// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"template/internal/ent/course"
	"template/internal/ent/coursesection"
	"template/internal/ent/media"
	"template/internal/ent/permission"
	"template/internal/ent/predicate"
	"template/internal/ent/question"
	"template/internal/ent/questionoption"
	"template/internal/ent/role"
	"template/internal/ent/test"
	"template/internal/ent/testsession"
	"template/internal/ent/todo"
	"template/internal/ent/user"
	"template/internal/ent/userquestionanswer"
	"template/internal/ent/userrole"
	"template/internal/ent/video"
	"template/internal/ent/videoquestiontimestamp"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCourse                 = "Course"
	TypeCourseSection          = "CourseSection"
	TypeMedia                  = "Media"
	TypePermission             = "Permission"
	TypeQuestion               = "Question"
	TypeQuestionOption         = "QuestionOption"
	TypeRole                   = "Role"
	TypeTest                   = "Test"
	TypeTestSession            = "TestSession"
	TypeTodo                   = "Todo"
	TypeUser                   = "User"
	TypeUserQuestionAnswer     = "UserQuestionAnswer"
	TypeUserRole               = "UserRole"
	TypeVideo                  = "Video"
	TypeVideoQuestionTimestamp = "VideoQuestionTimestamp"
)

// CourseMutation represents an operation that mutates the Course nodes in the graph.
type CourseMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	title                  *string
	description            *string
	is_published           *bool
	clearedFields          map[string]struct{}
	media                  *uuid.UUID
	clearedmedia           bool
	creator                *uuid.UUID
	clearedcreator         bool
	course_sections        map[uuid.UUID]struct{}
	removedcourse_sections map[uuid.UUID]struct{}
	clearedcourse_sections bool
	course_videos          map[uuid.UUID]struct{}
	removedcourse_videos   map[uuid.UUID]struct{}
	clearedcourse_videos   bool
	tests                  map[uuid.UUID]struct{}
	removedtests           map[uuid.UUID]struct{}
	clearedtests           bool
	done                   bool
	oldValue               func(context.Context) (*Course, error)
	predicates             []predicate.Course
}

var _ ent.Mutation = (*CourseMutation)(nil)

// courseOption allows management of the mutation configuration using functional options.
type courseOption func(*CourseMutation)

// newCourseMutation creates new mutation for the Course entity.
func newCourseMutation(c config, op Op, opts ...courseOption) *CourseMutation {
	m := &CourseMutation{
		config:        c,
		op:            op,
		typ:           TypeCourse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCourseID sets the ID field of the mutation.
func withCourseID(id uuid.UUID) courseOption {
	return func(m *CourseMutation) {
		var (
			err   error
			once  sync.Once
			value *Course
		)
		m.oldValue = func(ctx context.Context) (*Course, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Course.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCourse sets the old Course of the mutation.
func withCourse(node *Course) courseOption {
	return func(m *CourseMutation) {
		m.oldValue = func(context.Context) (*Course, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CourseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CourseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Course entities.
func (m *CourseMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CourseMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CourseMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Course.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CourseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CourseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CourseMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CourseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CourseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CourseMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CourseMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CourseMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CourseMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[course.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CourseMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[course.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CourseMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, course.FieldDeletedAt)
}

// SetTitle sets the "title" field.
func (m *CourseMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *CourseMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *CourseMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *CourseMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CourseMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CourseMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[course.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CourseMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[course.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CourseMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, course.FieldDescription)
}

// SetMediaID sets the "media_id" field.
func (m *CourseMutation) SetMediaID(u uuid.UUID) {
	m.media = &u
}

// MediaID returns the value of the "media_id" field in the mutation.
func (m *CourseMutation) MediaID() (r uuid.UUID, exists bool) {
	v := m.media
	if v == nil {
		return
	}
	return *v, true
}

// OldMediaID returns the old "media_id" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldMediaID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMediaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMediaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMediaID: %w", err)
	}
	return oldValue.MediaID, nil
}

// ClearMediaID clears the value of the "media_id" field.
func (m *CourseMutation) ClearMediaID() {
	m.media = nil
	m.clearedFields[course.FieldMediaID] = struct{}{}
}

// MediaIDCleared returns if the "media_id" field was cleared in this mutation.
func (m *CourseMutation) MediaIDCleared() bool {
	_, ok := m.clearedFields[course.FieldMediaID]
	return ok
}

// ResetMediaID resets all changes to the "media_id" field.
func (m *CourseMutation) ResetMediaID() {
	m.media = nil
	delete(m.clearedFields, course.FieldMediaID)
}

// SetCreatorID sets the "creator_id" field.
func (m *CourseMutation) SetCreatorID(u uuid.UUID) {
	m.creator = &u
}

// CreatorID returns the value of the "creator_id" field in the mutation.
func (m *CourseMutation) CreatorID() (r uuid.UUID, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorID returns the old "creator_id" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldCreatorID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorID: %w", err)
	}
	return oldValue.CreatorID, nil
}

// ResetCreatorID resets all changes to the "creator_id" field.
func (m *CourseMutation) ResetCreatorID() {
	m.creator = nil
}

// SetIsPublished sets the "is_published" field.
func (m *CourseMutation) SetIsPublished(b bool) {
	m.is_published = &b
}

// IsPublished returns the value of the "is_published" field in the mutation.
func (m *CourseMutation) IsPublished() (r bool, exists bool) {
	v := m.is_published
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublished returns the old "is_published" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldIsPublished(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublished is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublished requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublished: %w", err)
	}
	return oldValue.IsPublished, nil
}

// ResetIsPublished resets all changes to the "is_published" field.
func (m *CourseMutation) ResetIsPublished() {
	m.is_published = nil
}

// ClearMedia clears the "media" edge to the Media entity.
func (m *CourseMutation) ClearMedia() {
	m.clearedmedia = true
	m.clearedFields[course.FieldMediaID] = struct{}{}
}

// MediaCleared reports if the "media" edge to the Media entity was cleared.
func (m *CourseMutation) MediaCleared() bool {
	return m.MediaIDCleared() || m.clearedmedia
}

// MediaIDs returns the "media" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MediaID instead. It exists only for internal usage by the builders.
func (m *CourseMutation) MediaIDs() (ids []uuid.UUID) {
	if id := m.media; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMedia resets all changes to the "media" edge.
func (m *CourseMutation) ResetMedia() {
	m.media = nil
	m.clearedmedia = false
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *CourseMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[course.FieldCreatorID] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *CourseMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *CourseMutation) CreatorIDs() (ids []uuid.UUID) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *CourseMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// AddCourseSectionIDs adds the "course_sections" edge to the CourseSection entity by ids.
func (m *CourseMutation) AddCourseSectionIDs(ids ...uuid.UUID) {
	if m.course_sections == nil {
		m.course_sections = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.course_sections[ids[i]] = struct{}{}
	}
}

// ClearCourseSections clears the "course_sections" edge to the CourseSection entity.
func (m *CourseMutation) ClearCourseSections() {
	m.clearedcourse_sections = true
}

// CourseSectionsCleared reports if the "course_sections" edge to the CourseSection entity was cleared.
func (m *CourseMutation) CourseSectionsCleared() bool {
	return m.clearedcourse_sections
}

// RemoveCourseSectionIDs removes the "course_sections" edge to the CourseSection entity by IDs.
func (m *CourseMutation) RemoveCourseSectionIDs(ids ...uuid.UUID) {
	if m.removedcourse_sections == nil {
		m.removedcourse_sections = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.course_sections, ids[i])
		m.removedcourse_sections[ids[i]] = struct{}{}
	}
}

// RemovedCourseSections returns the removed IDs of the "course_sections" edge to the CourseSection entity.
func (m *CourseMutation) RemovedCourseSectionsIDs() (ids []uuid.UUID) {
	for id := range m.removedcourse_sections {
		ids = append(ids, id)
	}
	return
}

// CourseSectionsIDs returns the "course_sections" edge IDs in the mutation.
func (m *CourseMutation) CourseSectionsIDs() (ids []uuid.UUID) {
	for id := range m.course_sections {
		ids = append(ids, id)
	}
	return
}

// ResetCourseSections resets all changes to the "course_sections" edge.
func (m *CourseMutation) ResetCourseSections() {
	m.course_sections = nil
	m.clearedcourse_sections = false
	m.removedcourse_sections = nil
}

// AddCourseVideoIDs adds the "course_videos" edge to the Video entity by ids.
func (m *CourseMutation) AddCourseVideoIDs(ids ...uuid.UUID) {
	if m.course_videos == nil {
		m.course_videos = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.course_videos[ids[i]] = struct{}{}
	}
}

// ClearCourseVideos clears the "course_videos" edge to the Video entity.
func (m *CourseMutation) ClearCourseVideos() {
	m.clearedcourse_videos = true
}

// CourseVideosCleared reports if the "course_videos" edge to the Video entity was cleared.
func (m *CourseMutation) CourseVideosCleared() bool {
	return m.clearedcourse_videos
}

// RemoveCourseVideoIDs removes the "course_videos" edge to the Video entity by IDs.
func (m *CourseMutation) RemoveCourseVideoIDs(ids ...uuid.UUID) {
	if m.removedcourse_videos == nil {
		m.removedcourse_videos = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.course_videos, ids[i])
		m.removedcourse_videos[ids[i]] = struct{}{}
	}
}

// RemovedCourseVideos returns the removed IDs of the "course_videos" edge to the Video entity.
func (m *CourseMutation) RemovedCourseVideosIDs() (ids []uuid.UUID) {
	for id := range m.removedcourse_videos {
		ids = append(ids, id)
	}
	return
}

// CourseVideosIDs returns the "course_videos" edge IDs in the mutation.
func (m *CourseMutation) CourseVideosIDs() (ids []uuid.UUID) {
	for id := range m.course_videos {
		ids = append(ids, id)
	}
	return
}

// ResetCourseVideos resets all changes to the "course_videos" edge.
func (m *CourseMutation) ResetCourseVideos() {
	m.course_videos = nil
	m.clearedcourse_videos = false
	m.removedcourse_videos = nil
}

// AddTestIDs adds the "tests" edge to the Test entity by ids.
func (m *CourseMutation) AddTestIDs(ids ...uuid.UUID) {
	if m.tests == nil {
		m.tests = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tests[ids[i]] = struct{}{}
	}
}

// ClearTests clears the "tests" edge to the Test entity.
func (m *CourseMutation) ClearTests() {
	m.clearedtests = true
}

// TestsCleared reports if the "tests" edge to the Test entity was cleared.
func (m *CourseMutation) TestsCleared() bool {
	return m.clearedtests
}

// RemoveTestIDs removes the "tests" edge to the Test entity by IDs.
func (m *CourseMutation) RemoveTestIDs(ids ...uuid.UUID) {
	if m.removedtests == nil {
		m.removedtests = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tests, ids[i])
		m.removedtests[ids[i]] = struct{}{}
	}
}

// RemovedTests returns the removed IDs of the "tests" edge to the Test entity.
func (m *CourseMutation) RemovedTestsIDs() (ids []uuid.UUID) {
	for id := range m.removedtests {
		ids = append(ids, id)
	}
	return
}

// TestsIDs returns the "tests" edge IDs in the mutation.
func (m *CourseMutation) TestsIDs() (ids []uuid.UUID) {
	for id := range m.tests {
		ids = append(ids, id)
	}
	return
}

// ResetTests resets all changes to the "tests" edge.
func (m *CourseMutation) ResetTests() {
	m.tests = nil
	m.clearedtests = false
	m.removedtests = nil
}

// Where appends a list predicates to the CourseMutation builder.
func (m *CourseMutation) Where(ps ...predicate.Course) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CourseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CourseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Course, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CourseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CourseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Course).
func (m *CourseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CourseMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, course.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, course.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, course.FieldDeletedAt)
	}
	if m.title != nil {
		fields = append(fields, course.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, course.FieldDescription)
	}
	if m.media != nil {
		fields = append(fields, course.FieldMediaID)
	}
	if m.creator != nil {
		fields = append(fields, course.FieldCreatorID)
	}
	if m.is_published != nil {
		fields = append(fields, course.FieldIsPublished)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CourseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case course.FieldCreatedAt:
		return m.CreatedAt()
	case course.FieldUpdatedAt:
		return m.UpdatedAt()
	case course.FieldDeletedAt:
		return m.DeletedAt()
	case course.FieldTitle:
		return m.Title()
	case course.FieldDescription:
		return m.Description()
	case course.FieldMediaID:
		return m.MediaID()
	case course.FieldCreatorID:
		return m.CreatorID()
	case course.FieldIsPublished:
		return m.IsPublished()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CourseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case course.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case course.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case course.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case course.FieldTitle:
		return m.OldTitle(ctx)
	case course.FieldDescription:
		return m.OldDescription(ctx)
	case course.FieldMediaID:
		return m.OldMediaID(ctx)
	case course.FieldCreatorID:
		return m.OldCreatorID(ctx)
	case course.FieldIsPublished:
		return m.OldIsPublished(ctx)
	}
	return nil, fmt.Errorf("unknown Course field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case course.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case course.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case course.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case course.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case course.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case course.FieldMediaID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMediaID(v)
		return nil
	case course.FieldCreatorID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorID(v)
		return nil
	case course.FieldIsPublished:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublished(v)
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CourseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CourseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Course numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CourseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(course.FieldDeletedAt) {
		fields = append(fields, course.FieldDeletedAt)
	}
	if m.FieldCleared(course.FieldDescription) {
		fields = append(fields, course.FieldDescription)
	}
	if m.FieldCleared(course.FieldMediaID) {
		fields = append(fields, course.FieldMediaID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CourseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CourseMutation) ClearField(name string) error {
	switch name {
	case course.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case course.FieldDescription:
		m.ClearDescription()
		return nil
	case course.FieldMediaID:
		m.ClearMediaID()
		return nil
	}
	return fmt.Errorf("unknown Course nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CourseMutation) ResetField(name string) error {
	switch name {
	case course.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case course.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case course.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case course.FieldTitle:
		m.ResetTitle()
		return nil
	case course.FieldDescription:
		m.ResetDescription()
		return nil
	case course.FieldMediaID:
		m.ResetMediaID()
		return nil
	case course.FieldCreatorID:
		m.ResetCreatorID()
		return nil
	case course.FieldIsPublished:
		m.ResetIsPublished()
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CourseMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.media != nil {
		edges = append(edges, course.EdgeMedia)
	}
	if m.creator != nil {
		edges = append(edges, course.EdgeCreator)
	}
	if m.course_sections != nil {
		edges = append(edges, course.EdgeCourseSections)
	}
	if m.course_videos != nil {
		edges = append(edges, course.EdgeCourseVideos)
	}
	if m.tests != nil {
		edges = append(edges, course.EdgeTests)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CourseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case course.EdgeMedia:
		if id := m.media; id != nil {
			return []ent.Value{*id}
		}
	case course.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case course.EdgeCourseSections:
		ids := make([]ent.Value, 0, len(m.course_sections))
		for id := range m.course_sections {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeCourseVideos:
		ids := make([]ent.Value, 0, len(m.course_videos))
		for id := range m.course_videos {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeTests:
		ids := make([]ent.Value, 0, len(m.tests))
		for id := range m.tests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CourseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedcourse_sections != nil {
		edges = append(edges, course.EdgeCourseSections)
	}
	if m.removedcourse_videos != nil {
		edges = append(edges, course.EdgeCourseVideos)
	}
	if m.removedtests != nil {
		edges = append(edges, course.EdgeTests)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CourseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case course.EdgeCourseSections:
		ids := make([]ent.Value, 0, len(m.removedcourse_sections))
		for id := range m.removedcourse_sections {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeCourseVideos:
		ids := make([]ent.Value, 0, len(m.removedcourse_videos))
		for id := range m.removedcourse_videos {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeTests:
		ids := make([]ent.Value, 0, len(m.removedtests))
		for id := range m.removedtests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CourseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedmedia {
		edges = append(edges, course.EdgeMedia)
	}
	if m.clearedcreator {
		edges = append(edges, course.EdgeCreator)
	}
	if m.clearedcourse_sections {
		edges = append(edges, course.EdgeCourseSections)
	}
	if m.clearedcourse_videos {
		edges = append(edges, course.EdgeCourseVideos)
	}
	if m.clearedtests {
		edges = append(edges, course.EdgeTests)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CourseMutation) EdgeCleared(name string) bool {
	switch name {
	case course.EdgeMedia:
		return m.clearedmedia
	case course.EdgeCreator:
		return m.clearedcreator
	case course.EdgeCourseSections:
		return m.clearedcourse_sections
	case course.EdgeCourseVideos:
		return m.clearedcourse_videos
	case course.EdgeTests:
		return m.clearedtests
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CourseMutation) ClearEdge(name string) error {
	switch name {
	case course.EdgeMedia:
		m.ClearMedia()
		return nil
	case course.EdgeCreator:
		m.ClearCreator()
		return nil
	}
	return fmt.Errorf("unknown Course unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CourseMutation) ResetEdge(name string) error {
	switch name {
	case course.EdgeMedia:
		m.ResetMedia()
		return nil
	case course.EdgeCreator:
		m.ResetCreator()
		return nil
	case course.EdgeCourseSections:
		m.ResetCourseSections()
		return nil
	case course.EdgeCourseVideos:
		m.ResetCourseVideos()
		return nil
	case course.EdgeTests:
		m.ResetTests()
		return nil
	}
	return fmt.Errorf("unknown Course edge %s", name)
}

// CourseSectionMutation represents an operation that mutates the CourseSection nodes in the graph.
type CourseSectionMutation struct {
	config
	op                           Op
	typ                          string
	id                           *uuid.UUID
	created_at                   *time.Time
	updated_at                   *time.Time
	deleted_at                   *time.Time
	title                        *string
	description                  *string
	_order                       *int
	add_order                    *int
	clearedFields                map[string]struct{}
	course                       *uuid.UUID
	clearedcourse                bool
	parent                       *uuid.UUID
	clearedparent                bool
	children                     map[uuid.UUID]struct{}
	removedchildren              map[uuid.UUID]struct{}
	clearedchildren              bool
	course_section_videos        map[uuid.UUID]struct{}
	removedcourse_section_videos map[uuid.UUID]struct{}
	clearedcourse_section_videos bool
	questions                    map[uuid.UUID]struct{}
	removedquestions             map[uuid.UUID]struct{}
	clearedquestions             bool
	test_sessions                map[uuid.UUID]struct{}
	removedtest_sessions         map[uuid.UUID]struct{}
	clearedtest_sessions         bool
	tests                        map[uuid.UUID]struct{}
	removedtests                 map[uuid.UUID]struct{}
	clearedtests                 bool
	done                         bool
	oldValue                     func(context.Context) (*CourseSection, error)
	predicates                   []predicate.CourseSection
}

var _ ent.Mutation = (*CourseSectionMutation)(nil)

// coursesectionOption allows management of the mutation configuration using functional options.
type coursesectionOption func(*CourseSectionMutation)

// newCourseSectionMutation creates new mutation for the CourseSection entity.
func newCourseSectionMutation(c config, op Op, opts ...coursesectionOption) *CourseSectionMutation {
	m := &CourseSectionMutation{
		config:        c,
		op:            op,
		typ:           TypeCourseSection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCourseSectionID sets the ID field of the mutation.
func withCourseSectionID(id uuid.UUID) coursesectionOption {
	return func(m *CourseSectionMutation) {
		var (
			err   error
			once  sync.Once
			value *CourseSection
		)
		m.oldValue = func(ctx context.Context) (*CourseSection, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CourseSection.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCourseSection sets the old CourseSection of the mutation.
func withCourseSection(node *CourseSection) coursesectionOption {
	return func(m *CourseSectionMutation) {
		m.oldValue = func(context.Context) (*CourseSection, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CourseSectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CourseSectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CourseSection entities.
func (m *CourseSectionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CourseSectionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CourseSectionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CourseSection.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CourseSectionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CourseSectionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CourseSection entity.
// If the CourseSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseSectionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CourseSectionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CourseSectionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CourseSectionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CourseSection entity.
// If the CourseSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseSectionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CourseSectionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CourseSectionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CourseSectionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CourseSection entity.
// If the CourseSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseSectionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CourseSectionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[coursesection.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CourseSectionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[coursesection.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CourseSectionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, coursesection.FieldDeletedAt)
}

// SetCourseID sets the "course_id" field.
func (m *CourseSectionMutation) SetCourseID(u uuid.UUID) {
	m.course = &u
}

// CourseID returns the value of the "course_id" field in the mutation.
func (m *CourseSectionMutation) CourseID() (r uuid.UUID, exists bool) {
	v := m.course
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseID returns the old "course_id" field's value of the CourseSection entity.
// If the CourseSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseSectionMutation) OldCourseID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCourseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCourseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseID: %w", err)
	}
	return oldValue.CourseID, nil
}

// ResetCourseID resets all changes to the "course_id" field.
func (m *CourseSectionMutation) ResetCourseID() {
	m.course = nil
}

// SetSectionID sets the "section_id" field.
func (m *CourseSectionMutation) SetSectionID(u uuid.UUID) {
	m.parent = &u
}

// SectionID returns the value of the "section_id" field in the mutation.
func (m *CourseSectionMutation) SectionID() (r uuid.UUID, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldSectionID returns the old "section_id" field's value of the CourseSection entity.
// If the CourseSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseSectionMutation) OldSectionID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSectionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSectionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSectionID: %w", err)
	}
	return oldValue.SectionID, nil
}

// ClearSectionID clears the value of the "section_id" field.
func (m *CourseSectionMutation) ClearSectionID() {
	m.parent = nil
	m.clearedFields[coursesection.FieldSectionID] = struct{}{}
}

// SectionIDCleared returns if the "section_id" field was cleared in this mutation.
func (m *CourseSectionMutation) SectionIDCleared() bool {
	_, ok := m.clearedFields[coursesection.FieldSectionID]
	return ok
}

// ResetSectionID resets all changes to the "section_id" field.
func (m *CourseSectionMutation) ResetSectionID() {
	m.parent = nil
	delete(m.clearedFields, coursesection.FieldSectionID)
}

// SetTitle sets the "title" field.
func (m *CourseSectionMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *CourseSectionMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the CourseSection entity.
// If the CourseSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseSectionMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *CourseSectionMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *CourseSectionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CourseSectionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the CourseSection entity.
// If the CourseSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseSectionMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CourseSectionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[coursesection.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CourseSectionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[coursesection.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CourseSectionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, coursesection.FieldDescription)
}

// SetOrder sets the "order" field.
func (m *CourseSectionMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *CourseSectionMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the CourseSection entity.
// If the CourseSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseSectionMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *CourseSectionMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *CourseSectionMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *CourseSectionMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// ClearCourse clears the "course" edge to the Course entity.
func (m *CourseSectionMutation) ClearCourse() {
	m.clearedcourse = true
	m.clearedFields[coursesection.FieldCourseID] = struct{}{}
}

// CourseCleared reports if the "course" edge to the Course entity was cleared.
func (m *CourseSectionMutation) CourseCleared() bool {
	return m.clearedcourse
}

// CourseIDs returns the "course" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CourseID instead. It exists only for internal usage by the builders.
func (m *CourseSectionMutation) CourseIDs() (ids []uuid.UUID) {
	if id := m.course; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourse resets all changes to the "course" edge.
func (m *CourseSectionMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
}

// SetParentID sets the "parent" edge to the CourseSection entity by id.
func (m *CourseSectionMutation) SetParentID(id uuid.UUID) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the CourseSection entity.
func (m *CourseSectionMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[coursesection.FieldSectionID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the CourseSection entity was cleared.
func (m *CourseSectionMutation) ParentCleared() bool {
	return m.SectionIDCleared() || m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *CourseSectionMutation) ParentID() (id uuid.UUID, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *CourseSectionMutation) ParentIDs() (ids []uuid.UUID) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *CourseSectionMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the CourseSection entity by ids.
func (m *CourseSectionMutation) AddChildIDs(ids ...uuid.UUID) {
	if m.children == nil {
		m.children = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the CourseSection entity.
func (m *CourseSectionMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the CourseSection entity was cleared.
func (m *CourseSectionMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the CourseSection entity by IDs.
func (m *CourseSectionMutation) RemoveChildIDs(ids ...uuid.UUID) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the CourseSection entity.
func (m *CourseSectionMutation) RemovedChildrenIDs() (ids []uuid.UUID) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *CourseSectionMutation) ChildrenIDs() (ids []uuid.UUID) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *CourseSectionMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddCourseSectionVideoIDs adds the "course_section_videos" edge to the Video entity by ids.
func (m *CourseSectionMutation) AddCourseSectionVideoIDs(ids ...uuid.UUID) {
	if m.course_section_videos == nil {
		m.course_section_videos = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.course_section_videos[ids[i]] = struct{}{}
	}
}

// ClearCourseSectionVideos clears the "course_section_videos" edge to the Video entity.
func (m *CourseSectionMutation) ClearCourseSectionVideos() {
	m.clearedcourse_section_videos = true
}

// CourseSectionVideosCleared reports if the "course_section_videos" edge to the Video entity was cleared.
func (m *CourseSectionMutation) CourseSectionVideosCleared() bool {
	return m.clearedcourse_section_videos
}

// RemoveCourseSectionVideoIDs removes the "course_section_videos" edge to the Video entity by IDs.
func (m *CourseSectionMutation) RemoveCourseSectionVideoIDs(ids ...uuid.UUID) {
	if m.removedcourse_section_videos == nil {
		m.removedcourse_section_videos = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.course_section_videos, ids[i])
		m.removedcourse_section_videos[ids[i]] = struct{}{}
	}
}

// RemovedCourseSectionVideos returns the removed IDs of the "course_section_videos" edge to the Video entity.
func (m *CourseSectionMutation) RemovedCourseSectionVideosIDs() (ids []uuid.UUID) {
	for id := range m.removedcourse_section_videos {
		ids = append(ids, id)
	}
	return
}

// CourseSectionVideosIDs returns the "course_section_videos" edge IDs in the mutation.
func (m *CourseSectionMutation) CourseSectionVideosIDs() (ids []uuid.UUID) {
	for id := range m.course_section_videos {
		ids = append(ids, id)
	}
	return
}

// ResetCourseSectionVideos resets all changes to the "course_section_videos" edge.
func (m *CourseSectionMutation) ResetCourseSectionVideos() {
	m.course_section_videos = nil
	m.clearedcourse_section_videos = false
	m.removedcourse_section_videos = nil
}

// AddQuestionIDs adds the "questions" edge to the Question entity by ids.
func (m *CourseSectionMutation) AddQuestionIDs(ids ...uuid.UUID) {
	if m.questions == nil {
		m.questions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.questions[ids[i]] = struct{}{}
	}
}

// ClearQuestions clears the "questions" edge to the Question entity.
func (m *CourseSectionMutation) ClearQuestions() {
	m.clearedquestions = true
}

// QuestionsCleared reports if the "questions" edge to the Question entity was cleared.
func (m *CourseSectionMutation) QuestionsCleared() bool {
	return m.clearedquestions
}

// RemoveQuestionIDs removes the "questions" edge to the Question entity by IDs.
func (m *CourseSectionMutation) RemoveQuestionIDs(ids ...uuid.UUID) {
	if m.removedquestions == nil {
		m.removedquestions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.questions, ids[i])
		m.removedquestions[ids[i]] = struct{}{}
	}
}

// RemovedQuestions returns the removed IDs of the "questions" edge to the Question entity.
func (m *CourseSectionMutation) RemovedQuestionsIDs() (ids []uuid.UUID) {
	for id := range m.removedquestions {
		ids = append(ids, id)
	}
	return
}

// QuestionsIDs returns the "questions" edge IDs in the mutation.
func (m *CourseSectionMutation) QuestionsIDs() (ids []uuid.UUID) {
	for id := range m.questions {
		ids = append(ids, id)
	}
	return
}

// ResetQuestions resets all changes to the "questions" edge.
func (m *CourseSectionMutation) ResetQuestions() {
	m.questions = nil
	m.clearedquestions = false
	m.removedquestions = nil
}

// AddTestSessionIDs adds the "test_sessions" edge to the TestSession entity by ids.
func (m *CourseSectionMutation) AddTestSessionIDs(ids ...uuid.UUID) {
	if m.test_sessions == nil {
		m.test_sessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.test_sessions[ids[i]] = struct{}{}
	}
}

// ClearTestSessions clears the "test_sessions" edge to the TestSession entity.
func (m *CourseSectionMutation) ClearTestSessions() {
	m.clearedtest_sessions = true
}

// TestSessionsCleared reports if the "test_sessions" edge to the TestSession entity was cleared.
func (m *CourseSectionMutation) TestSessionsCleared() bool {
	return m.clearedtest_sessions
}

// RemoveTestSessionIDs removes the "test_sessions" edge to the TestSession entity by IDs.
func (m *CourseSectionMutation) RemoveTestSessionIDs(ids ...uuid.UUID) {
	if m.removedtest_sessions == nil {
		m.removedtest_sessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.test_sessions, ids[i])
		m.removedtest_sessions[ids[i]] = struct{}{}
	}
}

// RemovedTestSessions returns the removed IDs of the "test_sessions" edge to the TestSession entity.
func (m *CourseSectionMutation) RemovedTestSessionsIDs() (ids []uuid.UUID) {
	for id := range m.removedtest_sessions {
		ids = append(ids, id)
	}
	return
}

// TestSessionsIDs returns the "test_sessions" edge IDs in the mutation.
func (m *CourseSectionMutation) TestSessionsIDs() (ids []uuid.UUID) {
	for id := range m.test_sessions {
		ids = append(ids, id)
	}
	return
}

// ResetTestSessions resets all changes to the "test_sessions" edge.
func (m *CourseSectionMutation) ResetTestSessions() {
	m.test_sessions = nil
	m.clearedtest_sessions = false
	m.removedtest_sessions = nil
}

// AddTestIDs adds the "tests" edge to the Test entity by ids.
func (m *CourseSectionMutation) AddTestIDs(ids ...uuid.UUID) {
	if m.tests == nil {
		m.tests = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tests[ids[i]] = struct{}{}
	}
}

// ClearTests clears the "tests" edge to the Test entity.
func (m *CourseSectionMutation) ClearTests() {
	m.clearedtests = true
}

// TestsCleared reports if the "tests" edge to the Test entity was cleared.
func (m *CourseSectionMutation) TestsCleared() bool {
	return m.clearedtests
}

// RemoveTestIDs removes the "tests" edge to the Test entity by IDs.
func (m *CourseSectionMutation) RemoveTestIDs(ids ...uuid.UUID) {
	if m.removedtests == nil {
		m.removedtests = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tests, ids[i])
		m.removedtests[ids[i]] = struct{}{}
	}
}

// RemovedTests returns the removed IDs of the "tests" edge to the Test entity.
func (m *CourseSectionMutation) RemovedTestsIDs() (ids []uuid.UUID) {
	for id := range m.removedtests {
		ids = append(ids, id)
	}
	return
}

// TestsIDs returns the "tests" edge IDs in the mutation.
func (m *CourseSectionMutation) TestsIDs() (ids []uuid.UUID) {
	for id := range m.tests {
		ids = append(ids, id)
	}
	return
}

// ResetTests resets all changes to the "tests" edge.
func (m *CourseSectionMutation) ResetTests() {
	m.tests = nil
	m.clearedtests = false
	m.removedtests = nil
}

// Where appends a list predicates to the CourseSectionMutation builder.
func (m *CourseSectionMutation) Where(ps ...predicate.CourseSection) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CourseSectionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CourseSectionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CourseSection, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CourseSectionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CourseSectionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CourseSection).
func (m *CourseSectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CourseSectionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, coursesection.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, coursesection.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, coursesection.FieldDeletedAt)
	}
	if m.course != nil {
		fields = append(fields, coursesection.FieldCourseID)
	}
	if m.parent != nil {
		fields = append(fields, coursesection.FieldSectionID)
	}
	if m.title != nil {
		fields = append(fields, coursesection.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, coursesection.FieldDescription)
	}
	if m._order != nil {
		fields = append(fields, coursesection.FieldOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CourseSectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case coursesection.FieldCreatedAt:
		return m.CreatedAt()
	case coursesection.FieldUpdatedAt:
		return m.UpdatedAt()
	case coursesection.FieldDeletedAt:
		return m.DeletedAt()
	case coursesection.FieldCourseID:
		return m.CourseID()
	case coursesection.FieldSectionID:
		return m.SectionID()
	case coursesection.FieldTitle:
		return m.Title()
	case coursesection.FieldDescription:
		return m.Description()
	case coursesection.FieldOrder:
		return m.Order()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CourseSectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case coursesection.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case coursesection.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case coursesection.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case coursesection.FieldCourseID:
		return m.OldCourseID(ctx)
	case coursesection.FieldSectionID:
		return m.OldSectionID(ctx)
	case coursesection.FieldTitle:
		return m.OldTitle(ctx)
	case coursesection.FieldDescription:
		return m.OldDescription(ctx)
	case coursesection.FieldOrder:
		return m.OldOrder(ctx)
	}
	return nil, fmt.Errorf("unknown CourseSection field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseSectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case coursesection.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case coursesection.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case coursesection.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case coursesection.FieldCourseID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseID(v)
		return nil
	case coursesection.FieldSectionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSectionID(v)
		return nil
	case coursesection.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case coursesection.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case coursesection.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	}
	return fmt.Errorf("unknown CourseSection field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CourseSectionMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, coursesection.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CourseSectionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case coursesection.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseSectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case coursesection.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown CourseSection numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CourseSectionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(coursesection.FieldDeletedAt) {
		fields = append(fields, coursesection.FieldDeletedAt)
	}
	if m.FieldCleared(coursesection.FieldSectionID) {
		fields = append(fields, coursesection.FieldSectionID)
	}
	if m.FieldCleared(coursesection.FieldDescription) {
		fields = append(fields, coursesection.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CourseSectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CourseSectionMutation) ClearField(name string) error {
	switch name {
	case coursesection.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case coursesection.FieldSectionID:
		m.ClearSectionID()
		return nil
	case coursesection.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown CourseSection nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CourseSectionMutation) ResetField(name string) error {
	switch name {
	case coursesection.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case coursesection.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case coursesection.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case coursesection.FieldCourseID:
		m.ResetCourseID()
		return nil
	case coursesection.FieldSectionID:
		m.ResetSectionID()
		return nil
	case coursesection.FieldTitle:
		m.ResetTitle()
		return nil
	case coursesection.FieldDescription:
		m.ResetDescription()
		return nil
	case coursesection.FieldOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown CourseSection field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CourseSectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.course != nil {
		edges = append(edges, coursesection.EdgeCourse)
	}
	if m.parent != nil {
		edges = append(edges, coursesection.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, coursesection.EdgeChildren)
	}
	if m.course_section_videos != nil {
		edges = append(edges, coursesection.EdgeCourseSectionVideos)
	}
	if m.questions != nil {
		edges = append(edges, coursesection.EdgeQuestions)
	}
	if m.test_sessions != nil {
		edges = append(edges, coursesection.EdgeTestSessions)
	}
	if m.tests != nil {
		edges = append(edges, coursesection.EdgeTests)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CourseSectionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case coursesection.EdgeCourse:
		if id := m.course; id != nil {
			return []ent.Value{*id}
		}
	case coursesection.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case coursesection.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case coursesection.EdgeCourseSectionVideos:
		ids := make([]ent.Value, 0, len(m.course_section_videos))
		for id := range m.course_section_videos {
			ids = append(ids, id)
		}
		return ids
	case coursesection.EdgeQuestions:
		ids := make([]ent.Value, 0, len(m.questions))
		for id := range m.questions {
			ids = append(ids, id)
		}
		return ids
	case coursesection.EdgeTestSessions:
		ids := make([]ent.Value, 0, len(m.test_sessions))
		for id := range m.test_sessions {
			ids = append(ids, id)
		}
		return ids
	case coursesection.EdgeTests:
		ids := make([]ent.Value, 0, len(m.tests))
		for id := range m.tests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CourseSectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedchildren != nil {
		edges = append(edges, coursesection.EdgeChildren)
	}
	if m.removedcourse_section_videos != nil {
		edges = append(edges, coursesection.EdgeCourseSectionVideos)
	}
	if m.removedquestions != nil {
		edges = append(edges, coursesection.EdgeQuestions)
	}
	if m.removedtest_sessions != nil {
		edges = append(edges, coursesection.EdgeTestSessions)
	}
	if m.removedtests != nil {
		edges = append(edges, coursesection.EdgeTests)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CourseSectionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case coursesection.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case coursesection.EdgeCourseSectionVideos:
		ids := make([]ent.Value, 0, len(m.removedcourse_section_videos))
		for id := range m.removedcourse_section_videos {
			ids = append(ids, id)
		}
		return ids
	case coursesection.EdgeQuestions:
		ids := make([]ent.Value, 0, len(m.removedquestions))
		for id := range m.removedquestions {
			ids = append(ids, id)
		}
		return ids
	case coursesection.EdgeTestSessions:
		ids := make([]ent.Value, 0, len(m.removedtest_sessions))
		for id := range m.removedtest_sessions {
			ids = append(ids, id)
		}
		return ids
	case coursesection.EdgeTests:
		ids := make([]ent.Value, 0, len(m.removedtests))
		for id := range m.removedtests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CourseSectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedcourse {
		edges = append(edges, coursesection.EdgeCourse)
	}
	if m.clearedparent {
		edges = append(edges, coursesection.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, coursesection.EdgeChildren)
	}
	if m.clearedcourse_section_videos {
		edges = append(edges, coursesection.EdgeCourseSectionVideos)
	}
	if m.clearedquestions {
		edges = append(edges, coursesection.EdgeQuestions)
	}
	if m.clearedtest_sessions {
		edges = append(edges, coursesection.EdgeTestSessions)
	}
	if m.clearedtests {
		edges = append(edges, coursesection.EdgeTests)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CourseSectionMutation) EdgeCleared(name string) bool {
	switch name {
	case coursesection.EdgeCourse:
		return m.clearedcourse
	case coursesection.EdgeParent:
		return m.clearedparent
	case coursesection.EdgeChildren:
		return m.clearedchildren
	case coursesection.EdgeCourseSectionVideos:
		return m.clearedcourse_section_videos
	case coursesection.EdgeQuestions:
		return m.clearedquestions
	case coursesection.EdgeTestSessions:
		return m.clearedtest_sessions
	case coursesection.EdgeTests:
		return m.clearedtests
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CourseSectionMutation) ClearEdge(name string) error {
	switch name {
	case coursesection.EdgeCourse:
		m.ClearCourse()
		return nil
	case coursesection.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown CourseSection unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CourseSectionMutation) ResetEdge(name string) error {
	switch name {
	case coursesection.EdgeCourse:
		m.ResetCourse()
		return nil
	case coursesection.EdgeParent:
		m.ResetParent()
		return nil
	case coursesection.EdgeChildren:
		m.ResetChildren()
		return nil
	case coursesection.EdgeCourseSectionVideos:
		m.ResetCourseSectionVideos()
		return nil
	case coursesection.EdgeQuestions:
		m.ResetQuestions()
		return nil
	case coursesection.EdgeTestSessions:
		m.ResetTestSessions()
		return nil
	case coursesection.EdgeTests:
		m.ResetTests()
		return nil
	}
	return fmt.Errorf("unknown CourseSection edge %s", name)
}

// MediaMutation represents an operation that mutates the Media nodes in the graph.
type MediaMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	file_name           *string
	file_url            *string
	mime_type           *string
	metadata            *map[string]interface{}
	clearedFields       map[string]struct{}
	user_media          map[uuid.UUID]struct{}
	removeduser_media   map[uuid.UUID]struct{}
	cleareduser_media   bool
	user                *uuid.UUID
	cleareduser         bool
	course_media        map[uuid.UUID]struct{}
	removedcourse_media map[uuid.UUID]struct{}
	clearedcourse_media bool
	video_media         map[uuid.UUID]struct{}
	removedvideo_media  map[uuid.UUID]struct{}
	clearedvideo_media  bool
	done                bool
	oldValue            func(context.Context) (*Media, error)
	predicates          []predicate.Media
}

var _ ent.Mutation = (*MediaMutation)(nil)

// mediaOption allows management of the mutation configuration using functional options.
type mediaOption func(*MediaMutation)

// newMediaMutation creates new mutation for the Media entity.
func newMediaMutation(c config, op Op, opts ...mediaOption) *MediaMutation {
	m := &MediaMutation{
		config:        c,
		op:            op,
		typ:           TypeMedia,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMediaID sets the ID field of the mutation.
func withMediaID(id uuid.UUID) mediaOption {
	return func(m *MediaMutation) {
		var (
			err   error
			once  sync.Once
			value *Media
		)
		m.oldValue = func(ctx context.Context) (*Media, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Media.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMedia sets the old Media of the mutation.
func withMedia(node *Media) mediaOption {
	return func(m *MediaMutation) {
		m.oldValue = func(context.Context) (*Media, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MediaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MediaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Media entities.
func (m *MediaMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MediaMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MediaMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Media.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MediaMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MediaMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MediaMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MediaMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MediaMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MediaMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MediaMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MediaMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *MediaMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[media.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *MediaMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[media.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MediaMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, media.FieldDeletedAt)
}

// SetFileName sets the "file_name" field.
func (m *MediaMutation) SetFileName(s string) {
	m.file_name = &s
}

// FileName returns the value of the "file_name" field in the mutation.
func (m *MediaMutation) FileName() (r string, exists bool) {
	v := m.file_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFileName returns the old "file_name" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldFileName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileName: %w", err)
	}
	return oldValue.FileName, nil
}

// ResetFileName resets all changes to the "file_name" field.
func (m *MediaMutation) ResetFileName() {
	m.file_name = nil
}

// SetFileURL sets the "file_url" field.
func (m *MediaMutation) SetFileURL(s string) {
	m.file_url = &s
}

// FileURL returns the value of the "file_url" field in the mutation.
func (m *MediaMutation) FileURL() (r string, exists bool) {
	v := m.file_url
	if v == nil {
		return
	}
	return *v, true
}

// OldFileURL returns the old "file_url" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldFileURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileURL: %w", err)
	}
	return oldValue.FileURL, nil
}

// ResetFileURL resets all changes to the "file_url" field.
func (m *MediaMutation) ResetFileURL() {
	m.file_url = nil
}

// SetMimeType sets the "mime_type" field.
func (m *MediaMutation) SetMimeType(s string) {
	m.mime_type = &s
}

// MimeType returns the value of the "mime_type" field in the mutation.
func (m *MediaMutation) MimeType() (r string, exists bool) {
	v := m.mime_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMimeType returns the old "mime_type" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldMimeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMimeType: %w", err)
	}
	return oldValue.MimeType, nil
}

// ResetMimeType resets all changes to the "mime_type" field.
func (m *MediaMutation) ResetMimeType() {
	m.mime_type = nil
}

// SetUploaderID sets the "uploader_id" field.
func (m *MediaMutation) SetUploaderID(u uuid.UUID) {
	m.user = &u
}

// UploaderID returns the value of the "uploader_id" field in the mutation.
func (m *MediaMutation) UploaderID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUploaderID returns the old "uploader_id" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldUploaderID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUploaderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUploaderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploaderID: %w", err)
	}
	return oldValue.UploaderID, nil
}

// ClearUploaderID clears the value of the "uploader_id" field.
func (m *MediaMutation) ClearUploaderID() {
	m.user = nil
	m.clearedFields[media.FieldUploaderID] = struct{}{}
}

// UploaderIDCleared returns if the "uploader_id" field was cleared in this mutation.
func (m *MediaMutation) UploaderIDCleared() bool {
	_, ok := m.clearedFields[media.FieldUploaderID]
	return ok
}

// ResetUploaderID resets all changes to the "uploader_id" field.
func (m *MediaMutation) ResetUploaderID() {
	m.user = nil
	delete(m.clearedFields, media.FieldUploaderID)
}

// SetMetadata sets the "metadata" field.
func (m *MediaMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *MediaMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *MediaMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[media.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *MediaMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[media.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *MediaMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, media.FieldMetadata)
}

// AddUserMediumIDs adds the "user_media" edge to the User entity by ids.
func (m *MediaMutation) AddUserMediumIDs(ids ...uuid.UUID) {
	if m.user_media == nil {
		m.user_media = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_media[ids[i]] = struct{}{}
	}
}

// ClearUserMedia clears the "user_media" edge to the User entity.
func (m *MediaMutation) ClearUserMedia() {
	m.cleareduser_media = true
}

// UserMediaCleared reports if the "user_media" edge to the User entity was cleared.
func (m *MediaMutation) UserMediaCleared() bool {
	return m.cleareduser_media
}

// RemoveUserMediumIDs removes the "user_media" edge to the User entity by IDs.
func (m *MediaMutation) RemoveUserMediumIDs(ids ...uuid.UUID) {
	if m.removeduser_media == nil {
		m.removeduser_media = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_media, ids[i])
		m.removeduser_media[ids[i]] = struct{}{}
	}
}

// RemovedUserMedia returns the removed IDs of the "user_media" edge to the User entity.
func (m *MediaMutation) RemovedUserMediaIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_media {
		ids = append(ids, id)
	}
	return
}

// UserMediaIDs returns the "user_media" edge IDs in the mutation.
func (m *MediaMutation) UserMediaIDs() (ids []uuid.UUID) {
	for id := range m.user_media {
		ids = append(ids, id)
	}
	return
}

// ResetUserMedia resets all changes to the "user_media" edge.
func (m *MediaMutation) ResetUserMedia() {
	m.user_media = nil
	m.cleareduser_media = false
	m.removeduser_media = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *MediaMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *MediaMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[media.FieldUploaderID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *MediaMutation) UserCleared() bool {
	return m.UploaderIDCleared() || m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *MediaMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *MediaMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *MediaMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddCourseMediumIDs adds the "course_media" edge to the Course entity by ids.
func (m *MediaMutation) AddCourseMediumIDs(ids ...uuid.UUID) {
	if m.course_media == nil {
		m.course_media = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.course_media[ids[i]] = struct{}{}
	}
}

// ClearCourseMedia clears the "course_media" edge to the Course entity.
func (m *MediaMutation) ClearCourseMedia() {
	m.clearedcourse_media = true
}

// CourseMediaCleared reports if the "course_media" edge to the Course entity was cleared.
func (m *MediaMutation) CourseMediaCleared() bool {
	return m.clearedcourse_media
}

// RemoveCourseMediumIDs removes the "course_media" edge to the Course entity by IDs.
func (m *MediaMutation) RemoveCourseMediumIDs(ids ...uuid.UUID) {
	if m.removedcourse_media == nil {
		m.removedcourse_media = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.course_media, ids[i])
		m.removedcourse_media[ids[i]] = struct{}{}
	}
}

// RemovedCourseMedia returns the removed IDs of the "course_media" edge to the Course entity.
func (m *MediaMutation) RemovedCourseMediaIDs() (ids []uuid.UUID) {
	for id := range m.removedcourse_media {
		ids = append(ids, id)
	}
	return
}

// CourseMediaIDs returns the "course_media" edge IDs in the mutation.
func (m *MediaMutation) CourseMediaIDs() (ids []uuid.UUID) {
	for id := range m.course_media {
		ids = append(ids, id)
	}
	return
}

// ResetCourseMedia resets all changes to the "course_media" edge.
func (m *MediaMutation) ResetCourseMedia() {
	m.course_media = nil
	m.clearedcourse_media = false
	m.removedcourse_media = nil
}

// AddVideoMediumIDs adds the "video_media" edge to the Video entity by ids.
func (m *MediaMutation) AddVideoMediumIDs(ids ...uuid.UUID) {
	if m.video_media == nil {
		m.video_media = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.video_media[ids[i]] = struct{}{}
	}
}

// ClearVideoMedia clears the "video_media" edge to the Video entity.
func (m *MediaMutation) ClearVideoMedia() {
	m.clearedvideo_media = true
}

// VideoMediaCleared reports if the "video_media" edge to the Video entity was cleared.
func (m *MediaMutation) VideoMediaCleared() bool {
	return m.clearedvideo_media
}

// RemoveVideoMediumIDs removes the "video_media" edge to the Video entity by IDs.
func (m *MediaMutation) RemoveVideoMediumIDs(ids ...uuid.UUID) {
	if m.removedvideo_media == nil {
		m.removedvideo_media = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.video_media, ids[i])
		m.removedvideo_media[ids[i]] = struct{}{}
	}
}

// RemovedVideoMedia returns the removed IDs of the "video_media" edge to the Video entity.
func (m *MediaMutation) RemovedVideoMediaIDs() (ids []uuid.UUID) {
	for id := range m.removedvideo_media {
		ids = append(ids, id)
	}
	return
}

// VideoMediaIDs returns the "video_media" edge IDs in the mutation.
func (m *MediaMutation) VideoMediaIDs() (ids []uuid.UUID) {
	for id := range m.video_media {
		ids = append(ids, id)
	}
	return
}

// ResetVideoMedia resets all changes to the "video_media" edge.
func (m *MediaMutation) ResetVideoMedia() {
	m.video_media = nil
	m.clearedvideo_media = false
	m.removedvideo_media = nil
}

// Where appends a list predicates to the MediaMutation builder.
func (m *MediaMutation) Where(ps ...predicate.Media) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MediaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MediaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Media, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MediaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MediaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Media).
func (m *MediaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MediaMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, media.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, media.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, media.FieldDeletedAt)
	}
	if m.file_name != nil {
		fields = append(fields, media.FieldFileName)
	}
	if m.file_url != nil {
		fields = append(fields, media.FieldFileURL)
	}
	if m.mime_type != nil {
		fields = append(fields, media.FieldMimeType)
	}
	if m.user != nil {
		fields = append(fields, media.FieldUploaderID)
	}
	if m.metadata != nil {
		fields = append(fields, media.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MediaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case media.FieldCreatedAt:
		return m.CreatedAt()
	case media.FieldUpdatedAt:
		return m.UpdatedAt()
	case media.FieldDeletedAt:
		return m.DeletedAt()
	case media.FieldFileName:
		return m.FileName()
	case media.FieldFileURL:
		return m.FileURL()
	case media.FieldMimeType:
		return m.MimeType()
	case media.FieldUploaderID:
		return m.UploaderID()
	case media.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MediaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case media.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case media.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case media.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case media.FieldFileName:
		return m.OldFileName(ctx)
	case media.FieldFileURL:
		return m.OldFileURL(ctx)
	case media.FieldMimeType:
		return m.OldMimeType(ctx)
	case media.FieldUploaderID:
		return m.OldUploaderID(ctx)
	case media.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown Media field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MediaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case media.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case media.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case media.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case media.FieldFileName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileName(v)
		return nil
	case media.FieldFileURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileURL(v)
		return nil
	case media.FieldMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMimeType(v)
		return nil
	case media.FieldUploaderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploaderID(v)
		return nil
	case media.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown Media field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MediaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MediaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MediaMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Media numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MediaMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(media.FieldDeletedAt) {
		fields = append(fields, media.FieldDeletedAt)
	}
	if m.FieldCleared(media.FieldUploaderID) {
		fields = append(fields, media.FieldUploaderID)
	}
	if m.FieldCleared(media.FieldMetadata) {
		fields = append(fields, media.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MediaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MediaMutation) ClearField(name string) error {
	switch name {
	case media.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case media.FieldUploaderID:
		m.ClearUploaderID()
		return nil
	case media.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Media nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MediaMutation) ResetField(name string) error {
	switch name {
	case media.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case media.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case media.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case media.FieldFileName:
		m.ResetFileName()
		return nil
	case media.FieldFileURL:
		m.ResetFileURL()
		return nil
	case media.FieldMimeType:
		m.ResetMimeType()
		return nil
	case media.FieldUploaderID:
		m.ResetUploaderID()
		return nil
	case media.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown Media field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MediaMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user_media != nil {
		edges = append(edges, media.EdgeUserMedia)
	}
	if m.user != nil {
		edges = append(edges, media.EdgeUser)
	}
	if m.course_media != nil {
		edges = append(edges, media.EdgeCourseMedia)
	}
	if m.video_media != nil {
		edges = append(edges, media.EdgeVideoMedia)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MediaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case media.EdgeUserMedia:
		ids := make([]ent.Value, 0, len(m.user_media))
		for id := range m.user_media {
			ids = append(ids, id)
		}
		return ids
	case media.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case media.EdgeCourseMedia:
		ids := make([]ent.Value, 0, len(m.course_media))
		for id := range m.course_media {
			ids = append(ids, id)
		}
		return ids
	case media.EdgeVideoMedia:
		ids := make([]ent.Value, 0, len(m.video_media))
		for id := range m.video_media {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MediaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removeduser_media != nil {
		edges = append(edges, media.EdgeUserMedia)
	}
	if m.removedcourse_media != nil {
		edges = append(edges, media.EdgeCourseMedia)
	}
	if m.removedvideo_media != nil {
		edges = append(edges, media.EdgeVideoMedia)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MediaMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case media.EdgeUserMedia:
		ids := make([]ent.Value, 0, len(m.removeduser_media))
		for id := range m.removeduser_media {
			ids = append(ids, id)
		}
		return ids
	case media.EdgeCourseMedia:
		ids := make([]ent.Value, 0, len(m.removedcourse_media))
		for id := range m.removedcourse_media {
			ids = append(ids, id)
		}
		return ids
	case media.EdgeVideoMedia:
		ids := make([]ent.Value, 0, len(m.removedvideo_media))
		for id := range m.removedvideo_media {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MediaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser_media {
		edges = append(edges, media.EdgeUserMedia)
	}
	if m.cleareduser {
		edges = append(edges, media.EdgeUser)
	}
	if m.clearedcourse_media {
		edges = append(edges, media.EdgeCourseMedia)
	}
	if m.clearedvideo_media {
		edges = append(edges, media.EdgeVideoMedia)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MediaMutation) EdgeCleared(name string) bool {
	switch name {
	case media.EdgeUserMedia:
		return m.cleareduser_media
	case media.EdgeUser:
		return m.cleareduser
	case media.EdgeCourseMedia:
		return m.clearedcourse_media
	case media.EdgeVideoMedia:
		return m.clearedvideo_media
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MediaMutation) ClearEdge(name string) error {
	switch name {
	case media.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Media unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MediaMutation) ResetEdge(name string) error {
	switch name {
	case media.EdgeUserMedia:
		m.ResetUserMedia()
		return nil
	case media.EdgeUser:
		m.ResetUser()
		return nil
	case media.EdgeCourseMedia:
		m.ResetCourseMedia()
		return nil
	case media.EdgeVideoMedia:
		m.ResetVideoMedia()
		return nil
	}
	return fmt.Errorf("unknown Media edge %s", name)
}

// PermissionMutation represents an operation that mutates the Permission nodes in the graph.
type PermissionMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	name          *string
	description   *string
	clearedFields map[string]struct{}
	roles         map[uuid.UUID]struct{}
	removedroles  map[uuid.UUID]struct{}
	clearedroles  bool
	done          bool
	oldValue      func(context.Context) (*Permission, error)
	predicates    []predicate.Permission
}

var _ ent.Mutation = (*PermissionMutation)(nil)

// permissionOption allows management of the mutation configuration using functional options.
type permissionOption func(*PermissionMutation)

// newPermissionMutation creates new mutation for the Permission entity.
func newPermissionMutation(c config, op Op, opts ...permissionOption) *PermissionMutation {
	m := &PermissionMutation{
		config:        c,
		op:            op,
		typ:           TypePermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPermissionID sets the ID field of the mutation.
func withPermissionID(id uuid.UUID) permissionOption {
	return func(m *PermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Permission
		)
		m.oldValue = func(ctx context.Context) (*Permission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Permission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPermission sets the old Permission of the mutation.
func withPermission(node *Permission) permissionOption {
	return func(m *PermissionMutation) {
		m.oldValue = func(context.Context) (*Permission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Permission entities.
func (m *PermissionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PermissionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PermissionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Permission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PermissionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PermissionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PermissionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PermissionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PermissionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PermissionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PermissionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PermissionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PermissionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[permission.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PermissionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[permission.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PermissionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, permission.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *PermissionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PermissionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PermissionMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *PermissionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PermissionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PermissionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[permission.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PermissionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[permission.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PermissionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, permission.FieldDescription)
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *PermissionMutation) AddRoleIDs(ids ...uuid.UUID) {
	if m.roles == nil {
		m.roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *PermissionMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *PermissionMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *PermissionMutation) RemoveRoleIDs(ids ...uuid.UUID) {
	if m.removedroles == nil {
		m.removedroles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *PermissionMutation) RemovedRolesIDs() (ids []uuid.UUID) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *PermissionMutation) RolesIDs() (ids []uuid.UUID) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *PermissionMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// Where appends a list predicates to the PermissionMutation builder.
func (m *PermissionMutation) Where(ps ...predicate.Permission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PermissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PermissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Permission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PermissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PermissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Permission).
func (m *PermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PermissionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, permission.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, permission.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, permission.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, permission.FieldName)
	}
	if m.description != nil {
		fields = append(fields, permission.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case permission.FieldCreatedAt:
		return m.CreatedAt()
	case permission.FieldUpdatedAt:
		return m.UpdatedAt()
	case permission.FieldDeletedAt:
		return m.DeletedAt()
	case permission.FieldName:
		return m.Name()
	case permission.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case permission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case permission.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case permission.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case permission.FieldName:
		return m.OldName(ctx)
	case permission.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Permission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case permission.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case permission.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case permission.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case permission.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case permission.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PermissionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PermissionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Permission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PermissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(permission.FieldDeletedAt) {
		fields = append(fields, permission.FieldDeletedAt)
	}
	if m.FieldCleared(permission.FieldDescription) {
		fields = append(fields, permission.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PermissionMutation) ClearField(name string) error {
	switch name {
	case permission.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case permission.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Permission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PermissionMutation) ResetField(name string) error {
	switch name {
	case permission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case permission.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case permission.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case permission.FieldName:
		m.ResetName()
		return nil
	case permission.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.roles != nil {
		edges = append(edges, permission.EdgeRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PermissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedroles != nil {
		edges = append(edges, permission.EdgeRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PermissionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedroles {
		edges = append(edges, permission.EdgeRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PermissionMutation) EdgeCleared(name string) bool {
	switch name {
	case permission.EdgeRoles:
		return m.clearedroles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PermissionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Permission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PermissionMutation) ResetEdge(name string) error {
	switch name {
	case permission.EdgeRoles:
		m.ResetRoles()
		return nil
	}
	return fmt.Errorf("unknown Permission edge %s", name)
}

// QuestionMutation represents an operation that mutates the Question nodes in the graph.
type QuestionMutation struct {
	config
	op                                        Op
	typ                                       string
	id                                        *uuid.UUID
	created_at                                *time.Time
	updated_at                                *time.Time
	deleted_at                                *time.Time
	question_text                             *string
	clearedFields                             map[string]struct{}
	section                                   *uuid.UUID
	clearedsection                            bool
	question_options                          map[uuid.UUID]struct{}
	removedquestion_options                   map[uuid.UUID]struct{}
	clearedquestion_options                   bool
	video_question_timestamps_question        map[uuid.UUID]struct{}
	removedvideo_question_timestamps_question map[uuid.UUID]struct{}
	clearedvideo_question_timestamps_question bool
	user_question_answers                     map[uuid.UUID]struct{}
	removeduser_question_answers              map[uuid.UUID]struct{}
	cleareduser_question_answers              bool
	tests                                     map[uuid.UUID]struct{}
	removedtests                              map[uuid.UUID]struct{}
	clearedtests                              bool
	done                                      bool
	oldValue                                  func(context.Context) (*Question, error)
	predicates                                []predicate.Question
}

var _ ent.Mutation = (*QuestionMutation)(nil)

// questionOption allows management of the mutation configuration using functional options.
type questionOption func(*QuestionMutation)

// newQuestionMutation creates new mutation for the Question entity.
func newQuestionMutation(c config, op Op, opts ...questionOption) *QuestionMutation {
	m := &QuestionMutation{
		config:        c,
		op:            op,
		typ:           TypeQuestion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withQuestionID sets the ID field of the mutation.
func withQuestionID(id uuid.UUID) questionOption {
	return func(m *QuestionMutation) {
		var (
			err   error
			once  sync.Once
			value *Question
		)
		m.oldValue = func(ctx context.Context) (*Question, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Question.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withQuestion sets the old Question of the mutation.
func withQuestion(node *Question) questionOption {
	return func(m *QuestionMutation) {
		m.oldValue = func(context.Context) (*Question, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m QuestionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m QuestionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Question entities.
func (m *QuestionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *QuestionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *QuestionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Question.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *QuestionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *QuestionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *QuestionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *QuestionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *QuestionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *QuestionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *QuestionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *QuestionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *QuestionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[question.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *QuestionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[question.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *QuestionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, question.FieldDeletedAt)
}

// SetSectionID sets the "section_id" field.
func (m *QuestionMutation) SetSectionID(u uuid.UUID) {
	m.section = &u
}

// SectionID returns the value of the "section_id" field in the mutation.
func (m *QuestionMutation) SectionID() (r uuid.UUID, exists bool) {
	v := m.section
	if v == nil {
		return
	}
	return *v, true
}

// OldSectionID returns the old "section_id" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldSectionID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSectionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSectionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSectionID: %w", err)
	}
	return oldValue.SectionID, nil
}

// ClearSectionID clears the value of the "section_id" field.
func (m *QuestionMutation) ClearSectionID() {
	m.section = nil
	m.clearedFields[question.FieldSectionID] = struct{}{}
}

// SectionIDCleared returns if the "section_id" field was cleared in this mutation.
func (m *QuestionMutation) SectionIDCleared() bool {
	_, ok := m.clearedFields[question.FieldSectionID]
	return ok
}

// ResetSectionID resets all changes to the "section_id" field.
func (m *QuestionMutation) ResetSectionID() {
	m.section = nil
	delete(m.clearedFields, question.FieldSectionID)
}

// SetQuestionText sets the "question_text" field.
func (m *QuestionMutation) SetQuestionText(s string) {
	m.question_text = &s
}

// QuestionText returns the value of the "question_text" field in the mutation.
func (m *QuestionMutation) QuestionText() (r string, exists bool) {
	v := m.question_text
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionText returns the old "question_text" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldQuestionText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuestionText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuestionText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionText: %w", err)
	}
	return oldValue.QuestionText, nil
}

// ResetQuestionText resets all changes to the "question_text" field.
func (m *QuestionMutation) ResetQuestionText() {
	m.question_text = nil
}

// ClearSection clears the "section" edge to the CourseSection entity.
func (m *QuestionMutation) ClearSection() {
	m.clearedsection = true
	m.clearedFields[question.FieldSectionID] = struct{}{}
}

// SectionCleared reports if the "section" edge to the CourseSection entity was cleared.
func (m *QuestionMutation) SectionCleared() bool {
	return m.SectionIDCleared() || m.clearedsection
}

// SectionIDs returns the "section" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SectionID instead. It exists only for internal usage by the builders.
func (m *QuestionMutation) SectionIDs() (ids []uuid.UUID) {
	if id := m.section; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSection resets all changes to the "section" edge.
func (m *QuestionMutation) ResetSection() {
	m.section = nil
	m.clearedsection = false
}

// AddQuestionOptionIDs adds the "question_options" edge to the QuestionOption entity by ids.
func (m *QuestionMutation) AddQuestionOptionIDs(ids ...uuid.UUID) {
	if m.question_options == nil {
		m.question_options = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.question_options[ids[i]] = struct{}{}
	}
}

// ClearQuestionOptions clears the "question_options" edge to the QuestionOption entity.
func (m *QuestionMutation) ClearQuestionOptions() {
	m.clearedquestion_options = true
}

// QuestionOptionsCleared reports if the "question_options" edge to the QuestionOption entity was cleared.
func (m *QuestionMutation) QuestionOptionsCleared() bool {
	return m.clearedquestion_options
}

// RemoveQuestionOptionIDs removes the "question_options" edge to the QuestionOption entity by IDs.
func (m *QuestionMutation) RemoveQuestionOptionIDs(ids ...uuid.UUID) {
	if m.removedquestion_options == nil {
		m.removedquestion_options = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.question_options, ids[i])
		m.removedquestion_options[ids[i]] = struct{}{}
	}
}

// RemovedQuestionOptions returns the removed IDs of the "question_options" edge to the QuestionOption entity.
func (m *QuestionMutation) RemovedQuestionOptionsIDs() (ids []uuid.UUID) {
	for id := range m.removedquestion_options {
		ids = append(ids, id)
	}
	return
}

// QuestionOptionsIDs returns the "question_options" edge IDs in the mutation.
func (m *QuestionMutation) QuestionOptionsIDs() (ids []uuid.UUID) {
	for id := range m.question_options {
		ids = append(ids, id)
	}
	return
}

// ResetQuestionOptions resets all changes to the "question_options" edge.
func (m *QuestionMutation) ResetQuestionOptions() {
	m.question_options = nil
	m.clearedquestion_options = false
	m.removedquestion_options = nil
}

// AddVideoQuestionTimestampsQuestionIDs adds the "video_question_timestamps_question" edge to the VideoQuestionTimestamp entity by ids.
func (m *QuestionMutation) AddVideoQuestionTimestampsQuestionIDs(ids ...uuid.UUID) {
	if m.video_question_timestamps_question == nil {
		m.video_question_timestamps_question = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.video_question_timestamps_question[ids[i]] = struct{}{}
	}
}

// ClearVideoQuestionTimestampsQuestion clears the "video_question_timestamps_question" edge to the VideoQuestionTimestamp entity.
func (m *QuestionMutation) ClearVideoQuestionTimestampsQuestion() {
	m.clearedvideo_question_timestamps_question = true
}

// VideoQuestionTimestampsQuestionCleared reports if the "video_question_timestamps_question" edge to the VideoQuestionTimestamp entity was cleared.
func (m *QuestionMutation) VideoQuestionTimestampsQuestionCleared() bool {
	return m.clearedvideo_question_timestamps_question
}

// RemoveVideoQuestionTimestampsQuestionIDs removes the "video_question_timestamps_question" edge to the VideoQuestionTimestamp entity by IDs.
func (m *QuestionMutation) RemoveVideoQuestionTimestampsQuestionIDs(ids ...uuid.UUID) {
	if m.removedvideo_question_timestamps_question == nil {
		m.removedvideo_question_timestamps_question = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.video_question_timestamps_question, ids[i])
		m.removedvideo_question_timestamps_question[ids[i]] = struct{}{}
	}
}

// RemovedVideoQuestionTimestampsQuestion returns the removed IDs of the "video_question_timestamps_question" edge to the VideoQuestionTimestamp entity.
func (m *QuestionMutation) RemovedVideoQuestionTimestampsQuestionIDs() (ids []uuid.UUID) {
	for id := range m.removedvideo_question_timestamps_question {
		ids = append(ids, id)
	}
	return
}

// VideoQuestionTimestampsQuestionIDs returns the "video_question_timestamps_question" edge IDs in the mutation.
func (m *QuestionMutation) VideoQuestionTimestampsQuestionIDs() (ids []uuid.UUID) {
	for id := range m.video_question_timestamps_question {
		ids = append(ids, id)
	}
	return
}

// ResetVideoQuestionTimestampsQuestion resets all changes to the "video_question_timestamps_question" edge.
func (m *QuestionMutation) ResetVideoQuestionTimestampsQuestion() {
	m.video_question_timestamps_question = nil
	m.clearedvideo_question_timestamps_question = false
	m.removedvideo_question_timestamps_question = nil
}

// AddUserQuestionAnswerIDs adds the "user_question_answers" edge to the UserQuestionAnswer entity by ids.
func (m *QuestionMutation) AddUserQuestionAnswerIDs(ids ...uuid.UUID) {
	if m.user_question_answers == nil {
		m.user_question_answers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_question_answers[ids[i]] = struct{}{}
	}
}

// ClearUserQuestionAnswers clears the "user_question_answers" edge to the UserQuestionAnswer entity.
func (m *QuestionMutation) ClearUserQuestionAnswers() {
	m.cleareduser_question_answers = true
}

// UserQuestionAnswersCleared reports if the "user_question_answers" edge to the UserQuestionAnswer entity was cleared.
func (m *QuestionMutation) UserQuestionAnswersCleared() bool {
	return m.cleareduser_question_answers
}

// RemoveUserQuestionAnswerIDs removes the "user_question_answers" edge to the UserQuestionAnswer entity by IDs.
func (m *QuestionMutation) RemoveUserQuestionAnswerIDs(ids ...uuid.UUID) {
	if m.removeduser_question_answers == nil {
		m.removeduser_question_answers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_question_answers, ids[i])
		m.removeduser_question_answers[ids[i]] = struct{}{}
	}
}

// RemovedUserQuestionAnswers returns the removed IDs of the "user_question_answers" edge to the UserQuestionAnswer entity.
func (m *QuestionMutation) RemovedUserQuestionAnswersIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_question_answers {
		ids = append(ids, id)
	}
	return
}

// UserQuestionAnswersIDs returns the "user_question_answers" edge IDs in the mutation.
func (m *QuestionMutation) UserQuestionAnswersIDs() (ids []uuid.UUID) {
	for id := range m.user_question_answers {
		ids = append(ids, id)
	}
	return
}

// ResetUserQuestionAnswers resets all changes to the "user_question_answers" edge.
func (m *QuestionMutation) ResetUserQuestionAnswers() {
	m.user_question_answers = nil
	m.cleareduser_question_answers = false
	m.removeduser_question_answers = nil
}

// AddTestIDs adds the "tests" edge to the Test entity by ids.
func (m *QuestionMutation) AddTestIDs(ids ...uuid.UUID) {
	if m.tests == nil {
		m.tests = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tests[ids[i]] = struct{}{}
	}
}

// ClearTests clears the "tests" edge to the Test entity.
func (m *QuestionMutation) ClearTests() {
	m.clearedtests = true
}

// TestsCleared reports if the "tests" edge to the Test entity was cleared.
func (m *QuestionMutation) TestsCleared() bool {
	return m.clearedtests
}

// RemoveTestIDs removes the "tests" edge to the Test entity by IDs.
func (m *QuestionMutation) RemoveTestIDs(ids ...uuid.UUID) {
	if m.removedtests == nil {
		m.removedtests = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tests, ids[i])
		m.removedtests[ids[i]] = struct{}{}
	}
}

// RemovedTests returns the removed IDs of the "tests" edge to the Test entity.
func (m *QuestionMutation) RemovedTestsIDs() (ids []uuid.UUID) {
	for id := range m.removedtests {
		ids = append(ids, id)
	}
	return
}

// TestsIDs returns the "tests" edge IDs in the mutation.
func (m *QuestionMutation) TestsIDs() (ids []uuid.UUID) {
	for id := range m.tests {
		ids = append(ids, id)
	}
	return
}

// ResetTests resets all changes to the "tests" edge.
func (m *QuestionMutation) ResetTests() {
	m.tests = nil
	m.clearedtests = false
	m.removedtests = nil
}

// Where appends a list predicates to the QuestionMutation builder.
func (m *QuestionMutation) Where(ps ...predicate.Question) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the QuestionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *QuestionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Question, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *QuestionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *QuestionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Question).
func (m *QuestionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *QuestionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, question.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, question.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, question.FieldDeletedAt)
	}
	if m.section != nil {
		fields = append(fields, question.FieldSectionID)
	}
	if m.question_text != nil {
		fields = append(fields, question.FieldQuestionText)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *QuestionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case question.FieldCreatedAt:
		return m.CreatedAt()
	case question.FieldUpdatedAt:
		return m.UpdatedAt()
	case question.FieldDeletedAt:
		return m.DeletedAt()
	case question.FieldSectionID:
		return m.SectionID()
	case question.FieldQuestionText:
		return m.QuestionText()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *QuestionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case question.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case question.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case question.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case question.FieldSectionID:
		return m.OldSectionID(ctx)
	case question.FieldQuestionText:
		return m.OldQuestionText(ctx)
	}
	return nil, fmt.Errorf("unknown Question field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QuestionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case question.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case question.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case question.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case question.FieldSectionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSectionID(v)
		return nil
	case question.FieldQuestionText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionText(v)
		return nil
	}
	return fmt.Errorf("unknown Question field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *QuestionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *QuestionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QuestionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Question numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *QuestionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(question.FieldDeletedAt) {
		fields = append(fields, question.FieldDeletedAt)
	}
	if m.FieldCleared(question.FieldSectionID) {
		fields = append(fields, question.FieldSectionID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *QuestionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *QuestionMutation) ClearField(name string) error {
	switch name {
	case question.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case question.FieldSectionID:
		m.ClearSectionID()
		return nil
	}
	return fmt.Errorf("unknown Question nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *QuestionMutation) ResetField(name string) error {
	switch name {
	case question.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case question.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case question.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case question.FieldSectionID:
		m.ResetSectionID()
		return nil
	case question.FieldQuestionText:
		m.ResetQuestionText()
		return nil
	}
	return fmt.Errorf("unknown Question field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *QuestionMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.section != nil {
		edges = append(edges, question.EdgeSection)
	}
	if m.question_options != nil {
		edges = append(edges, question.EdgeQuestionOptions)
	}
	if m.video_question_timestamps_question != nil {
		edges = append(edges, question.EdgeVideoQuestionTimestampsQuestion)
	}
	if m.user_question_answers != nil {
		edges = append(edges, question.EdgeUserQuestionAnswers)
	}
	if m.tests != nil {
		edges = append(edges, question.EdgeTests)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *QuestionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case question.EdgeSection:
		if id := m.section; id != nil {
			return []ent.Value{*id}
		}
	case question.EdgeQuestionOptions:
		ids := make([]ent.Value, 0, len(m.question_options))
		for id := range m.question_options {
			ids = append(ids, id)
		}
		return ids
	case question.EdgeVideoQuestionTimestampsQuestion:
		ids := make([]ent.Value, 0, len(m.video_question_timestamps_question))
		for id := range m.video_question_timestamps_question {
			ids = append(ids, id)
		}
		return ids
	case question.EdgeUserQuestionAnswers:
		ids := make([]ent.Value, 0, len(m.user_question_answers))
		for id := range m.user_question_answers {
			ids = append(ids, id)
		}
		return ids
	case question.EdgeTests:
		ids := make([]ent.Value, 0, len(m.tests))
		for id := range m.tests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *QuestionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedquestion_options != nil {
		edges = append(edges, question.EdgeQuestionOptions)
	}
	if m.removedvideo_question_timestamps_question != nil {
		edges = append(edges, question.EdgeVideoQuestionTimestampsQuestion)
	}
	if m.removeduser_question_answers != nil {
		edges = append(edges, question.EdgeUserQuestionAnswers)
	}
	if m.removedtests != nil {
		edges = append(edges, question.EdgeTests)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *QuestionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case question.EdgeQuestionOptions:
		ids := make([]ent.Value, 0, len(m.removedquestion_options))
		for id := range m.removedquestion_options {
			ids = append(ids, id)
		}
		return ids
	case question.EdgeVideoQuestionTimestampsQuestion:
		ids := make([]ent.Value, 0, len(m.removedvideo_question_timestamps_question))
		for id := range m.removedvideo_question_timestamps_question {
			ids = append(ids, id)
		}
		return ids
	case question.EdgeUserQuestionAnswers:
		ids := make([]ent.Value, 0, len(m.removeduser_question_answers))
		for id := range m.removeduser_question_answers {
			ids = append(ids, id)
		}
		return ids
	case question.EdgeTests:
		ids := make([]ent.Value, 0, len(m.removedtests))
		for id := range m.removedtests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *QuestionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedsection {
		edges = append(edges, question.EdgeSection)
	}
	if m.clearedquestion_options {
		edges = append(edges, question.EdgeQuestionOptions)
	}
	if m.clearedvideo_question_timestamps_question {
		edges = append(edges, question.EdgeVideoQuestionTimestampsQuestion)
	}
	if m.cleareduser_question_answers {
		edges = append(edges, question.EdgeUserQuestionAnswers)
	}
	if m.clearedtests {
		edges = append(edges, question.EdgeTests)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *QuestionMutation) EdgeCleared(name string) bool {
	switch name {
	case question.EdgeSection:
		return m.clearedsection
	case question.EdgeQuestionOptions:
		return m.clearedquestion_options
	case question.EdgeVideoQuestionTimestampsQuestion:
		return m.clearedvideo_question_timestamps_question
	case question.EdgeUserQuestionAnswers:
		return m.cleareduser_question_answers
	case question.EdgeTests:
		return m.clearedtests
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *QuestionMutation) ClearEdge(name string) error {
	switch name {
	case question.EdgeSection:
		m.ClearSection()
		return nil
	}
	return fmt.Errorf("unknown Question unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *QuestionMutation) ResetEdge(name string) error {
	switch name {
	case question.EdgeSection:
		m.ResetSection()
		return nil
	case question.EdgeQuestionOptions:
		m.ResetQuestionOptions()
		return nil
	case question.EdgeVideoQuestionTimestampsQuestion:
		m.ResetVideoQuestionTimestampsQuestion()
		return nil
	case question.EdgeUserQuestionAnswers:
		m.ResetUserQuestionAnswers()
		return nil
	case question.EdgeTests:
		m.ResetTests()
		return nil
	}
	return fmt.Errorf("unknown Question edge %s", name)
}

// QuestionOptionMutation represents an operation that mutates the QuestionOption nodes in the graph.
type QuestionOptionMutation struct {
	config
	op                           Op
	typ                          string
	id                           *uuid.UUID
	created_at                   *time.Time
	updated_at                   *time.Time
	deleted_at                   *time.Time
	option_text                  *string
	is_correct                   *bool
	clearedFields                map[string]struct{}
	question                     *uuid.UUID
	clearedquestion              bool
	user_question_answers        map[uuid.UUID]struct{}
	removeduser_question_answers map[uuid.UUID]struct{}
	cleareduser_question_answers bool
	done                         bool
	oldValue                     func(context.Context) (*QuestionOption, error)
	predicates                   []predicate.QuestionOption
}

var _ ent.Mutation = (*QuestionOptionMutation)(nil)

// questionoptionOption allows management of the mutation configuration using functional options.
type questionoptionOption func(*QuestionOptionMutation)

// newQuestionOptionMutation creates new mutation for the QuestionOption entity.
func newQuestionOptionMutation(c config, op Op, opts ...questionoptionOption) *QuestionOptionMutation {
	m := &QuestionOptionMutation{
		config:        c,
		op:            op,
		typ:           TypeQuestionOption,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withQuestionOptionID sets the ID field of the mutation.
func withQuestionOptionID(id uuid.UUID) questionoptionOption {
	return func(m *QuestionOptionMutation) {
		var (
			err   error
			once  sync.Once
			value *QuestionOption
		)
		m.oldValue = func(ctx context.Context) (*QuestionOption, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().QuestionOption.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withQuestionOption sets the old QuestionOption of the mutation.
func withQuestionOption(node *QuestionOption) questionoptionOption {
	return func(m *QuestionOptionMutation) {
		m.oldValue = func(context.Context) (*QuestionOption, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m QuestionOptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m QuestionOptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of QuestionOption entities.
func (m *QuestionOptionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *QuestionOptionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *QuestionOptionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().QuestionOption.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *QuestionOptionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *QuestionOptionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the QuestionOption entity.
// If the QuestionOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionOptionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *QuestionOptionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *QuestionOptionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *QuestionOptionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the QuestionOption entity.
// If the QuestionOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionOptionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *QuestionOptionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *QuestionOptionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *QuestionOptionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the QuestionOption entity.
// If the QuestionOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionOptionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *QuestionOptionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[questionoption.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *QuestionOptionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[questionoption.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *QuestionOptionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, questionoption.FieldDeletedAt)
}

// SetQuestionID sets the "question_id" field.
func (m *QuestionOptionMutation) SetQuestionID(u uuid.UUID) {
	m.question = &u
}

// QuestionID returns the value of the "question_id" field in the mutation.
func (m *QuestionOptionMutation) QuestionID() (r uuid.UUID, exists bool) {
	v := m.question
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionID returns the old "question_id" field's value of the QuestionOption entity.
// If the QuestionOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionOptionMutation) OldQuestionID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuestionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuestionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionID: %w", err)
	}
	return oldValue.QuestionID, nil
}

// ResetQuestionID resets all changes to the "question_id" field.
func (m *QuestionOptionMutation) ResetQuestionID() {
	m.question = nil
}

// SetOptionText sets the "option_text" field.
func (m *QuestionOptionMutation) SetOptionText(s string) {
	m.option_text = &s
}

// OptionText returns the value of the "option_text" field in the mutation.
func (m *QuestionOptionMutation) OptionText() (r string, exists bool) {
	v := m.option_text
	if v == nil {
		return
	}
	return *v, true
}

// OldOptionText returns the old "option_text" field's value of the QuestionOption entity.
// If the QuestionOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionOptionMutation) OldOptionText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOptionText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOptionText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOptionText: %w", err)
	}
	return oldValue.OptionText, nil
}

// ResetOptionText resets all changes to the "option_text" field.
func (m *QuestionOptionMutation) ResetOptionText() {
	m.option_text = nil
}

// SetIsCorrect sets the "is_correct" field.
func (m *QuestionOptionMutation) SetIsCorrect(b bool) {
	m.is_correct = &b
}

// IsCorrect returns the value of the "is_correct" field in the mutation.
func (m *QuestionOptionMutation) IsCorrect() (r bool, exists bool) {
	v := m.is_correct
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCorrect returns the old "is_correct" field's value of the QuestionOption entity.
// If the QuestionOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionOptionMutation) OldIsCorrect(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCorrect is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCorrect requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCorrect: %w", err)
	}
	return oldValue.IsCorrect, nil
}

// ResetIsCorrect resets all changes to the "is_correct" field.
func (m *QuestionOptionMutation) ResetIsCorrect() {
	m.is_correct = nil
}

// ClearQuestion clears the "question" edge to the Question entity.
func (m *QuestionOptionMutation) ClearQuestion() {
	m.clearedquestion = true
	m.clearedFields[questionoption.FieldQuestionID] = struct{}{}
}

// QuestionCleared reports if the "question" edge to the Question entity was cleared.
func (m *QuestionOptionMutation) QuestionCleared() bool {
	return m.clearedquestion
}

// QuestionIDs returns the "question" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// QuestionID instead. It exists only for internal usage by the builders.
func (m *QuestionOptionMutation) QuestionIDs() (ids []uuid.UUID) {
	if id := m.question; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetQuestion resets all changes to the "question" edge.
func (m *QuestionOptionMutation) ResetQuestion() {
	m.question = nil
	m.clearedquestion = false
}

// AddUserQuestionAnswerIDs adds the "user_question_answers" edge to the UserQuestionAnswer entity by ids.
func (m *QuestionOptionMutation) AddUserQuestionAnswerIDs(ids ...uuid.UUID) {
	if m.user_question_answers == nil {
		m.user_question_answers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_question_answers[ids[i]] = struct{}{}
	}
}

// ClearUserQuestionAnswers clears the "user_question_answers" edge to the UserQuestionAnswer entity.
func (m *QuestionOptionMutation) ClearUserQuestionAnswers() {
	m.cleareduser_question_answers = true
}

// UserQuestionAnswersCleared reports if the "user_question_answers" edge to the UserQuestionAnswer entity was cleared.
func (m *QuestionOptionMutation) UserQuestionAnswersCleared() bool {
	return m.cleareduser_question_answers
}

// RemoveUserQuestionAnswerIDs removes the "user_question_answers" edge to the UserQuestionAnswer entity by IDs.
func (m *QuestionOptionMutation) RemoveUserQuestionAnswerIDs(ids ...uuid.UUID) {
	if m.removeduser_question_answers == nil {
		m.removeduser_question_answers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_question_answers, ids[i])
		m.removeduser_question_answers[ids[i]] = struct{}{}
	}
}

// RemovedUserQuestionAnswers returns the removed IDs of the "user_question_answers" edge to the UserQuestionAnswer entity.
func (m *QuestionOptionMutation) RemovedUserQuestionAnswersIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_question_answers {
		ids = append(ids, id)
	}
	return
}

// UserQuestionAnswersIDs returns the "user_question_answers" edge IDs in the mutation.
func (m *QuestionOptionMutation) UserQuestionAnswersIDs() (ids []uuid.UUID) {
	for id := range m.user_question_answers {
		ids = append(ids, id)
	}
	return
}

// ResetUserQuestionAnswers resets all changes to the "user_question_answers" edge.
func (m *QuestionOptionMutation) ResetUserQuestionAnswers() {
	m.user_question_answers = nil
	m.cleareduser_question_answers = false
	m.removeduser_question_answers = nil
}

// Where appends a list predicates to the QuestionOptionMutation builder.
func (m *QuestionOptionMutation) Where(ps ...predicate.QuestionOption) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the QuestionOptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *QuestionOptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.QuestionOption, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *QuestionOptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *QuestionOptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (QuestionOption).
func (m *QuestionOptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *QuestionOptionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, questionoption.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, questionoption.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, questionoption.FieldDeletedAt)
	}
	if m.question != nil {
		fields = append(fields, questionoption.FieldQuestionID)
	}
	if m.option_text != nil {
		fields = append(fields, questionoption.FieldOptionText)
	}
	if m.is_correct != nil {
		fields = append(fields, questionoption.FieldIsCorrect)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *QuestionOptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case questionoption.FieldCreatedAt:
		return m.CreatedAt()
	case questionoption.FieldUpdatedAt:
		return m.UpdatedAt()
	case questionoption.FieldDeletedAt:
		return m.DeletedAt()
	case questionoption.FieldQuestionID:
		return m.QuestionID()
	case questionoption.FieldOptionText:
		return m.OptionText()
	case questionoption.FieldIsCorrect:
		return m.IsCorrect()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *QuestionOptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case questionoption.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case questionoption.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case questionoption.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case questionoption.FieldQuestionID:
		return m.OldQuestionID(ctx)
	case questionoption.FieldOptionText:
		return m.OldOptionText(ctx)
	case questionoption.FieldIsCorrect:
		return m.OldIsCorrect(ctx)
	}
	return nil, fmt.Errorf("unknown QuestionOption field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QuestionOptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case questionoption.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case questionoption.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case questionoption.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case questionoption.FieldQuestionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionID(v)
		return nil
	case questionoption.FieldOptionText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOptionText(v)
		return nil
	case questionoption.FieldIsCorrect:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCorrect(v)
		return nil
	}
	return fmt.Errorf("unknown QuestionOption field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *QuestionOptionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *QuestionOptionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QuestionOptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown QuestionOption numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *QuestionOptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(questionoption.FieldDeletedAt) {
		fields = append(fields, questionoption.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *QuestionOptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *QuestionOptionMutation) ClearField(name string) error {
	switch name {
	case questionoption.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown QuestionOption nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *QuestionOptionMutation) ResetField(name string) error {
	switch name {
	case questionoption.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case questionoption.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case questionoption.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case questionoption.FieldQuestionID:
		m.ResetQuestionID()
		return nil
	case questionoption.FieldOptionText:
		m.ResetOptionText()
		return nil
	case questionoption.FieldIsCorrect:
		m.ResetIsCorrect()
		return nil
	}
	return fmt.Errorf("unknown QuestionOption field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *QuestionOptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.question != nil {
		edges = append(edges, questionoption.EdgeQuestion)
	}
	if m.user_question_answers != nil {
		edges = append(edges, questionoption.EdgeUserQuestionAnswers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *QuestionOptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case questionoption.EdgeQuestion:
		if id := m.question; id != nil {
			return []ent.Value{*id}
		}
	case questionoption.EdgeUserQuestionAnswers:
		ids := make([]ent.Value, 0, len(m.user_question_answers))
		for id := range m.user_question_answers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *QuestionOptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeduser_question_answers != nil {
		edges = append(edges, questionoption.EdgeUserQuestionAnswers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *QuestionOptionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case questionoption.EdgeUserQuestionAnswers:
		ids := make([]ent.Value, 0, len(m.removeduser_question_answers))
		for id := range m.removeduser_question_answers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *QuestionOptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedquestion {
		edges = append(edges, questionoption.EdgeQuestion)
	}
	if m.cleareduser_question_answers {
		edges = append(edges, questionoption.EdgeUserQuestionAnswers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *QuestionOptionMutation) EdgeCleared(name string) bool {
	switch name {
	case questionoption.EdgeQuestion:
		return m.clearedquestion
	case questionoption.EdgeUserQuestionAnswers:
		return m.cleareduser_question_answers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *QuestionOptionMutation) ClearEdge(name string) error {
	switch name {
	case questionoption.EdgeQuestion:
		m.ClearQuestion()
		return nil
	}
	return fmt.Errorf("unknown QuestionOption unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *QuestionOptionMutation) ResetEdge(name string) error {
	switch name {
	case questionoption.EdgeQuestion:
		m.ResetQuestion()
		return nil
	case questionoption.EdgeUserQuestionAnswers:
		m.ResetUserQuestionAnswers()
		return nil
	}
	return fmt.Errorf("unknown QuestionOption edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	name               *string
	description        *string
	clearedFields      map[string]struct{}
	users              map[uuid.UUID]struct{}
	removedusers       map[uuid.UUID]struct{}
	clearedusers       bool
	permissions        map[uuid.UUID]struct{}
	removedpermissions map[uuid.UUID]struct{}
	clearedpermissions bool
	user_roles         map[uuid.UUID]struct{}
	removeduser_roles  map[uuid.UUID]struct{}
	cleareduser_roles  bool
	done               bool
	oldValue           func(context.Context) (*Role, error)
	predicates         []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id uuid.UUID) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RoleMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RoleMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *RoleMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[role.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *RoleMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[role.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RoleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, role.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *RoleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RoleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RoleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[role.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RoleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[role.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RoleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, role.FieldDescription)
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *RoleMutation) AddUserIDs(ids ...uuid.UUID) {
	if m.users == nil {
		m.users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *RoleMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *RoleMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *RoleMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removedusers == nil {
		m.removedusers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *RoleMutation) RemovedUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *RoleMutation) UsersIDs() (ids []uuid.UUID) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *RoleMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddPermissionIDs adds the "permissions" edge to the Permission entity by ids.
func (m *RoleMutation) AddPermissionIDs(ids ...uuid.UUID) {
	if m.permissions == nil {
		m.permissions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.permissions[ids[i]] = struct{}{}
	}
}

// ClearPermissions clears the "permissions" edge to the Permission entity.
func (m *RoleMutation) ClearPermissions() {
	m.clearedpermissions = true
}

// PermissionsCleared reports if the "permissions" edge to the Permission entity was cleared.
func (m *RoleMutation) PermissionsCleared() bool {
	return m.clearedpermissions
}

// RemovePermissionIDs removes the "permissions" edge to the Permission entity by IDs.
func (m *RoleMutation) RemovePermissionIDs(ids ...uuid.UUID) {
	if m.removedpermissions == nil {
		m.removedpermissions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.permissions, ids[i])
		m.removedpermissions[ids[i]] = struct{}{}
	}
}

// RemovedPermissions returns the removed IDs of the "permissions" edge to the Permission entity.
func (m *RoleMutation) RemovedPermissionsIDs() (ids []uuid.UUID) {
	for id := range m.removedpermissions {
		ids = append(ids, id)
	}
	return
}

// PermissionsIDs returns the "permissions" edge IDs in the mutation.
func (m *RoleMutation) PermissionsIDs() (ids []uuid.UUID) {
	for id := range m.permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPermissions resets all changes to the "permissions" edge.
func (m *RoleMutation) ResetPermissions() {
	m.permissions = nil
	m.clearedpermissions = false
	m.removedpermissions = nil
}

// AddUserRoleIDs adds the "user_roles" edge to the UserRole entity by ids.
func (m *RoleMutation) AddUserRoleIDs(ids ...uuid.UUID) {
	if m.user_roles == nil {
		m.user_roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_roles[ids[i]] = struct{}{}
	}
}

// ClearUserRoles clears the "user_roles" edge to the UserRole entity.
func (m *RoleMutation) ClearUserRoles() {
	m.cleareduser_roles = true
}

// UserRolesCleared reports if the "user_roles" edge to the UserRole entity was cleared.
func (m *RoleMutation) UserRolesCleared() bool {
	return m.cleareduser_roles
}

// RemoveUserRoleIDs removes the "user_roles" edge to the UserRole entity by IDs.
func (m *RoleMutation) RemoveUserRoleIDs(ids ...uuid.UUID) {
	if m.removeduser_roles == nil {
		m.removeduser_roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_roles, ids[i])
		m.removeduser_roles[ids[i]] = struct{}{}
	}
}

// RemovedUserRoles returns the removed IDs of the "user_roles" edge to the UserRole entity.
func (m *RoleMutation) RemovedUserRolesIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_roles {
		ids = append(ids, id)
	}
	return
}

// UserRolesIDs returns the "user_roles" edge IDs in the mutation.
func (m *RoleMutation) UserRolesIDs() (ids []uuid.UUID) {
	for id := range m.user_roles {
		ids = append(ids, id)
	}
	return
}

// ResetUserRoles resets all changes to the "user_roles" edge.
func (m *RoleMutation) ResetUserRoles() {
	m.user_roles = nil
	m.cleareduser_roles = false
	m.removeduser_roles = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, role.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.description != nil {
		fields = append(fields, role.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldUpdatedAt:
		return m.UpdatedAt()
	case role.FieldDeletedAt:
		return m.DeletedAt()
	case role.FieldName:
		return m.Name()
	case role.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case role.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case role.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldDeletedAt) {
		fields = append(fields, role.FieldDeletedAt)
	}
	if m.FieldCleared(role.FieldDescription) {
		fields = append(fields, role.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case role.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case role.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.users != nil {
		edges = append(edges, role.EdgeUsers)
	}
	if m.permissions != nil {
		edges = append(edges, role.EdgePermissions)
	}
	if m.user_roles != nil {
		edges = append(edges, role.EdgeUserRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case role.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.permissions))
		for id := range m.permissions {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeUserRoles:
		ids := make([]ent.Value, 0, len(m.user_roles))
		for id := range m.user_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedusers != nil {
		edges = append(edges, role.EdgeUsers)
	}
	if m.removedpermissions != nil {
		edges = append(edges, role.EdgePermissions)
	}
	if m.removeduser_roles != nil {
		edges = append(edges, role.EdgeUserRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case role.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.removedpermissions))
		for id := range m.removedpermissions {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeUserRoles:
		ids := make([]ent.Value, 0, len(m.removeduser_roles))
		for id := range m.removeduser_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedusers {
		edges = append(edges, role.EdgeUsers)
	}
	if m.clearedpermissions {
		edges = append(edges, role.EdgePermissions)
	}
	if m.cleareduser_roles {
		edges = append(edges, role.EdgeUserRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeUsers:
		return m.clearedusers
	case role.EdgePermissions:
		return m.clearedpermissions
	case role.EdgeUserRoles:
		return m.cleareduser_roles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeUsers:
		m.ResetUsers()
		return nil
	case role.EdgePermissions:
		m.ResetPermissions()
		return nil
	case role.EdgeUserRoles:
		m.ResetUserRoles()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// TestMutation represents an operation that mutates the Test nodes in the graph.
type TestMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	name                  *string
	clearedFields         map[string]struct{}
	course_section        *uuid.UUID
	clearedcourse_section bool
	course                *uuid.UUID
	clearedcourse         bool
	test_sessions         map[uuid.UUID]struct{}
	removedtest_sessions  map[uuid.UUID]struct{}
	clearedtest_sessions  bool
	questions             map[uuid.UUID]struct{}
	removedquestions      map[uuid.UUID]struct{}
	clearedquestions      bool
	done                  bool
	oldValue              func(context.Context) (*Test, error)
	predicates            []predicate.Test
}

var _ ent.Mutation = (*TestMutation)(nil)

// testOption allows management of the mutation configuration using functional options.
type testOption func(*TestMutation)

// newTestMutation creates new mutation for the Test entity.
func newTestMutation(c config, op Op, opts ...testOption) *TestMutation {
	m := &TestMutation{
		config:        c,
		op:            op,
		typ:           TypeTest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTestID sets the ID field of the mutation.
func withTestID(id uuid.UUID) testOption {
	return func(m *TestMutation) {
		var (
			err   error
			once  sync.Once
			value *Test
		)
		m.oldValue = func(ctx context.Context) (*Test, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Test.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTest sets the old Test of the mutation.
func withTest(node *Test) testOption {
	return func(m *TestMutation) {
		m.oldValue = func(context.Context) (*Test, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Test entities.
func (m *TestMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TestMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TestMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Test.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TestMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TestMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TestMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TestMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TestMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TestMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TestMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[test.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TestMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[test.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TestMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, test.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *TestMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TestMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TestMutation) ResetName() {
	m.name = nil
}

// SetCourseSectionID sets the "course_section_id" field.
func (m *TestMutation) SetCourseSectionID(u uuid.UUID) {
	m.course_section = &u
}

// CourseSectionID returns the value of the "course_section_id" field in the mutation.
func (m *TestMutation) CourseSectionID() (r uuid.UUID, exists bool) {
	v := m.course_section
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseSectionID returns the old "course_section_id" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldCourseSectionID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCourseSectionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCourseSectionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseSectionID: %w", err)
	}
	return oldValue.CourseSectionID, nil
}

// ClearCourseSectionID clears the value of the "course_section_id" field.
func (m *TestMutation) ClearCourseSectionID() {
	m.course_section = nil
	m.clearedFields[test.FieldCourseSectionID] = struct{}{}
}

// CourseSectionIDCleared returns if the "course_section_id" field was cleared in this mutation.
func (m *TestMutation) CourseSectionIDCleared() bool {
	_, ok := m.clearedFields[test.FieldCourseSectionID]
	return ok
}

// ResetCourseSectionID resets all changes to the "course_section_id" field.
func (m *TestMutation) ResetCourseSectionID() {
	m.course_section = nil
	delete(m.clearedFields, test.FieldCourseSectionID)
}

// SetCourseID sets the "course_id" field.
func (m *TestMutation) SetCourseID(u uuid.UUID) {
	m.course = &u
}

// CourseID returns the value of the "course_id" field in the mutation.
func (m *TestMutation) CourseID() (r uuid.UUID, exists bool) {
	v := m.course
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseID returns the old "course_id" field's value of the Test entity.
// If the Test object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestMutation) OldCourseID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCourseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCourseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseID: %w", err)
	}
	return oldValue.CourseID, nil
}

// ClearCourseID clears the value of the "course_id" field.
func (m *TestMutation) ClearCourseID() {
	m.course = nil
	m.clearedFields[test.FieldCourseID] = struct{}{}
}

// CourseIDCleared returns if the "course_id" field was cleared in this mutation.
func (m *TestMutation) CourseIDCleared() bool {
	_, ok := m.clearedFields[test.FieldCourseID]
	return ok
}

// ResetCourseID resets all changes to the "course_id" field.
func (m *TestMutation) ResetCourseID() {
	m.course = nil
	delete(m.clearedFields, test.FieldCourseID)
}

// ClearCourseSection clears the "course_section" edge to the CourseSection entity.
func (m *TestMutation) ClearCourseSection() {
	m.clearedcourse_section = true
	m.clearedFields[test.FieldCourseSectionID] = struct{}{}
}

// CourseSectionCleared reports if the "course_section" edge to the CourseSection entity was cleared.
func (m *TestMutation) CourseSectionCleared() bool {
	return m.CourseSectionIDCleared() || m.clearedcourse_section
}

// CourseSectionIDs returns the "course_section" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CourseSectionID instead. It exists only for internal usage by the builders.
func (m *TestMutation) CourseSectionIDs() (ids []uuid.UUID) {
	if id := m.course_section; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourseSection resets all changes to the "course_section" edge.
func (m *TestMutation) ResetCourseSection() {
	m.course_section = nil
	m.clearedcourse_section = false
}

// ClearCourse clears the "course" edge to the Course entity.
func (m *TestMutation) ClearCourse() {
	m.clearedcourse = true
	m.clearedFields[test.FieldCourseID] = struct{}{}
}

// CourseCleared reports if the "course" edge to the Course entity was cleared.
func (m *TestMutation) CourseCleared() bool {
	return m.CourseIDCleared() || m.clearedcourse
}

// CourseIDs returns the "course" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CourseID instead. It exists only for internal usage by the builders.
func (m *TestMutation) CourseIDs() (ids []uuid.UUID) {
	if id := m.course; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourse resets all changes to the "course" edge.
func (m *TestMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
}

// AddTestSessionIDs adds the "test_sessions" edge to the TestSession entity by ids.
func (m *TestMutation) AddTestSessionIDs(ids ...uuid.UUID) {
	if m.test_sessions == nil {
		m.test_sessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.test_sessions[ids[i]] = struct{}{}
	}
}

// ClearTestSessions clears the "test_sessions" edge to the TestSession entity.
func (m *TestMutation) ClearTestSessions() {
	m.clearedtest_sessions = true
}

// TestSessionsCleared reports if the "test_sessions" edge to the TestSession entity was cleared.
func (m *TestMutation) TestSessionsCleared() bool {
	return m.clearedtest_sessions
}

// RemoveTestSessionIDs removes the "test_sessions" edge to the TestSession entity by IDs.
func (m *TestMutation) RemoveTestSessionIDs(ids ...uuid.UUID) {
	if m.removedtest_sessions == nil {
		m.removedtest_sessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.test_sessions, ids[i])
		m.removedtest_sessions[ids[i]] = struct{}{}
	}
}

// RemovedTestSessions returns the removed IDs of the "test_sessions" edge to the TestSession entity.
func (m *TestMutation) RemovedTestSessionsIDs() (ids []uuid.UUID) {
	for id := range m.removedtest_sessions {
		ids = append(ids, id)
	}
	return
}

// TestSessionsIDs returns the "test_sessions" edge IDs in the mutation.
func (m *TestMutation) TestSessionsIDs() (ids []uuid.UUID) {
	for id := range m.test_sessions {
		ids = append(ids, id)
	}
	return
}

// ResetTestSessions resets all changes to the "test_sessions" edge.
func (m *TestMutation) ResetTestSessions() {
	m.test_sessions = nil
	m.clearedtest_sessions = false
	m.removedtest_sessions = nil
}

// AddQuestionIDs adds the "questions" edge to the Question entity by ids.
func (m *TestMutation) AddQuestionIDs(ids ...uuid.UUID) {
	if m.questions == nil {
		m.questions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.questions[ids[i]] = struct{}{}
	}
}

// ClearQuestions clears the "questions" edge to the Question entity.
func (m *TestMutation) ClearQuestions() {
	m.clearedquestions = true
}

// QuestionsCleared reports if the "questions" edge to the Question entity was cleared.
func (m *TestMutation) QuestionsCleared() bool {
	return m.clearedquestions
}

// RemoveQuestionIDs removes the "questions" edge to the Question entity by IDs.
func (m *TestMutation) RemoveQuestionIDs(ids ...uuid.UUID) {
	if m.removedquestions == nil {
		m.removedquestions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.questions, ids[i])
		m.removedquestions[ids[i]] = struct{}{}
	}
}

// RemovedQuestions returns the removed IDs of the "questions" edge to the Question entity.
func (m *TestMutation) RemovedQuestionsIDs() (ids []uuid.UUID) {
	for id := range m.removedquestions {
		ids = append(ids, id)
	}
	return
}

// QuestionsIDs returns the "questions" edge IDs in the mutation.
func (m *TestMutation) QuestionsIDs() (ids []uuid.UUID) {
	for id := range m.questions {
		ids = append(ids, id)
	}
	return
}

// ResetQuestions resets all changes to the "questions" edge.
func (m *TestMutation) ResetQuestions() {
	m.questions = nil
	m.clearedquestions = false
	m.removedquestions = nil
}

// Where appends a list predicates to the TestMutation builder.
func (m *TestMutation) Where(ps ...predicate.Test) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Test, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Test).
func (m *TestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TestMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, test.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, test.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, test.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, test.FieldName)
	}
	if m.course_section != nil {
		fields = append(fields, test.FieldCourseSectionID)
	}
	if m.course != nil {
		fields = append(fields, test.FieldCourseID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case test.FieldCreatedAt:
		return m.CreatedAt()
	case test.FieldUpdatedAt:
		return m.UpdatedAt()
	case test.FieldDeletedAt:
		return m.DeletedAt()
	case test.FieldName:
		return m.Name()
	case test.FieldCourseSectionID:
		return m.CourseSectionID()
	case test.FieldCourseID:
		return m.CourseID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case test.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case test.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case test.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case test.FieldName:
		return m.OldName(ctx)
	case test.FieldCourseSectionID:
		return m.OldCourseSectionID(ctx)
	case test.FieldCourseID:
		return m.OldCourseID(ctx)
	}
	return nil, fmt.Errorf("unknown Test field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case test.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case test.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case test.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case test.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case test.FieldCourseSectionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseSectionID(v)
		return nil
	case test.FieldCourseID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseID(v)
		return nil
	}
	return fmt.Errorf("unknown Test field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TestMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TestMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Test numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(test.FieldDeletedAt) {
		fields = append(fields, test.FieldDeletedAt)
	}
	if m.FieldCleared(test.FieldCourseSectionID) {
		fields = append(fields, test.FieldCourseSectionID)
	}
	if m.FieldCleared(test.FieldCourseID) {
		fields = append(fields, test.FieldCourseID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TestMutation) ClearField(name string) error {
	switch name {
	case test.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case test.FieldCourseSectionID:
		m.ClearCourseSectionID()
		return nil
	case test.FieldCourseID:
		m.ClearCourseID()
		return nil
	}
	return fmt.Errorf("unknown Test nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TestMutation) ResetField(name string) error {
	switch name {
	case test.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case test.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case test.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case test.FieldName:
		m.ResetName()
		return nil
	case test.FieldCourseSectionID:
		m.ResetCourseSectionID()
		return nil
	case test.FieldCourseID:
		m.ResetCourseID()
		return nil
	}
	return fmt.Errorf("unknown Test field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TestMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.course_section != nil {
		edges = append(edges, test.EdgeCourseSection)
	}
	if m.course != nil {
		edges = append(edges, test.EdgeCourse)
	}
	if m.test_sessions != nil {
		edges = append(edges, test.EdgeTestSessions)
	}
	if m.questions != nil {
		edges = append(edges, test.EdgeQuestions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case test.EdgeCourseSection:
		if id := m.course_section; id != nil {
			return []ent.Value{*id}
		}
	case test.EdgeCourse:
		if id := m.course; id != nil {
			return []ent.Value{*id}
		}
	case test.EdgeTestSessions:
		ids := make([]ent.Value, 0, len(m.test_sessions))
		for id := range m.test_sessions {
			ids = append(ids, id)
		}
		return ids
	case test.EdgeQuestions:
		ids := make([]ent.Value, 0, len(m.questions))
		for id := range m.questions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedtest_sessions != nil {
		edges = append(edges, test.EdgeTestSessions)
	}
	if m.removedquestions != nil {
		edges = append(edges, test.EdgeQuestions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TestMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case test.EdgeTestSessions:
		ids := make([]ent.Value, 0, len(m.removedtest_sessions))
		for id := range m.removedtest_sessions {
			ids = append(ids, id)
		}
		return ids
	case test.EdgeQuestions:
		ids := make([]ent.Value, 0, len(m.removedquestions))
		for id := range m.removedquestions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcourse_section {
		edges = append(edges, test.EdgeCourseSection)
	}
	if m.clearedcourse {
		edges = append(edges, test.EdgeCourse)
	}
	if m.clearedtest_sessions {
		edges = append(edges, test.EdgeTestSessions)
	}
	if m.clearedquestions {
		edges = append(edges, test.EdgeQuestions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TestMutation) EdgeCleared(name string) bool {
	switch name {
	case test.EdgeCourseSection:
		return m.clearedcourse_section
	case test.EdgeCourse:
		return m.clearedcourse
	case test.EdgeTestSessions:
		return m.clearedtest_sessions
	case test.EdgeQuestions:
		return m.clearedquestions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TestMutation) ClearEdge(name string) error {
	switch name {
	case test.EdgeCourseSection:
		m.ClearCourseSection()
		return nil
	case test.EdgeCourse:
		m.ClearCourse()
		return nil
	}
	return fmt.Errorf("unknown Test unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TestMutation) ResetEdge(name string) error {
	switch name {
	case test.EdgeCourseSection:
		m.ResetCourseSection()
		return nil
	case test.EdgeCourse:
		m.ResetCourse()
		return nil
	case test.EdgeTestSessions:
		m.ResetTestSessions()
		return nil
	case test.EdgeQuestions:
		m.ResetQuestions()
		return nil
	}
	return fmt.Errorf("unknown Test edge %s", name)
}

// TestSessionMutation represents an operation that mutates the TestSession nodes in the graph.
type TestSessionMutation struct {
	config
	op                           Op
	typ                          string
	id                           *uuid.UUID
	created_at                   *time.Time
	updated_at                   *time.Time
	deleted_at                   *time.Time
	completed_at                 *time.Time
	total_score                  *int
	addtotal_score               *int
	clearedFields                map[string]struct{}
	user                         *uuid.UUID
	cleareduser                  bool
	course_section               *uuid.UUID
	clearedcourse_section        bool
	test                         *uuid.UUID
	clearedtest                  bool
	user_question_answers        map[uuid.UUID]struct{}
	removeduser_question_answers map[uuid.UUID]struct{}
	cleareduser_question_answers bool
	done                         bool
	oldValue                     func(context.Context) (*TestSession, error)
	predicates                   []predicate.TestSession
}

var _ ent.Mutation = (*TestSessionMutation)(nil)

// testsessionOption allows management of the mutation configuration using functional options.
type testsessionOption func(*TestSessionMutation)

// newTestSessionMutation creates new mutation for the TestSession entity.
func newTestSessionMutation(c config, op Op, opts ...testsessionOption) *TestSessionMutation {
	m := &TestSessionMutation{
		config:        c,
		op:            op,
		typ:           TypeTestSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTestSessionID sets the ID field of the mutation.
func withTestSessionID(id uuid.UUID) testsessionOption {
	return func(m *TestSessionMutation) {
		var (
			err   error
			once  sync.Once
			value *TestSession
		)
		m.oldValue = func(ctx context.Context) (*TestSession, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TestSession.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTestSession sets the old TestSession of the mutation.
func withTestSession(node *TestSession) testsessionOption {
	return func(m *TestSessionMutation) {
		m.oldValue = func(context.Context) (*TestSession, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TestSessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TestSessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TestSession entities.
func (m *TestSessionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TestSessionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TestSessionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TestSession.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TestSessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TestSessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TestSession entity.
// If the TestSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestSessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TestSessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TestSessionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TestSessionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TestSession entity.
// If the TestSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestSessionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TestSessionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TestSessionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TestSessionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TestSession entity.
// If the TestSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestSessionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TestSessionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[testsession.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TestSessionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[testsession.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TestSessionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, testsession.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *TestSessionMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TestSessionMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the TestSession entity.
// If the TestSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestSessionMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TestSessionMutation) ResetUserID() {
	m.user = nil
}

// SetCourseSectionID sets the "course_section_id" field.
func (m *TestSessionMutation) SetCourseSectionID(u uuid.UUID) {
	m.course_section = &u
}

// CourseSectionID returns the value of the "course_section_id" field in the mutation.
func (m *TestSessionMutation) CourseSectionID() (r uuid.UUID, exists bool) {
	v := m.course_section
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseSectionID returns the old "course_section_id" field's value of the TestSession entity.
// If the TestSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestSessionMutation) OldCourseSectionID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCourseSectionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCourseSectionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseSectionID: %w", err)
	}
	return oldValue.CourseSectionID, nil
}

// ClearCourseSectionID clears the value of the "course_section_id" field.
func (m *TestSessionMutation) ClearCourseSectionID() {
	m.course_section = nil
	m.clearedFields[testsession.FieldCourseSectionID] = struct{}{}
}

// CourseSectionIDCleared returns if the "course_section_id" field was cleared in this mutation.
func (m *TestSessionMutation) CourseSectionIDCleared() bool {
	_, ok := m.clearedFields[testsession.FieldCourseSectionID]
	return ok
}

// ResetCourseSectionID resets all changes to the "course_section_id" field.
func (m *TestSessionMutation) ResetCourseSectionID() {
	m.course_section = nil
	delete(m.clearedFields, testsession.FieldCourseSectionID)
}

// SetTestID sets the "test_id" field.
func (m *TestSessionMutation) SetTestID(u uuid.UUID) {
	m.test = &u
}

// TestID returns the value of the "test_id" field in the mutation.
func (m *TestSessionMutation) TestID() (r uuid.UUID, exists bool) {
	v := m.test
	if v == nil {
		return
	}
	return *v, true
}

// OldTestID returns the old "test_id" field's value of the TestSession entity.
// If the TestSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestSessionMutation) OldTestID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestID: %w", err)
	}
	return oldValue.TestID, nil
}

// ResetTestID resets all changes to the "test_id" field.
func (m *TestSessionMutation) ResetTestID() {
	m.test = nil
}

// SetCompletedAt sets the "completed_at" field.
func (m *TestSessionMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *TestSessionMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the TestSession entity.
// If the TestSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestSessionMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *TestSessionMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[testsession.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *TestSessionMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[testsession.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *TestSessionMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, testsession.FieldCompletedAt)
}

// SetTotalScore sets the "total_score" field.
func (m *TestSessionMutation) SetTotalScore(i int) {
	m.total_score = &i
	m.addtotal_score = nil
}

// TotalScore returns the value of the "total_score" field in the mutation.
func (m *TestSessionMutation) TotalScore() (r int, exists bool) {
	v := m.total_score
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalScore returns the old "total_score" field's value of the TestSession entity.
// If the TestSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestSessionMutation) OldTotalScore(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalScore: %w", err)
	}
	return oldValue.TotalScore, nil
}

// AddTotalScore adds i to the "total_score" field.
func (m *TestSessionMutation) AddTotalScore(i int) {
	if m.addtotal_score != nil {
		*m.addtotal_score += i
	} else {
		m.addtotal_score = &i
	}
}

// AddedTotalScore returns the value that was added to the "total_score" field in this mutation.
func (m *TestSessionMutation) AddedTotalScore() (r int, exists bool) {
	v := m.addtotal_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalScore resets all changes to the "total_score" field.
func (m *TestSessionMutation) ResetTotalScore() {
	m.total_score = nil
	m.addtotal_score = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *TestSessionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[testsession.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TestSessionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TestSessionMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TestSessionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearCourseSection clears the "course_section" edge to the CourseSection entity.
func (m *TestSessionMutation) ClearCourseSection() {
	m.clearedcourse_section = true
	m.clearedFields[testsession.FieldCourseSectionID] = struct{}{}
}

// CourseSectionCleared reports if the "course_section" edge to the CourseSection entity was cleared.
func (m *TestSessionMutation) CourseSectionCleared() bool {
	return m.CourseSectionIDCleared() || m.clearedcourse_section
}

// CourseSectionIDs returns the "course_section" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CourseSectionID instead. It exists only for internal usage by the builders.
func (m *TestSessionMutation) CourseSectionIDs() (ids []uuid.UUID) {
	if id := m.course_section; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourseSection resets all changes to the "course_section" edge.
func (m *TestSessionMutation) ResetCourseSection() {
	m.course_section = nil
	m.clearedcourse_section = false
}

// ClearTest clears the "test" edge to the Test entity.
func (m *TestSessionMutation) ClearTest() {
	m.clearedtest = true
	m.clearedFields[testsession.FieldTestID] = struct{}{}
}

// TestCleared reports if the "test" edge to the Test entity was cleared.
func (m *TestSessionMutation) TestCleared() bool {
	return m.clearedtest
}

// TestIDs returns the "test" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TestID instead. It exists only for internal usage by the builders.
func (m *TestSessionMutation) TestIDs() (ids []uuid.UUID) {
	if id := m.test; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTest resets all changes to the "test" edge.
func (m *TestSessionMutation) ResetTest() {
	m.test = nil
	m.clearedtest = false
}

// AddUserQuestionAnswerIDs adds the "user_question_answers" edge to the UserQuestionAnswer entity by ids.
func (m *TestSessionMutation) AddUserQuestionAnswerIDs(ids ...uuid.UUID) {
	if m.user_question_answers == nil {
		m.user_question_answers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_question_answers[ids[i]] = struct{}{}
	}
}

// ClearUserQuestionAnswers clears the "user_question_answers" edge to the UserQuestionAnswer entity.
func (m *TestSessionMutation) ClearUserQuestionAnswers() {
	m.cleareduser_question_answers = true
}

// UserQuestionAnswersCleared reports if the "user_question_answers" edge to the UserQuestionAnswer entity was cleared.
func (m *TestSessionMutation) UserQuestionAnswersCleared() bool {
	return m.cleareduser_question_answers
}

// RemoveUserQuestionAnswerIDs removes the "user_question_answers" edge to the UserQuestionAnswer entity by IDs.
func (m *TestSessionMutation) RemoveUserQuestionAnswerIDs(ids ...uuid.UUID) {
	if m.removeduser_question_answers == nil {
		m.removeduser_question_answers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_question_answers, ids[i])
		m.removeduser_question_answers[ids[i]] = struct{}{}
	}
}

// RemovedUserQuestionAnswers returns the removed IDs of the "user_question_answers" edge to the UserQuestionAnswer entity.
func (m *TestSessionMutation) RemovedUserQuestionAnswersIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_question_answers {
		ids = append(ids, id)
	}
	return
}

// UserQuestionAnswersIDs returns the "user_question_answers" edge IDs in the mutation.
func (m *TestSessionMutation) UserQuestionAnswersIDs() (ids []uuid.UUID) {
	for id := range m.user_question_answers {
		ids = append(ids, id)
	}
	return
}

// ResetUserQuestionAnswers resets all changes to the "user_question_answers" edge.
func (m *TestSessionMutation) ResetUserQuestionAnswers() {
	m.user_question_answers = nil
	m.cleareduser_question_answers = false
	m.removeduser_question_answers = nil
}

// Where appends a list predicates to the TestSessionMutation builder.
func (m *TestSessionMutation) Where(ps ...predicate.TestSession) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TestSessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TestSessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TestSession, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TestSessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TestSessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TestSession).
func (m *TestSessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TestSessionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, testsession.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, testsession.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, testsession.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, testsession.FieldUserID)
	}
	if m.course_section != nil {
		fields = append(fields, testsession.FieldCourseSectionID)
	}
	if m.test != nil {
		fields = append(fields, testsession.FieldTestID)
	}
	if m.completed_at != nil {
		fields = append(fields, testsession.FieldCompletedAt)
	}
	if m.total_score != nil {
		fields = append(fields, testsession.FieldTotalScore)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TestSessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case testsession.FieldCreatedAt:
		return m.CreatedAt()
	case testsession.FieldUpdatedAt:
		return m.UpdatedAt()
	case testsession.FieldDeletedAt:
		return m.DeletedAt()
	case testsession.FieldUserID:
		return m.UserID()
	case testsession.FieldCourseSectionID:
		return m.CourseSectionID()
	case testsession.FieldTestID:
		return m.TestID()
	case testsession.FieldCompletedAt:
		return m.CompletedAt()
	case testsession.FieldTotalScore:
		return m.TotalScore()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TestSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case testsession.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case testsession.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case testsession.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case testsession.FieldUserID:
		return m.OldUserID(ctx)
	case testsession.FieldCourseSectionID:
		return m.OldCourseSectionID(ctx)
	case testsession.FieldTestID:
		return m.OldTestID(ctx)
	case testsession.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case testsession.FieldTotalScore:
		return m.OldTotalScore(ctx)
	}
	return nil, fmt.Errorf("unknown TestSession field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestSessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case testsession.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case testsession.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case testsession.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case testsession.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case testsession.FieldCourseSectionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseSectionID(v)
		return nil
	case testsession.FieldTestID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestID(v)
		return nil
	case testsession.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case testsession.FieldTotalScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalScore(v)
		return nil
	}
	return fmt.Errorf("unknown TestSession field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TestSessionMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_score != nil {
		fields = append(fields, testsession.FieldTotalScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TestSessionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case testsession.FieldTotalScore:
		return m.AddedTotalScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestSessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case testsession.FieldTotalScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalScore(v)
		return nil
	}
	return fmt.Errorf("unknown TestSession numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TestSessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(testsession.FieldDeletedAt) {
		fields = append(fields, testsession.FieldDeletedAt)
	}
	if m.FieldCleared(testsession.FieldCourseSectionID) {
		fields = append(fields, testsession.FieldCourseSectionID)
	}
	if m.FieldCleared(testsession.FieldCompletedAt) {
		fields = append(fields, testsession.FieldCompletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TestSessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TestSessionMutation) ClearField(name string) error {
	switch name {
	case testsession.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case testsession.FieldCourseSectionID:
		m.ClearCourseSectionID()
		return nil
	case testsession.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown TestSession nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TestSessionMutation) ResetField(name string) error {
	switch name {
	case testsession.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case testsession.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case testsession.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case testsession.FieldUserID:
		m.ResetUserID()
		return nil
	case testsession.FieldCourseSectionID:
		m.ResetCourseSectionID()
		return nil
	case testsession.FieldTestID:
		m.ResetTestID()
		return nil
	case testsession.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case testsession.FieldTotalScore:
		m.ResetTotalScore()
		return nil
	}
	return fmt.Errorf("unknown TestSession field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TestSessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, testsession.EdgeUser)
	}
	if m.course_section != nil {
		edges = append(edges, testsession.EdgeCourseSection)
	}
	if m.test != nil {
		edges = append(edges, testsession.EdgeTest)
	}
	if m.user_question_answers != nil {
		edges = append(edges, testsession.EdgeUserQuestionAnswers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TestSessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case testsession.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case testsession.EdgeCourseSection:
		if id := m.course_section; id != nil {
			return []ent.Value{*id}
		}
	case testsession.EdgeTest:
		if id := m.test; id != nil {
			return []ent.Value{*id}
		}
	case testsession.EdgeUserQuestionAnswers:
		ids := make([]ent.Value, 0, len(m.user_question_answers))
		for id := range m.user_question_answers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TestSessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removeduser_question_answers != nil {
		edges = append(edges, testsession.EdgeUserQuestionAnswers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TestSessionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case testsession.EdgeUserQuestionAnswers:
		ids := make([]ent.Value, 0, len(m.removeduser_question_answers))
		for id := range m.removeduser_question_answers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TestSessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, testsession.EdgeUser)
	}
	if m.clearedcourse_section {
		edges = append(edges, testsession.EdgeCourseSection)
	}
	if m.clearedtest {
		edges = append(edges, testsession.EdgeTest)
	}
	if m.cleareduser_question_answers {
		edges = append(edges, testsession.EdgeUserQuestionAnswers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TestSessionMutation) EdgeCleared(name string) bool {
	switch name {
	case testsession.EdgeUser:
		return m.cleareduser
	case testsession.EdgeCourseSection:
		return m.clearedcourse_section
	case testsession.EdgeTest:
		return m.clearedtest
	case testsession.EdgeUserQuestionAnswers:
		return m.cleareduser_question_answers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TestSessionMutation) ClearEdge(name string) error {
	switch name {
	case testsession.EdgeUser:
		m.ClearUser()
		return nil
	case testsession.EdgeCourseSection:
		m.ClearCourseSection()
		return nil
	case testsession.EdgeTest:
		m.ClearTest()
		return nil
	}
	return fmt.Errorf("unknown TestSession unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TestSessionMutation) ResetEdge(name string) error {
	switch name {
	case testsession.EdgeUser:
		m.ResetUser()
		return nil
	case testsession.EdgeCourseSection:
		m.ResetCourseSection()
		return nil
	case testsession.EdgeTest:
		m.ResetTest()
		return nil
	case testsession.EdgeUserQuestionAnswers:
		m.ResetUserQuestionAnswers()
		return nil
	}
	return fmt.Errorf("unknown TestSession edge %s", name)
}

// TodoMutation represents an operation that mutates the Todo nodes in the graph.
type TodoMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	title         *string
	description   *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Todo, error)
	predicates    []predicate.Todo
}

var _ ent.Mutation = (*TodoMutation)(nil)

// todoOption allows management of the mutation configuration using functional options.
type todoOption func(*TodoMutation)

// newTodoMutation creates new mutation for the Todo entity.
func newTodoMutation(c config, op Op, opts ...todoOption) *TodoMutation {
	m := &TodoMutation{
		config:        c,
		op:            op,
		typ:           TypeTodo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTodoID sets the ID field of the mutation.
func withTodoID(id uuid.UUID) todoOption {
	return func(m *TodoMutation) {
		var (
			err   error
			once  sync.Once
			value *Todo
		)
		m.oldValue = func(ctx context.Context) (*Todo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Todo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTodo sets the old Todo of the mutation.
func withTodo(node *Todo) todoOption {
	return func(m *TodoMutation) {
		m.oldValue = func(context.Context) (*Todo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TodoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TodoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Todo entities.
func (m *TodoMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TodoMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TodoMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Todo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TodoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TodoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Todo entity.
// If the Todo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TodoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TodoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TodoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TodoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Todo entity.
// If the Todo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TodoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TodoMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TodoMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TodoMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Todo entity.
// If the Todo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TodoMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TodoMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[todo.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TodoMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[todo.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TodoMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, todo.FieldDeletedAt)
}

// SetTitle sets the "title" field.
func (m *TodoMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *TodoMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Todo entity.
// If the Todo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TodoMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *TodoMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *TodoMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TodoMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Todo entity.
// If the Todo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TodoMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TodoMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[todo.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TodoMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[todo.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TodoMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, todo.FieldDescription)
}

// Where appends a list predicates to the TodoMutation builder.
func (m *TodoMutation) Where(ps ...predicate.Todo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TodoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TodoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Todo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TodoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TodoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Todo).
func (m *TodoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TodoMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, todo.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, todo.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, todo.FieldDeletedAt)
	}
	if m.title != nil {
		fields = append(fields, todo.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, todo.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TodoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case todo.FieldCreatedAt:
		return m.CreatedAt()
	case todo.FieldUpdatedAt:
		return m.UpdatedAt()
	case todo.FieldDeletedAt:
		return m.DeletedAt()
	case todo.FieldTitle:
		return m.Title()
	case todo.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TodoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case todo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case todo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case todo.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case todo.FieldTitle:
		return m.OldTitle(ctx)
	case todo.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Todo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TodoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case todo.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case todo.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case todo.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case todo.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case todo.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Todo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TodoMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TodoMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TodoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Todo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TodoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(todo.FieldDeletedAt) {
		fields = append(fields, todo.FieldDeletedAt)
	}
	if m.FieldCleared(todo.FieldDescription) {
		fields = append(fields, todo.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TodoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TodoMutation) ClearField(name string) error {
	switch name {
	case todo.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case todo.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Todo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TodoMutation) ResetField(name string) error {
	switch name {
	case todo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case todo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case todo.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case todo.FieldTitle:
		m.ResetTitle()
		return nil
	case todo.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Todo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TodoMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TodoMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TodoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TodoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TodoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TodoMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TodoMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Todo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TodoMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Todo edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                           Op
	typ                          string
	id                           *uuid.UUID
	created_at                   *time.Time
	updated_at                   *time.Time
	deleted_at                   *time.Time
	username                     *string
	email                        *string
	password_hash                *string
	first_name                   *string
	last_name                    *string
	is_active                    *bool
	clearedFields                map[string]struct{}
	media                        *uuid.UUID
	clearedmedia                 bool
	media_uploader               map[uuid.UUID]struct{}
	removedmedia_uploader        map[uuid.UUID]struct{}
	clearedmedia_uploader        bool
	roles                        map[uuid.UUID]struct{}
	removedroles                 map[uuid.UUID]struct{}
	clearedroles                 bool
	course_creator               map[uuid.UUID]struct{}
	removedcourse_creator        map[uuid.UUID]struct{}
	clearedcourse_creator        bool
	user_question_answers        map[uuid.UUID]struct{}
	removeduser_question_answers map[uuid.UUID]struct{}
	cleareduser_question_answers bool
	test_sessions                map[uuid.UUID]struct{}
	removedtest_sessions         map[uuid.UUID]struct{}
	clearedtest_sessions         bool
	user_roles                   map[uuid.UUID]struct{}
	removeduser_roles            map[uuid.UUID]struct{}
	cleareduser_roles            bool
	done                         bool
	oldValue                     func(context.Context) (*User, error)
	predicates                   []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ClearFirstName clears the value of the "first_name" field.
func (m *UserMutation) ClearFirstName() {
	m.first_name = nil
	m.clearedFields[user.FieldFirstName] = struct{}{}
}

// FirstNameCleared returns if the "first_name" field was cleared in this mutation.
func (m *UserMutation) FirstNameCleared() bool {
	_, ok := m.clearedFields[user.FieldFirstName]
	return ok
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
	delete(m.clearedFields, user.FieldFirstName)
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ClearLastName clears the value of the "last_name" field.
func (m *UserMutation) ClearLastName() {
	m.last_name = nil
	m.clearedFields[user.FieldLastName] = struct{}{}
}

// LastNameCleared returns if the "last_name" field was cleared in this mutation.
func (m *UserMutation) LastNameCleared() bool {
	_, ok := m.clearedFields[user.FieldLastName]
	return ok
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
	delete(m.clearedFields, user.FieldLastName)
}

// SetAvatarID sets the "avatar_id" field.
func (m *UserMutation) SetAvatarID(u uuid.UUID) {
	m.media = &u
}

// AvatarID returns the value of the "avatar_id" field in the mutation.
func (m *UserMutation) AvatarID() (r uuid.UUID, exists bool) {
	v := m.media
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarID returns the old "avatar_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatarID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarID: %w", err)
	}
	return oldValue.AvatarID, nil
}

// ClearAvatarID clears the value of the "avatar_id" field.
func (m *UserMutation) ClearAvatarID() {
	m.media = nil
	m.clearedFields[user.FieldAvatarID] = struct{}{}
}

// AvatarIDCleared returns if the "avatar_id" field was cleared in this mutation.
func (m *UserMutation) AvatarIDCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatarID]
	return ok
}

// ResetAvatarID resets all changes to the "avatar_id" field.
func (m *UserMutation) ResetAvatarID() {
	m.media = nil
	delete(m.clearedFields, user.FieldAvatarID)
}

// SetIsActive sets the "is_active" field.
func (m *UserMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *UserMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *UserMutation) ResetIsActive() {
	m.is_active = nil
}

// SetMediaID sets the "media" edge to the Media entity by id.
func (m *UserMutation) SetMediaID(id uuid.UUID) {
	m.media = &id
}

// ClearMedia clears the "media" edge to the Media entity.
func (m *UserMutation) ClearMedia() {
	m.clearedmedia = true
	m.clearedFields[user.FieldAvatarID] = struct{}{}
}

// MediaCleared reports if the "media" edge to the Media entity was cleared.
func (m *UserMutation) MediaCleared() bool {
	return m.AvatarIDCleared() || m.clearedmedia
}

// MediaID returns the "media" edge ID in the mutation.
func (m *UserMutation) MediaID() (id uuid.UUID, exists bool) {
	if m.media != nil {
		return *m.media, true
	}
	return
}

// MediaIDs returns the "media" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MediaID instead. It exists only for internal usage by the builders.
func (m *UserMutation) MediaIDs() (ids []uuid.UUID) {
	if id := m.media; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMedia resets all changes to the "media" edge.
func (m *UserMutation) ResetMedia() {
	m.media = nil
	m.clearedmedia = false
}

// AddMediaUploaderIDs adds the "media_uploader" edge to the Media entity by ids.
func (m *UserMutation) AddMediaUploaderIDs(ids ...uuid.UUID) {
	if m.media_uploader == nil {
		m.media_uploader = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.media_uploader[ids[i]] = struct{}{}
	}
}

// ClearMediaUploader clears the "media_uploader" edge to the Media entity.
func (m *UserMutation) ClearMediaUploader() {
	m.clearedmedia_uploader = true
}

// MediaUploaderCleared reports if the "media_uploader" edge to the Media entity was cleared.
func (m *UserMutation) MediaUploaderCleared() bool {
	return m.clearedmedia_uploader
}

// RemoveMediaUploaderIDs removes the "media_uploader" edge to the Media entity by IDs.
func (m *UserMutation) RemoveMediaUploaderIDs(ids ...uuid.UUID) {
	if m.removedmedia_uploader == nil {
		m.removedmedia_uploader = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.media_uploader, ids[i])
		m.removedmedia_uploader[ids[i]] = struct{}{}
	}
}

// RemovedMediaUploader returns the removed IDs of the "media_uploader" edge to the Media entity.
func (m *UserMutation) RemovedMediaUploaderIDs() (ids []uuid.UUID) {
	for id := range m.removedmedia_uploader {
		ids = append(ids, id)
	}
	return
}

// MediaUploaderIDs returns the "media_uploader" edge IDs in the mutation.
func (m *UserMutation) MediaUploaderIDs() (ids []uuid.UUID) {
	for id := range m.media_uploader {
		ids = append(ids, id)
	}
	return
}

// ResetMediaUploader resets all changes to the "media_uploader" edge.
func (m *UserMutation) ResetMediaUploader() {
	m.media_uploader = nil
	m.clearedmedia_uploader = false
	m.removedmedia_uploader = nil
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *UserMutation) AddRoleIDs(ids ...uuid.UUID) {
	if m.roles == nil {
		m.roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *UserMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *UserMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *UserMutation) RemoveRoleIDs(ids ...uuid.UUID) {
	if m.removedroles == nil {
		m.removedroles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *UserMutation) RemovedRolesIDs() (ids []uuid.UUID) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *UserMutation) RolesIDs() (ids []uuid.UUID) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *UserMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// AddCourseCreatorIDs adds the "course_creator" edge to the Course entity by ids.
func (m *UserMutation) AddCourseCreatorIDs(ids ...uuid.UUID) {
	if m.course_creator == nil {
		m.course_creator = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.course_creator[ids[i]] = struct{}{}
	}
}

// ClearCourseCreator clears the "course_creator" edge to the Course entity.
func (m *UserMutation) ClearCourseCreator() {
	m.clearedcourse_creator = true
}

// CourseCreatorCleared reports if the "course_creator" edge to the Course entity was cleared.
func (m *UserMutation) CourseCreatorCleared() bool {
	return m.clearedcourse_creator
}

// RemoveCourseCreatorIDs removes the "course_creator" edge to the Course entity by IDs.
func (m *UserMutation) RemoveCourseCreatorIDs(ids ...uuid.UUID) {
	if m.removedcourse_creator == nil {
		m.removedcourse_creator = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.course_creator, ids[i])
		m.removedcourse_creator[ids[i]] = struct{}{}
	}
}

// RemovedCourseCreator returns the removed IDs of the "course_creator" edge to the Course entity.
func (m *UserMutation) RemovedCourseCreatorIDs() (ids []uuid.UUID) {
	for id := range m.removedcourse_creator {
		ids = append(ids, id)
	}
	return
}

// CourseCreatorIDs returns the "course_creator" edge IDs in the mutation.
func (m *UserMutation) CourseCreatorIDs() (ids []uuid.UUID) {
	for id := range m.course_creator {
		ids = append(ids, id)
	}
	return
}

// ResetCourseCreator resets all changes to the "course_creator" edge.
func (m *UserMutation) ResetCourseCreator() {
	m.course_creator = nil
	m.clearedcourse_creator = false
	m.removedcourse_creator = nil
}

// AddUserQuestionAnswerIDs adds the "user_question_answers" edge to the UserQuestionAnswer entity by ids.
func (m *UserMutation) AddUserQuestionAnswerIDs(ids ...uuid.UUID) {
	if m.user_question_answers == nil {
		m.user_question_answers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_question_answers[ids[i]] = struct{}{}
	}
}

// ClearUserQuestionAnswers clears the "user_question_answers" edge to the UserQuestionAnswer entity.
func (m *UserMutation) ClearUserQuestionAnswers() {
	m.cleareduser_question_answers = true
}

// UserQuestionAnswersCleared reports if the "user_question_answers" edge to the UserQuestionAnswer entity was cleared.
func (m *UserMutation) UserQuestionAnswersCleared() bool {
	return m.cleareduser_question_answers
}

// RemoveUserQuestionAnswerIDs removes the "user_question_answers" edge to the UserQuestionAnswer entity by IDs.
func (m *UserMutation) RemoveUserQuestionAnswerIDs(ids ...uuid.UUID) {
	if m.removeduser_question_answers == nil {
		m.removeduser_question_answers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_question_answers, ids[i])
		m.removeduser_question_answers[ids[i]] = struct{}{}
	}
}

// RemovedUserQuestionAnswers returns the removed IDs of the "user_question_answers" edge to the UserQuestionAnswer entity.
func (m *UserMutation) RemovedUserQuestionAnswersIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_question_answers {
		ids = append(ids, id)
	}
	return
}

// UserQuestionAnswersIDs returns the "user_question_answers" edge IDs in the mutation.
func (m *UserMutation) UserQuestionAnswersIDs() (ids []uuid.UUID) {
	for id := range m.user_question_answers {
		ids = append(ids, id)
	}
	return
}

// ResetUserQuestionAnswers resets all changes to the "user_question_answers" edge.
func (m *UserMutation) ResetUserQuestionAnswers() {
	m.user_question_answers = nil
	m.cleareduser_question_answers = false
	m.removeduser_question_answers = nil
}

// AddTestSessionIDs adds the "test_sessions" edge to the TestSession entity by ids.
func (m *UserMutation) AddTestSessionIDs(ids ...uuid.UUID) {
	if m.test_sessions == nil {
		m.test_sessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.test_sessions[ids[i]] = struct{}{}
	}
}

// ClearTestSessions clears the "test_sessions" edge to the TestSession entity.
func (m *UserMutation) ClearTestSessions() {
	m.clearedtest_sessions = true
}

// TestSessionsCleared reports if the "test_sessions" edge to the TestSession entity was cleared.
func (m *UserMutation) TestSessionsCleared() bool {
	return m.clearedtest_sessions
}

// RemoveTestSessionIDs removes the "test_sessions" edge to the TestSession entity by IDs.
func (m *UserMutation) RemoveTestSessionIDs(ids ...uuid.UUID) {
	if m.removedtest_sessions == nil {
		m.removedtest_sessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.test_sessions, ids[i])
		m.removedtest_sessions[ids[i]] = struct{}{}
	}
}

// RemovedTestSessions returns the removed IDs of the "test_sessions" edge to the TestSession entity.
func (m *UserMutation) RemovedTestSessionsIDs() (ids []uuid.UUID) {
	for id := range m.removedtest_sessions {
		ids = append(ids, id)
	}
	return
}

// TestSessionsIDs returns the "test_sessions" edge IDs in the mutation.
func (m *UserMutation) TestSessionsIDs() (ids []uuid.UUID) {
	for id := range m.test_sessions {
		ids = append(ids, id)
	}
	return
}

// ResetTestSessions resets all changes to the "test_sessions" edge.
func (m *UserMutation) ResetTestSessions() {
	m.test_sessions = nil
	m.clearedtest_sessions = false
	m.removedtest_sessions = nil
}

// AddUserRoleIDs adds the "user_roles" edge to the UserRole entity by ids.
func (m *UserMutation) AddUserRoleIDs(ids ...uuid.UUID) {
	if m.user_roles == nil {
		m.user_roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_roles[ids[i]] = struct{}{}
	}
}

// ClearUserRoles clears the "user_roles" edge to the UserRole entity.
func (m *UserMutation) ClearUserRoles() {
	m.cleareduser_roles = true
}

// UserRolesCleared reports if the "user_roles" edge to the UserRole entity was cleared.
func (m *UserMutation) UserRolesCleared() bool {
	return m.cleareduser_roles
}

// RemoveUserRoleIDs removes the "user_roles" edge to the UserRole entity by IDs.
func (m *UserMutation) RemoveUserRoleIDs(ids ...uuid.UUID) {
	if m.removeduser_roles == nil {
		m.removeduser_roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_roles, ids[i])
		m.removeduser_roles[ids[i]] = struct{}{}
	}
}

// RemovedUserRoles returns the removed IDs of the "user_roles" edge to the UserRole entity.
func (m *UserMutation) RemovedUserRolesIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_roles {
		ids = append(ids, id)
	}
	return
}

// UserRolesIDs returns the "user_roles" edge IDs in the mutation.
func (m *UserMutation) UserRolesIDs() (ids []uuid.UUID) {
	for id := range m.user_roles {
		ids = append(ids, id)
	}
	return
}

// ResetUserRoles resets all changes to the "user_roles" edge.
func (m *UserMutation) ResetUserRoles() {
	m.user_roles = nil
	m.cleareduser_roles = false
	m.removeduser_roles = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.media != nil {
		fields = append(fields, user.FieldAvatarID)
	}
	if m.is_active != nil {
		fields = append(fields, user.FieldIsActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldUsername:
		return m.Username()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldAvatarID:
		return m.AvatarID()
	case user.FieldIsActive:
		return m.IsActive()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldAvatarID:
		return m.OldAvatarID(ctx)
	case user.FieldIsActive:
		return m.OldIsActive(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldAvatarID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarID(v)
		return nil
	case user.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.FieldCleared(user.FieldFirstName) {
		fields = append(fields, user.FieldFirstName)
	}
	if m.FieldCleared(user.FieldLastName) {
		fields = append(fields, user.FieldLastName)
	}
	if m.FieldCleared(user.FieldAvatarID) {
		fields = append(fields, user.FieldAvatarID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case user.FieldFirstName:
		m.ClearFirstName()
		return nil
	case user.FieldLastName:
		m.ClearLastName()
		return nil
	case user.FieldAvatarID:
		m.ClearAvatarID()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldAvatarID:
		m.ResetAvatarID()
		return nil
	case user.FieldIsActive:
		m.ResetIsActive()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.media != nil {
		edges = append(edges, user.EdgeMedia)
	}
	if m.media_uploader != nil {
		edges = append(edges, user.EdgeMediaUploader)
	}
	if m.roles != nil {
		edges = append(edges, user.EdgeRoles)
	}
	if m.course_creator != nil {
		edges = append(edges, user.EdgeCourseCreator)
	}
	if m.user_question_answers != nil {
		edges = append(edges, user.EdgeUserQuestionAnswers)
	}
	if m.test_sessions != nil {
		edges = append(edges, user.EdgeTestSessions)
	}
	if m.user_roles != nil {
		edges = append(edges, user.EdgeUserRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeMedia:
		if id := m.media; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeMediaUploader:
		ids := make([]ent.Value, 0, len(m.media_uploader))
		for id := range m.media_uploader {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCourseCreator:
		ids := make([]ent.Value, 0, len(m.course_creator))
		for id := range m.course_creator {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserQuestionAnswers:
		ids := make([]ent.Value, 0, len(m.user_question_answers))
		for id := range m.user_question_answers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTestSessions:
		ids := make([]ent.Value, 0, len(m.test_sessions))
		for id := range m.test_sessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserRoles:
		ids := make([]ent.Value, 0, len(m.user_roles))
		for id := range m.user_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedmedia_uploader != nil {
		edges = append(edges, user.EdgeMediaUploader)
	}
	if m.removedroles != nil {
		edges = append(edges, user.EdgeRoles)
	}
	if m.removedcourse_creator != nil {
		edges = append(edges, user.EdgeCourseCreator)
	}
	if m.removeduser_question_answers != nil {
		edges = append(edges, user.EdgeUserQuestionAnswers)
	}
	if m.removedtest_sessions != nil {
		edges = append(edges, user.EdgeTestSessions)
	}
	if m.removeduser_roles != nil {
		edges = append(edges, user.EdgeUserRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeMediaUploader:
		ids := make([]ent.Value, 0, len(m.removedmedia_uploader))
		for id := range m.removedmedia_uploader {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCourseCreator:
		ids := make([]ent.Value, 0, len(m.removedcourse_creator))
		for id := range m.removedcourse_creator {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserQuestionAnswers:
		ids := make([]ent.Value, 0, len(m.removeduser_question_answers))
		for id := range m.removeduser_question_answers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTestSessions:
		ids := make([]ent.Value, 0, len(m.removedtest_sessions))
		for id := range m.removedtest_sessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserRoles:
		ids := make([]ent.Value, 0, len(m.removeduser_roles))
		for id := range m.removeduser_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedmedia {
		edges = append(edges, user.EdgeMedia)
	}
	if m.clearedmedia_uploader {
		edges = append(edges, user.EdgeMediaUploader)
	}
	if m.clearedroles {
		edges = append(edges, user.EdgeRoles)
	}
	if m.clearedcourse_creator {
		edges = append(edges, user.EdgeCourseCreator)
	}
	if m.cleareduser_question_answers {
		edges = append(edges, user.EdgeUserQuestionAnswers)
	}
	if m.clearedtest_sessions {
		edges = append(edges, user.EdgeTestSessions)
	}
	if m.cleareduser_roles {
		edges = append(edges, user.EdgeUserRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeMedia:
		return m.clearedmedia
	case user.EdgeMediaUploader:
		return m.clearedmedia_uploader
	case user.EdgeRoles:
		return m.clearedroles
	case user.EdgeCourseCreator:
		return m.clearedcourse_creator
	case user.EdgeUserQuestionAnswers:
		return m.cleareduser_question_answers
	case user.EdgeTestSessions:
		return m.clearedtest_sessions
	case user.EdgeUserRoles:
		return m.cleareduser_roles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeMedia:
		m.ClearMedia()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeMedia:
		m.ResetMedia()
		return nil
	case user.EdgeMediaUploader:
		m.ResetMediaUploader()
		return nil
	case user.EdgeRoles:
		m.ResetRoles()
		return nil
	case user.EdgeCourseCreator:
		m.ResetCourseCreator()
		return nil
	case user.EdgeUserQuestionAnswers:
		m.ResetUserQuestionAnswers()
		return nil
	case user.EdgeTestSessions:
		m.ResetTestSessions()
		return nil
	case user.EdgeUserRoles:
		m.ResetUserRoles()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserQuestionAnswerMutation represents an operation that mutates the UserQuestionAnswer nodes in the graph.
type UserQuestionAnswerMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	clearedFields          map[string]struct{}
	user                   *uuid.UUID
	cleareduser            bool
	question               *uuid.UUID
	clearedquestion        bool
	selected_option        *uuid.UUID
	clearedselected_option bool
	test_session           *uuid.UUID
	clearedtest_session    bool
	done                   bool
	oldValue               func(context.Context) (*UserQuestionAnswer, error)
	predicates             []predicate.UserQuestionAnswer
}

var _ ent.Mutation = (*UserQuestionAnswerMutation)(nil)

// userquestionanswerOption allows management of the mutation configuration using functional options.
type userquestionanswerOption func(*UserQuestionAnswerMutation)

// newUserQuestionAnswerMutation creates new mutation for the UserQuestionAnswer entity.
func newUserQuestionAnswerMutation(c config, op Op, opts ...userquestionanswerOption) *UserQuestionAnswerMutation {
	m := &UserQuestionAnswerMutation{
		config:        c,
		op:            op,
		typ:           TypeUserQuestionAnswer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserQuestionAnswerID sets the ID field of the mutation.
func withUserQuestionAnswerID(id uuid.UUID) userquestionanswerOption {
	return func(m *UserQuestionAnswerMutation) {
		var (
			err   error
			once  sync.Once
			value *UserQuestionAnswer
		)
		m.oldValue = func(ctx context.Context) (*UserQuestionAnswer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserQuestionAnswer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserQuestionAnswer sets the old UserQuestionAnswer of the mutation.
func withUserQuestionAnswer(node *UserQuestionAnswer) userquestionanswerOption {
	return func(m *UserQuestionAnswerMutation) {
		m.oldValue = func(context.Context) (*UserQuestionAnswer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserQuestionAnswerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserQuestionAnswerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserQuestionAnswer entities.
func (m *UserQuestionAnswerMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserQuestionAnswerMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserQuestionAnswerMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserQuestionAnswer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserQuestionAnswerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserQuestionAnswerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserQuestionAnswer entity.
// If the UserQuestionAnswer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserQuestionAnswerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserQuestionAnswerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserQuestionAnswerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserQuestionAnswerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserQuestionAnswer entity.
// If the UserQuestionAnswer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserQuestionAnswerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserQuestionAnswerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserQuestionAnswerMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserQuestionAnswerMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserQuestionAnswer entity.
// If the UserQuestionAnswer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserQuestionAnswerMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserQuestionAnswerMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[userquestionanswer.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserQuestionAnswerMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[userquestionanswer.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserQuestionAnswerMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, userquestionanswer.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *UserQuestionAnswerMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserQuestionAnswerMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserQuestionAnswer entity.
// If the UserQuestionAnswer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserQuestionAnswerMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserQuestionAnswerMutation) ResetUserID() {
	m.user = nil
}

// SetQuestionID sets the "question_id" field.
func (m *UserQuestionAnswerMutation) SetQuestionID(u uuid.UUID) {
	m.question = &u
}

// QuestionID returns the value of the "question_id" field in the mutation.
func (m *UserQuestionAnswerMutation) QuestionID() (r uuid.UUID, exists bool) {
	v := m.question
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionID returns the old "question_id" field's value of the UserQuestionAnswer entity.
// If the UserQuestionAnswer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserQuestionAnswerMutation) OldQuestionID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuestionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuestionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionID: %w", err)
	}
	return oldValue.QuestionID, nil
}

// ResetQuestionID resets all changes to the "question_id" field.
func (m *UserQuestionAnswerMutation) ResetQuestionID() {
	m.question = nil
}

// SetSelectedOptionID sets the "selected_option_id" field.
func (m *UserQuestionAnswerMutation) SetSelectedOptionID(u uuid.UUID) {
	m.selected_option = &u
}

// SelectedOptionID returns the value of the "selected_option_id" field in the mutation.
func (m *UserQuestionAnswerMutation) SelectedOptionID() (r uuid.UUID, exists bool) {
	v := m.selected_option
	if v == nil {
		return
	}
	return *v, true
}

// OldSelectedOptionID returns the old "selected_option_id" field's value of the UserQuestionAnswer entity.
// If the UserQuestionAnswer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserQuestionAnswerMutation) OldSelectedOptionID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSelectedOptionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSelectedOptionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelectedOptionID: %w", err)
	}
	return oldValue.SelectedOptionID, nil
}

// ResetSelectedOptionID resets all changes to the "selected_option_id" field.
func (m *UserQuestionAnswerMutation) ResetSelectedOptionID() {
	m.selected_option = nil
}

// SetSessionID sets the "session_id" field.
func (m *UserQuestionAnswerMutation) SetSessionID(u uuid.UUID) {
	m.test_session = &u
}

// SessionID returns the value of the "session_id" field in the mutation.
func (m *UserQuestionAnswerMutation) SessionID() (r uuid.UUID, exists bool) {
	v := m.test_session
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionID returns the old "session_id" field's value of the UserQuestionAnswer entity.
// If the UserQuestionAnswer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserQuestionAnswerMutation) OldSessionID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionID: %w", err)
	}
	return oldValue.SessionID, nil
}

// ResetSessionID resets all changes to the "session_id" field.
func (m *UserQuestionAnswerMutation) ResetSessionID() {
	m.test_session = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserQuestionAnswerMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userquestionanswer.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserQuestionAnswerMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserQuestionAnswerMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserQuestionAnswerMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearQuestion clears the "question" edge to the Question entity.
func (m *UserQuestionAnswerMutation) ClearQuestion() {
	m.clearedquestion = true
	m.clearedFields[userquestionanswer.FieldQuestionID] = struct{}{}
}

// QuestionCleared reports if the "question" edge to the Question entity was cleared.
func (m *UserQuestionAnswerMutation) QuestionCleared() bool {
	return m.clearedquestion
}

// QuestionIDs returns the "question" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// QuestionID instead. It exists only for internal usage by the builders.
func (m *UserQuestionAnswerMutation) QuestionIDs() (ids []uuid.UUID) {
	if id := m.question; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetQuestion resets all changes to the "question" edge.
func (m *UserQuestionAnswerMutation) ResetQuestion() {
	m.question = nil
	m.clearedquestion = false
}

// ClearSelectedOption clears the "selected_option" edge to the QuestionOption entity.
func (m *UserQuestionAnswerMutation) ClearSelectedOption() {
	m.clearedselected_option = true
	m.clearedFields[userquestionanswer.FieldSelectedOptionID] = struct{}{}
}

// SelectedOptionCleared reports if the "selected_option" edge to the QuestionOption entity was cleared.
func (m *UserQuestionAnswerMutation) SelectedOptionCleared() bool {
	return m.clearedselected_option
}

// SelectedOptionIDs returns the "selected_option" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SelectedOptionID instead. It exists only for internal usage by the builders.
func (m *UserQuestionAnswerMutation) SelectedOptionIDs() (ids []uuid.UUID) {
	if id := m.selected_option; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSelectedOption resets all changes to the "selected_option" edge.
func (m *UserQuestionAnswerMutation) ResetSelectedOption() {
	m.selected_option = nil
	m.clearedselected_option = false
}

// SetTestSessionID sets the "test_session" edge to the TestSession entity by id.
func (m *UserQuestionAnswerMutation) SetTestSessionID(id uuid.UUID) {
	m.test_session = &id
}

// ClearTestSession clears the "test_session" edge to the TestSession entity.
func (m *UserQuestionAnswerMutation) ClearTestSession() {
	m.clearedtest_session = true
	m.clearedFields[userquestionanswer.FieldSessionID] = struct{}{}
}

// TestSessionCleared reports if the "test_session" edge to the TestSession entity was cleared.
func (m *UserQuestionAnswerMutation) TestSessionCleared() bool {
	return m.clearedtest_session
}

// TestSessionID returns the "test_session" edge ID in the mutation.
func (m *UserQuestionAnswerMutation) TestSessionID() (id uuid.UUID, exists bool) {
	if m.test_session != nil {
		return *m.test_session, true
	}
	return
}

// TestSessionIDs returns the "test_session" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TestSessionID instead. It exists only for internal usage by the builders.
func (m *UserQuestionAnswerMutation) TestSessionIDs() (ids []uuid.UUID) {
	if id := m.test_session; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTestSession resets all changes to the "test_session" edge.
func (m *UserQuestionAnswerMutation) ResetTestSession() {
	m.test_session = nil
	m.clearedtest_session = false
}

// Where appends a list predicates to the UserQuestionAnswerMutation builder.
func (m *UserQuestionAnswerMutation) Where(ps ...predicate.UserQuestionAnswer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserQuestionAnswerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserQuestionAnswerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserQuestionAnswer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserQuestionAnswerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserQuestionAnswerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserQuestionAnswer).
func (m *UserQuestionAnswerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserQuestionAnswerMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, userquestionanswer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userquestionanswer.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, userquestionanswer.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, userquestionanswer.FieldUserID)
	}
	if m.question != nil {
		fields = append(fields, userquestionanswer.FieldQuestionID)
	}
	if m.selected_option != nil {
		fields = append(fields, userquestionanswer.FieldSelectedOptionID)
	}
	if m.test_session != nil {
		fields = append(fields, userquestionanswer.FieldSessionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserQuestionAnswerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userquestionanswer.FieldCreatedAt:
		return m.CreatedAt()
	case userquestionanswer.FieldUpdatedAt:
		return m.UpdatedAt()
	case userquestionanswer.FieldDeletedAt:
		return m.DeletedAt()
	case userquestionanswer.FieldUserID:
		return m.UserID()
	case userquestionanswer.FieldQuestionID:
		return m.QuestionID()
	case userquestionanswer.FieldSelectedOptionID:
		return m.SelectedOptionID()
	case userquestionanswer.FieldSessionID:
		return m.SessionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserQuestionAnswerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userquestionanswer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userquestionanswer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userquestionanswer.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case userquestionanswer.FieldUserID:
		return m.OldUserID(ctx)
	case userquestionanswer.FieldQuestionID:
		return m.OldQuestionID(ctx)
	case userquestionanswer.FieldSelectedOptionID:
		return m.OldSelectedOptionID(ctx)
	case userquestionanswer.FieldSessionID:
		return m.OldSessionID(ctx)
	}
	return nil, fmt.Errorf("unknown UserQuestionAnswer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserQuestionAnswerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userquestionanswer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userquestionanswer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userquestionanswer.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case userquestionanswer.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userquestionanswer.FieldQuestionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionID(v)
		return nil
	case userquestionanswer.FieldSelectedOptionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelectedOptionID(v)
		return nil
	case userquestionanswer.FieldSessionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionID(v)
		return nil
	}
	return fmt.Errorf("unknown UserQuestionAnswer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserQuestionAnswerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserQuestionAnswerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserQuestionAnswerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserQuestionAnswer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserQuestionAnswerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userquestionanswer.FieldDeletedAt) {
		fields = append(fields, userquestionanswer.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserQuestionAnswerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserQuestionAnswerMutation) ClearField(name string) error {
	switch name {
	case userquestionanswer.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown UserQuestionAnswer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserQuestionAnswerMutation) ResetField(name string) error {
	switch name {
	case userquestionanswer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userquestionanswer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userquestionanswer.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case userquestionanswer.FieldUserID:
		m.ResetUserID()
		return nil
	case userquestionanswer.FieldQuestionID:
		m.ResetQuestionID()
		return nil
	case userquestionanswer.FieldSelectedOptionID:
		m.ResetSelectedOptionID()
		return nil
	case userquestionanswer.FieldSessionID:
		m.ResetSessionID()
		return nil
	}
	return fmt.Errorf("unknown UserQuestionAnswer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserQuestionAnswerMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, userquestionanswer.EdgeUser)
	}
	if m.question != nil {
		edges = append(edges, userquestionanswer.EdgeQuestion)
	}
	if m.selected_option != nil {
		edges = append(edges, userquestionanswer.EdgeSelectedOption)
	}
	if m.test_session != nil {
		edges = append(edges, userquestionanswer.EdgeTestSession)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserQuestionAnswerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userquestionanswer.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userquestionanswer.EdgeQuestion:
		if id := m.question; id != nil {
			return []ent.Value{*id}
		}
	case userquestionanswer.EdgeSelectedOption:
		if id := m.selected_option; id != nil {
			return []ent.Value{*id}
		}
	case userquestionanswer.EdgeTestSession:
		if id := m.test_session; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserQuestionAnswerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserQuestionAnswerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserQuestionAnswerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, userquestionanswer.EdgeUser)
	}
	if m.clearedquestion {
		edges = append(edges, userquestionanswer.EdgeQuestion)
	}
	if m.clearedselected_option {
		edges = append(edges, userquestionanswer.EdgeSelectedOption)
	}
	if m.clearedtest_session {
		edges = append(edges, userquestionanswer.EdgeTestSession)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserQuestionAnswerMutation) EdgeCleared(name string) bool {
	switch name {
	case userquestionanswer.EdgeUser:
		return m.cleareduser
	case userquestionanswer.EdgeQuestion:
		return m.clearedquestion
	case userquestionanswer.EdgeSelectedOption:
		return m.clearedselected_option
	case userquestionanswer.EdgeTestSession:
		return m.clearedtest_session
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserQuestionAnswerMutation) ClearEdge(name string) error {
	switch name {
	case userquestionanswer.EdgeUser:
		m.ClearUser()
		return nil
	case userquestionanswer.EdgeQuestion:
		m.ClearQuestion()
		return nil
	case userquestionanswer.EdgeSelectedOption:
		m.ClearSelectedOption()
		return nil
	case userquestionanswer.EdgeTestSession:
		m.ClearTestSession()
		return nil
	}
	return fmt.Errorf("unknown UserQuestionAnswer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserQuestionAnswerMutation) ResetEdge(name string) error {
	switch name {
	case userquestionanswer.EdgeUser:
		m.ResetUser()
		return nil
	case userquestionanswer.EdgeQuestion:
		m.ResetQuestion()
		return nil
	case userquestionanswer.EdgeSelectedOption:
		m.ResetSelectedOption()
		return nil
	case userquestionanswer.EdgeTestSession:
		m.ResetTestSession()
		return nil
	}
	return fmt.Errorf("unknown UserQuestionAnswer edge %s", name)
}

// UserRoleMutation represents an operation that mutates the UserRole nodes in the graph.
type UserRoleMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	clearedFields map[string]struct{}
	user          *uuid.UUID
	cleareduser   bool
	role          *uuid.UUID
	clearedrole   bool
	done          bool
	oldValue      func(context.Context) (*UserRole, error)
	predicates    []predicate.UserRole
}

var _ ent.Mutation = (*UserRoleMutation)(nil)

// userroleOption allows management of the mutation configuration using functional options.
type userroleOption func(*UserRoleMutation)

// newUserRoleMutation creates new mutation for the UserRole entity.
func newUserRoleMutation(c config, op Op, opts ...userroleOption) *UserRoleMutation {
	m := &UserRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeUserRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserRoleID sets the ID field of the mutation.
func withUserRoleID(id uuid.UUID) userroleOption {
	return func(m *UserRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *UserRole
		)
		m.oldValue = func(ctx context.Context) (*UserRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserRole sets the old UserRole of the mutation.
func withUserRole(node *UserRole) userroleOption {
	return func(m *UserRoleMutation) {
		m.oldValue = func(context.Context) (*UserRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserRole entities.
func (m *UserRoleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserRoleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserRoleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserRoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserRoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserRoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserRoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserRoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserRoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserRoleMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserRoleMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserRoleMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[userrole.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserRoleMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[userrole.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserRoleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, userrole.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *UserRoleMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserRoleMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserRoleMutation) ResetUserID() {
	m.user = nil
}

// SetRoleID sets the "role_id" field.
func (m *UserRoleMutation) SetRoleID(u uuid.UUID) {
	m.role = &u
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *UserRoleMutation) RoleID() (r uuid.UUID, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldRoleID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *UserRoleMutation) ResetRoleID() {
	m.role = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserRoleMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userrole.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserRoleMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserRoleMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserRoleMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearRole clears the "role" edge to the Role entity.
func (m *UserRoleMutation) ClearRole() {
	m.clearedrole = true
	m.clearedFields[userrole.FieldRoleID] = struct{}{}
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *UserRoleMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *UserRoleMutation) RoleIDs() (ids []uuid.UUID) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *UserRoleMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// Where appends a list predicates to the UserRoleMutation builder.
func (m *UserRoleMutation) Where(ps ...predicate.UserRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserRole).
func (m *UserRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserRoleMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, userrole.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userrole.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, userrole.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, userrole.FieldUserID)
	}
	if m.role != nil {
		fields = append(fields, userrole.FieldRoleID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userrole.FieldCreatedAt:
		return m.CreatedAt()
	case userrole.FieldUpdatedAt:
		return m.UpdatedAt()
	case userrole.FieldDeletedAt:
		return m.DeletedAt()
	case userrole.FieldUserID:
		return m.UserID()
	case userrole.FieldRoleID:
		return m.RoleID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userrole.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userrole.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userrole.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case userrole.FieldUserID:
		return m.OldUserID(ctx)
	case userrole.FieldRoleID:
		return m.OldRoleID(ctx)
	}
	return nil, fmt.Errorf("unknown UserRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userrole.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userrole.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userrole.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case userrole.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userrole.FieldRoleID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	}
	return fmt.Errorf("unknown UserRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserRoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserRoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserRoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userrole.FieldDeletedAt) {
		fields = append(fields, userrole.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserRoleMutation) ClearField(name string) error {
	switch name {
	case userrole.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown UserRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserRoleMutation) ResetField(name string) error {
	switch name {
	case userrole.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userrole.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userrole.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case userrole.FieldUserID:
		m.ResetUserID()
		return nil
	case userrole.FieldRoleID:
		m.ResetRoleID()
		return nil
	}
	return fmt.Errorf("unknown UserRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userrole.EdgeUser)
	}
	if m.role != nil {
		edges = append(edges, userrole.EdgeRole)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userrole.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userrole.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserRoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userrole.EdgeUser)
	}
	if m.clearedrole {
		edges = append(edges, userrole.EdgeRole)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case userrole.EdgeUser:
		return m.cleareduser
	case userrole.EdgeRole:
		return m.clearedrole
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserRoleMutation) ClearEdge(name string) error {
	switch name {
	case userrole.EdgeUser:
		m.ClearUser()
		return nil
	case userrole.EdgeRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown UserRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserRoleMutation) ResetEdge(name string) error {
	switch name {
	case userrole.EdgeUser:
		m.ResetUser()
		return nil
	case userrole.EdgeRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown UserRole edge %s", name)
}

// VideoMutation represents an operation that mutates the Video nodes in the graph.
type VideoMutation struct {
	config
	op                                     Op
	typ                                    string
	id                                     *uuid.UUID
	created_at                             *time.Time
	updated_at                             *time.Time
	deleted_at                             *time.Time
	title                                  *string
	description                            *string
	duration                               *int
	addduration                            *int
	clearedFields                          map[string]struct{}
	course_section                         *uuid.UUID
	clearedcourse_section                  bool
	media                                  *uuid.UUID
	clearedmedia                           bool
	course                                 *uuid.UUID
	clearedcourse                          bool
	video_question_timestamps_video        map[uuid.UUID]struct{}
	removedvideo_question_timestamps_video map[uuid.UUID]struct{}
	clearedvideo_question_timestamps_video bool
	done                                   bool
	oldValue                               func(context.Context) (*Video, error)
	predicates                             []predicate.Video
}

var _ ent.Mutation = (*VideoMutation)(nil)

// videoOption allows management of the mutation configuration using functional options.
type videoOption func(*VideoMutation)

// newVideoMutation creates new mutation for the Video entity.
func newVideoMutation(c config, op Op, opts ...videoOption) *VideoMutation {
	m := &VideoMutation{
		config:        c,
		op:            op,
		typ:           TypeVideo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVideoID sets the ID field of the mutation.
func withVideoID(id uuid.UUID) videoOption {
	return func(m *VideoMutation) {
		var (
			err   error
			once  sync.Once
			value *Video
		)
		m.oldValue = func(ctx context.Context) (*Video, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Video.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVideo sets the old Video of the mutation.
func withVideo(node *Video) videoOption {
	return func(m *VideoMutation) {
		m.oldValue = func(context.Context) (*Video, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VideoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VideoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Video entities.
func (m *VideoMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VideoMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VideoMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Video.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VideoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VideoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VideoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VideoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VideoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VideoMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *VideoMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *VideoMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *VideoMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[video.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *VideoMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[video.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *VideoMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, video.FieldDeletedAt)
}

// SetSectionID sets the "section_id" field.
func (m *VideoMutation) SetSectionID(u uuid.UUID) {
	m.course_section = &u
}

// SectionID returns the value of the "section_id" field in the mutation.
func (m *VideoMutation) SectionID() (r uuid.UUID, exists bool) {
	v := m.course_section
	if v == nil {
		return
	}
	return *v, true
}

// OldSectionID returns the old "section_id" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldSectionID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSectionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSectionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSectionID: %w", err)
	}
	return oldValue.SectionID, nil
}

// ResetSectionID resets all changes to the "section_id" field.
func (m *VideoMutation) ResetSectionID() {
	m.course_section = nil
}

// SetTitle sets the "title" field.
func (m *VideoMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *VideoMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *VideoMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *VideoMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *VideoMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *VideoMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[video.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *VideoMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[video.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *VideoMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, video.FieldDescription)
}

// SetMediaID sets the "media_id" field.
func (m *VideoMutation) SetMediaID(u uuid.UUID) {
	m.media = &u
}

// MediaID returns the value of the "media_id" field in the mutation.
func (m *VideoMutation) MediaID() (r uuid.UUID, exists bool) {
	v := m.media
	if v == nil {
		return
	}
	return *v, true
}

// OldMediaID returns the old "media_id" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldMediaID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMediaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMediaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMediaID: %w", err)
	}
	return oldValue.MediaID, nil
}

// ResetMediaID resets all changes to the "media_id" field.
func (m *VideoMutation) ResetMediaID() {
	m.media = nil
}

// SetCourseID sets the "course_id" field.
func (m *VideoMutation) SetCourseID(u uuid.UUID) {
	m.course = &u
}

// CourseID returns the value of the "course_id" field in the mutation.
func (m *VideoMutation) CourseID() (r uuid.UUID, exists bool) {
	v := m.course
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseID returns the old "course_id" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldCourseID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCourseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCourseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseID: %w", err)
	}
	return oldValue.CourseID, nil
}

// ResetCourseID resets all changes to the "course_id" field.
func (m *VideoMutation) ResetCourseID() {
	m.course = nil
}

// SetDuration sets the "duration" field.
func (m *VideoMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *VideoMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldDuration(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *VideoMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *VideoMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ClearDuration clears the value of the "duration" field.
func (m *VideoMutation) ClearDuration() {
	m.duration = nil
	m.addduration = nil
	m.clearedFields[video.FieldDuration] = struct{}{}
}

// DurationCleared returns if the "duration" field was cleared in this mutation.
func (m *VideoMutation) DurationCleared() bool {
	_, ok := m.clearedFields[video.FieldDuration]
	return ok
}

// ResetDuration resets all changes to the "duration" field.
func (m *VideoMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
	delete(m.clearedFields, video.FieldDuration)
}

// SetCourseSectionID sets the "course_section" edge to the CourseSection entity by id.
func (m *VideoMutation) SetCourseSectionID(id uuid.UUID) {
	m.course_section = &id
}

// ClearCourseSection clears the "course_section" edge to the CourseSection entity.
func (m *VideoMutation) ClearCourseSection() {
	m.clearedcourse_section = true
	m.clearedFields[video.FieldSectionID] = struct{}{}
}

// CourseSectionCleared reports if the "course_section" edge to the CourseSection entity was cleared.
func (m *VideoMutation) CourseSectionCleared() bool {
	return m.clearedcourse_section
}

// CourseSectionID returns the "course_section" edge ID in the mutation.
func (m *VideoMutation) CourseSectionID() (id uuid.UUID, exists bool) {
	if m.course_section != nil {
		return *m.course_section, true
	}
	return
}

// CourseSectionIDs returns the "course_section" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CourseSectionID instead. It exists only for internal usage by the builders.
func (m *VideoMutation) CourseSectionIDs() (ids []uuid.UUID) {
	if id := m.course_section; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourseSection resets all changes to the "course_section" edge.
func (m *VideoMutation) ResetCourseSection() {
	m.course_section = nil
	m.clearedcourse_section = false
}

// ClearMedia clears the "media" edge to the Media entity.
func (m *VideoMutation) ClearMedia() {
	m.clearedmedia = true
	m.clearedFields[video.FieldMediaID] = struct{}{}
}

// MediaCleared reports if the "media" edge to the Media entity was cleared.
func (m *VideoMutation) MediaCleared() bool {
	return m.clearedmedia
}

// MediaIDs returns the "media" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MediaID instead. It exists only for internal usage by the builders.
func (m *VideoMutation) MediaIDs() (ids []uuid.UUID) {
	if id := m.media; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMedia resets all changes to the "media" edge.
func (m *VideoMutation) ResetMedia() {
	m.media = nil
	m.clearedmedia = false
}

// ClearCourse clears the "course" edge to the Course entity.
func (m *VideoMutation) ClearCourse() {
	m.clearedcourse = true
	m.clearedFields[video.FieldCourseID] = struct{}{}
}

// CourseCleared reports if the "course" edge to the Course entity was cleared.
func (m *VideoMutation) CourseCleared() bool {
	return m.clearedcourse
}

// CourseIDs returns the "course" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CourseID instead. It exists only for internal usage by the builders.
func (m *VideoMutation) CourseIDs() (ids []uuid.UUID) {
	if id := m.course; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourse resets all changes to the "course" edge.
func (m *VideoMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
}

// AddVideoQuestionTimestampsVideoIDs adds the "video_question_timestamps_video" edge to the VideoQuestionTimestamp entity by ids.
func (m *VideoMutation) AddVideoQuestionTimestampsVideoIDs(ids ...uuid.UUID) {
	if m.video_question_timestamps_video == nil {
		m.video_question_timestamps_video = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.video_question_timestamps_video[ids[i]] = struct{}{}
	}
}

// ClearVideoQuestionTimestampsVideo clears the "video_question_timestamps_video" edge to the VideoQuestionTimestamp entity.
func (m *VideoMutation) ClearVideoQuestionTimestampsVideo() {
	m.clearedvideo_question_timestamps_video = true
}

// VideoQuestionTimestampsVideoCleared reports if the "video_question_timestamps_video" edge to the VideoQuestionTimestamp entity was cleared.
func (m *VideoMutation) VideoQuestionTimestampsVideoCleared() bool {
	return m.clearedvideo_question_timestamps_video
}

// RemoveVideoQuestionTimestampsVideoIDs removes the "video_question_timestamps_video" edge to the VideoQuestionTimestamp entity by IDs.
func (m *VideoMutation) RemoveVideoQuestionTimestampsVideoIDs(ids ...uuid.UUID) {
	if m.removedvideo_question_timestamps_video == nil {
		m.removedvideo_question_timestamps_video = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.video_question_timestamps_video, ids[i])
		m.removedvideo_question_timestamps_video[ids[i]] = struct{}{}
	}
}

// RemovedVideoQuestionTimestampsVideo returns the removed IDs of the "video_question_timestamps_video" edge to the VideoQuestionTimestamp entity.
func (m *VideoMutation) RemovedVideoQuestionTimestampsVideoIDs() (ids []uuid.UUID) {
	for id := range m.removedvideo_question_timestamps_video {
		ids = append(ids, id)
	}
	return
}

// VideoQuestionTimestampsVideoIDs returns the "video_question_timestamps_video" edge IDs in the mutation.
func (m *VideoMutation) VideoQuestionTimestampsVideoIDs() (ids []uuid.UUID) {
	for id := range m.video_question_timestamps_video {
		ids = append(ids, id)
	}
	return
}

// ResetVideoQuestionTimestampsVideo resets all changes to the "video_question_timestamps_video" edge.
func (m *VideoMutation) ResetVideoQuestionTimestampsVideo() {
	m.video_question_timestamps_video = nil
	m.clearedvideo_question_timestamps_video = false
	m.removedvideo_question_timestamps_video = nil
}

// Where appends a list predicates to the VideoMutation builder.
func (m *VideoMutation) Where(ps ...predicate.Video) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VideoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VideoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Video, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VideoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VideoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Video).
func (m *VideoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VideoMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, video.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, video.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, video.FieldDeletedAt)
	}
	if m.course_section != nil {
		fields = append(fields, video.FieldSectionID)
	}
	if m.title != nil {
		fields = append(fields, video.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, video.FieldDescription)
	}
	if m.media != nil {
		fields = append(fields, video.FieldMediaID)
	}
	if m.course != nil {
		fields = append(fields, video.FieldCourseID)
	}
	if m.duration != nil {
		fields = append(fields, video.FieldDuration)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VideoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case video.FieldCreatedAt:
		return m.CreatedAt()
	case video.FieldUpdatedAt:
		return m.UpdatedAt()
	case video.FieldDeletedAt:
		return m.DeletedAt()
	case video.FieldSectionID:
		return m.SectionID()
	case video.FieldTitle:
		return m.Title()
	case video.FieldDescription:
		return m.Description()
	case video.FieldMediaID:
		return m.MediaID()
	case video.FieldCourseID:
		return m.CourseID()
	case video.FieldDuration:
		return m.Duration()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VideoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case video.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case video.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case video.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case video.FieldSectionID:
		return m.OldSectionID(ctx)
	case video.FieldTitle:
		return m.OldTitle(ctx)
	case video.FieldDescription:
		return m.OldDescription(ctx)
	case video.FieldMediaID:
		return m.OldMediaID(ctx)
	case video.FieldCourseID:
		return m.OldCourseID(ctx)
	case video.FieldDuration:
		return m.OldDuration(ctx)
	}
	return nil, fmt.Errorf("unknown Video field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VideoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case video.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case video.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case video.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case video.FieldSectionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSectionID(v)
		return nil
	case video.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case video.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case video.FieldMediaID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMediaID(v)
		return nil
	case video.FieldCourseID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseID(v)
		return nil
	case video.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	}
	return fmt.Errorf("unknown Video field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VideoMutation) AddedFields() []string {
	var fields []string
	if m.addduration != nil {
		fields = append(fields, video.FieldDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VideoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case video.FieldDuration:
		return m.AddedDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VideoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case video.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	}
	return fmt.Errorf("unknown Video numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VideoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(video.FieldDeletedAt) {
		fields = append(fields, video.FieldDeletedAt)
	}
	if m.FieldCleared(video.FieldDescription) {
		fields = append(fields, video.FieldDescription)
	}
	if m.FieldCleared(video.FieldDuration) {
		fields = append(fields, video.FieldDuration)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VideoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VideoMutation) ClearField(name string) error {
	switch name {
	case video.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case video.FieldDescription:
		m.ClearDescription()
		return nil
	case video.FieldDuration:
		m.ClearDuration()
		return nil
	}
	return fmt.Errorf("unknown Video nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VideoMutation) ResetField(name string) error {
	switch name {
	case video.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case video.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case video.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case video.FieldSectionID:
		m.ResetSectionID()
		return nil
	case video.FieldTitle:
		m.ResetTitle()
		return nil
	case video.FieldDescription:
		m.ResetDescription()
		return nil
	case video.FieldMediaID:
		m.ResetMediaID()
		return nil
	case video.FieldCourseID:
		m.ResetCourseID()
		return nil
	case video.FieldDuration:
		m.ResetDuration()
		return nil
	}
	return fmt.Errorf("unknown Video field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VideoMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.course_section != nil {
		edges = append(edges, video.EdgeCourseSection)
	}
	if m.media != nil {
		edges = append(edges, video.EdgeMedia)
	}
	if m.course != nil {
		edges = append(edges, video.EdgeCourse)
	}
	if m.video_question_timestamps_video != nil {
		edges = append(edges, video.EdgeVideoQuestionTimestampsVideo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VideoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case video.EdgeCourseSection:
		if id := m.course_section; id != nil {
			return []ent.Value{*id}
		}
	case video.EdgeMedia:
		if id := m.media; id != nil {
			return []ent.Value{*id}
		}
	case video.EdgeCourse:
		if id := m.course; id != nil {
			return []ent.Value{*id}
		}
	case video.EdgeVideoQuestionTimestampsVideo:
		ids := make([]ent.Value, 0, len(m.video_question_timestamps_video))
		for id := range m.video_question_timestamps_video {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VideoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedvideo_question_timestamps_video != nil {
		edges = append(edges, video.EdgeVideoQuestionTimestampsVideo)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VideoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case video.EdgeVideoQuestionTimestampsVideo:
		ids := make([]ent.Value, 0, len(m.removedvideo_question_timestamps_video))
		for id := range m.removedvideo_question_timestamps_video {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VideoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcourse_section {
		edges = append(edges, video.EdgeCourseSection)
	}
	if m.clearedmedia {
		edges = append(edges, video.EdgeMedia)
	}
	if m.clearedcourse {
		edges = append(edges, video.EdgeCourse)
	}
	if m.clearedvideo_question_timestamps_video {
		edges = append(edges, video.EdgeVideoQuestionTimestampsVideo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VideoMutation) EdgeCleared(name string) bool {
	switch name {
	case video.EdgeCourseSection:
		return m.clearedcourse_section
	case video.EdgeMedia:
		return m.clearedmedia
	case video.EdgeCourse:
		return m.clearedcourse
	case video.EdgeVideoQuestionTimestampsVideo:
		return m.clearedvideo_question_timestamps_video
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VideoMutation) ClearEdge(name string) error {
	switch name {
	case video.EdgeCourseSection:
		m.ClearCourseSection()
		return nil
	case video.EdgeMedia:
		m.ClearMedia()
		return nil
	case video.EdgeCourse:
		m.ClearCourse()
		return nil
	}
	return fmt.Errorf("unknown Video unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VideoMutation) ResetEdge(name string) error {
	switch name {
	case video.EdgeCourseSection:
		m.ResetCourseSection()
		return nil
	case video.EdgeMedia:
		m.ResetMedia()
		return nil
	case video.EdgeCourse:
		m.ResetCourse()
		return nil
	case video.EdgeVideoQuestionTimestampsVideo:
		m.ResetVideoQuestionTimestampsVideo()
		return nil
	}
	return fmt.Errorf("unknown Video edge %s", name)
}

// VideoQuestionTimestampMutation represents an operation that mutates the VideoQuestionTimestamp nodes in the graph.
type VideoQuestionTimestampMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	timestamp       *int
	addtimestamp    *int
	clearedFields   map[string]struct{}
	video           *uuid.UUID
	clearedvideo    bool
	question        *uuid.UUID
	clearedquestion bool
	done            bool
	oldValue        func(context.Context) (*VideoQuestionTimestamp, error)
	predicates      []predicate.VideoQuestionTimestamp
}

var _ ent.Mutation = (*VideoQuestionTimestampMutation)(nil)

// videoquestiontimestampOption allows management of the mutation configuration using functional options.
type videoquestiontimestampOption func(*VideoQuestionTimestampMutation)

// newVideoQuestionTimestampMutation creates new mutation for the VideoQuestionTimestamp entity.
func newVideoQuestionTimestampMutation(c config, op Op, opts ...videoquestiontimestampOption) *VideoQuestionTimestampMutation {
	m := &VideoQuestionTimestampMutation{
		config:        c,
		op:            op,
		typ:           TypeVideoQuestionTimestamp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVideoQuestionTimestampID sets the ID field of the mutation.
func withVideoQuestionTimestampID(id uuid.UUID) videoquestiontimestampOption {
	return func(m *VideoQuestionTimestampMutation) {
		var (
			err   error
			once  sync.Once
			value *VideoQuestionTimestamp
		)
		m.oldValue = func(ctx context.Context) (*VideoQuestionTimestamp, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VideoQuestionTimestamp.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVideoQuestionTimestamp sets the old VideoQuestionTimestamp of the mutation.
func withVideoQuestionTimestamp(node *VideoQuestionTimestamp) videoquestiontimestampOption {
	return func(m *VideoQuestionTimestampMutation) {
		m.oldValue = func(context.Context) (*VideoQuestionTimestamp, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VideoQuestionTimestampMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VideoQuestionTimestampMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VideoQuestionTimestamp entities.
func (m *VideoQuestionTimestampMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VideoQuestionTimestampMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VideoQuestionTimestampMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VideoQuestionTimestamp.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VideoQuestionTimestampMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VideoQuestionTimestampMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VideoQuestionTimestamp entity.
// If the VideoQuestionTimestamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoQuestionTimestampMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VideoQuestionTimestampMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VideoQuestionTimestampMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VideoQuestionTimestampMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VideoQuestionTimestamp entity.
// If the VideoQuestionTimestamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoQuestionTimestampMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VideoQuestionTimestampMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *VideoQuestionTimestampMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *VideoQuestionTimestampMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the VideoQuestionTimestamp entity.
// If the VideoQuestionTimestamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoQuestionTimestampMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *VideoQuestionTimestampMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[videoquestiontimestamp.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *VideoQuestionTimestampMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[videoquestiontimestamp.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *VideoQuestionTimestampMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, videoquestiontimestamp.FieldDeletedAt)
}

// SetVideoID sets the "video_id" field.
func (m *VideoQuestionTimestampMutation) SetVideoID(u uuid.UUID) {
	m.video = &u
}

// VideoID returns the value of the "video_id" field in the mutation.
func (m *VideoQuestionTimestampMutation) VideoID() (r uuid.UUID, exists bool) {
	v := m.video
	if v == nil {
		return
	}
	return *v, true
}

// OldVideoID returns the old "video_id" field's value of the VideoQuestionTimestamp entity.
// If the VideoQuestionTimestamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoQuestionTimestampMutation) OldVideoID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVideoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVideoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideoID: %w", err)
	}
	return oldValue.VideoID, nil
}

// ResetVideoID resets all changes to the "video_id" field.
func (m *VideoQuestionTimestampMutation) ResetVideoID() {
	m.video = nil
}

// SetQuestionID sets the "question_id" field.
func (m *VideoQuestionTimestampMutation) SetQuestionID(u uuid.UUID) {
	m.question = &u
}

// QuestionID returns the value of the "question_id" field in the mutation.
func (m *VideoQuestionTimestampMutation) QuestionID() (r uuid.UUID, exists bool) {
	v := m.question
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionID returns the old "question_id" field's value of the VideoQuestionTimestamp entity.
// If the VideoQuestionTimestamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoQuestionTimestampMutation) OldQuestionID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuestionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuestionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionID: %w", err)
	}
	return oldValue.QuestionID, nil
}

// ResetQuestionID resets all changes to the "question_id" field.
func (m *VideoQuestionTimestampMutation) ResetQuestionID() {
	m.question = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *VideoQuestionTimestampMutation) SetTimestamp(i int) {
	m.timestamp = &i
	m.addtimestamp = nil
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *VideoQuestionTimestampMutation) Timestamp() (r int, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the VideoQuestionTimestamp entity.
// If the VideoQuestionTimestamp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoQuestionTimestampMutation) OldTimestamp(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// AddTimestamp adds i to the "timestamp" field.
func (m *VideoQuestionTimestampMutation) AddTimestamp(i int) {
	if m.addtimestamp != nil {
		*m.addtimestamp += i
	} else {
		m.addtimestamp = &i
	}
}

// AddedTimestamp returns the value that was added to the "timestamp" field in this mutation.
func (m *VideoQuestionTimestampMutation) AddedTimestamp() (r int, exists bool) {
	v := m.addtimestamp
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *VideoQuestionTimestampMutation) ResetTimestamp() {
	m.timestamp = nil
	m.addtimestamp = nil
}

// ClearVideo clears the "video" edge to the Video entity.
func (m *VideoQuestionTimestampMutation) ClearVideo() {
	m.clearedvideo = true
	m.clearedFields[videoquestiontimestamp.FieldVideoID] = struct{}{}
}

// VideoCleared reports if the "video" edge to the Video entity was cleared.
func (m *VideoQuestionTimestampMutation) VideoCleared() bool {
	return m.clearedvideo
}

// VideoIDs returns the "video" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VideoID instead. It exists only for internal usage by the builders.
func (m *VideoQuestionTimestampMutation) VideoIDs() (ids []uuid.UUID) {
	if id := m.video; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVideo resets all changes to the "video" edge.
func (m *VideoQuestionTimestampMutation) ResetVideo() {
	m.video = nil
	m.clearedvideo = false
}

// ClearQuestion clears the "question" edge to the Question entity.
func (m *VideoQuestionTimestampMutation) ClearQuestion() {
	m.clearedquestion = true
	m.clearedFields[videoquestiontimestamp.FieldQuestionID] = struct{}{}
}

// QuestionCleared reports if the "question" edge to the Question entity was cleared.
func (m *VideoQuestionTimestampMutation) QuestionCleared() bool {
	return m.clearedquestion
}

// QuestionIDs returns the "question" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// QuestionID instead. It exists only for internal usage by the builders.
func (m *VideoQuestionTimestampMutation) QuestionIDs() (ids []uuid.UUID) {
	if id := m.question; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetQuestion resets all changes to the "question" edge.
func (m *VideoQuestionTimestampMutation) ResetQuestion() {
	m.question = nil
	m.clearedquestion = false
}

// Where appends a list predicates to the VideoQuestionTimestampMutation builder.
func (m *VideoQuestionTimestampMutation) Where(ps ...predicate.VideoQuestionTimestamp) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VideoQuestionTimestampMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VideoQuestionTimestampMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VideoQuestionTimestamp, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VideoQuestionTimestampMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VideoQuestionTimestampMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VideoQuestionTimestamp).
func (m *VideoQuestionTimestampMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VideoQuestionTimestampMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, videoquestiontimestamp.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, videoquestiontimestamp.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, videoquestiontimestamp.FieldDeletedAt)
	}
	if m.video != nil {
		fields = append(fields, videoquestiontimestamp.FieldVideoID)
	}
	if m.question != nil {
		fields = append(fields, videoquestiontimestamp.FieldQuestionID)
	}
	if m.timestamp != nil {
		fields = append(fields, videoquestiontimestamp.FieldTimestamp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VideoQuestionTimestampMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case videoquestiontimestamp.FieldCreatedAt:
		return m.CreatedAt()
	case videoquestiontimestamp.FieldUpdatedAt:
		return m.UpdatedAt()
	case videoquestiontimestamp.FieldDeletedAt:
		return m.DeletedAt()
	case videoquestiontimestamp.FieldVideoID:
		return m.VideoID()
	case videoquestiontimestamp.FieldQuestionID:
		return m.QuestionID()
	case videoquestiontimestamp.FieldTimestamp:
		return m.Timestamp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VideoQuestionTimestampMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case videoquestiontimestamp.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case videoquestiontimestamp.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case videoquestiontimestamp.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case videoquestiontimestamp.FieldVideoID:
		return m.OldVideoID(ctx)
	case videoquestiontimestamp.FieldQuestionID:
		return m.OldQuestionID(ctx)
	case videoquestiontimestamp.FieldTimestamp:
		return m.OldTimestamp(ctx)
	}
	return nil, fmt.Errorf("unknown VideoQuestionTimestamp field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VideoQuestionTimestampMutation) SetField(name string, value ent.Value) error {
	switch name {
	case videoquestiontimestamp.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case videoquestiontimestamp.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case videoquestiontimestamp.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case videoquestiontimestamp.FieldVideoID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideoID(v)
		return nil
	case videoquestiontimestamp.FieldQuestionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionID(v)
		return nil
	case videoquestiontimestamp.FieldTimestamp:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown VideoQuestionTimestamp field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VideoQuestionTimestampMutation) AddedFields() []string {
	var fields []string
	if m.addtimestamp != nil {
		fields = append(fields, videoquestiontimestamp.FieldTimestamp)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VideoQuestionTimestampMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case videoquestiontimestamp.FieldTimestamp:
		return m.AddedTimestamp()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VideoQuestionTimestampMutation) AddField(name string, value ent.Value) error {
	switch name {
	case videoquestiontimestamp.FieldTimestamp:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown VideoQuestionTimestamp numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VideoQuestionTimestampMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(videoquestiontimestamp.FieldDeletedAt) {
		fields = append(fields, videoquestiontimestamp.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VideoQuestionTimestampMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VideoQuestionTimestampMutation) ClearField(name string) error {
	switch name {
	case videoquestiontimestamp.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown VideoQuestionTimestamp nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VideoQuestionTimestampMutation) ResetField(name string) error {
	switch name {
	case videoquestiontimestamp.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case videoquestiontimestamp.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case videoquestiontimestamp.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case videoquestiontimestamp.FieldVideoID:
		m.ResetVideoID()
		return nil
	case videoquestiontimestamp.FieldQuestionID:
		m.ResetQuestionID()
		return nil
	case videoquestiontimestamp.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	}
	return fmt.Errorf("unknown VideoQuestionTimestamp field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VideoQuestionTimestampMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.video != nil {
		edges = append(edges, videoquestiontimestamp.EdgeVideo)
	}
	if m.question != nil {
		edges = append(edges, videoquestiontimestamp.EdgeQuestion)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VideoQuestionTimestampMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case videoquestiontimestamp.EdgeVideo:
		if id := m.video; id != nil {
			return []ent.Value{*id}
		}
	case videoquestiontimestamp.EdgeQuestion:
		if id := m.question; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VideoQuestionTimestampMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VideoQuestionTimestampMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VideoQuestionTimestampMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedvideo {
		edges = append(edges, videoquestiontimestamp.EdgeVideo)
	}
	if m.clearedquestion {
		edges = append(edges, videoquestiontimestamp.EdgeQuestion)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VideoQuestionTimestampMutation) EdgeCleared(name string) bool {
	switch name {
	case videoquestiontimestamp.EdgeVideo:
		return m.clearedvideo
	case videoquestiontimestamp.EdgeQuestion:
		return m.clearedquestion
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VideoQuestionTimestampMutation) ClearEdge(name string) error {
	switch name {
	case videoquestiontimestamp.EdgeVideo:
		m.ClearVideo()
		return nil
	case videoquestiontimestamp.EdgeQuestion:
		m.ClearQuestion()
		return nil
	}
	return fmt.Errorf("unknown VideoQuestionTimestamp unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VideoQuestionTimestampMutation) ResetEdge(name string) error {
	switch name {
	case videoquestiontimestamp.EdgeVideo:
		m.ResetVideo()
		return nil
	case videoquestiontimestamp.EdgeQuestion:
		m.ResetQuestion()
		return nil
	}
	return fmt.Errorf("unknown VideoQuestionTimestamp edge %s", name)
}
