// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"template/internal/ent/migrate"

	"template/internal/ent/course"
	"template/internal/ent/coursesection"
	"template/internal/ent/media"
	"template/internal/ent/permission"
	"template/internal/ent/question"
	"template/internal/ent/questioncollection"
	"template/internal/ent/questionoption"
	"template/internal/ent/role"
	"template/internal/ent/test"
	"template/internal/ent/testignorequestion"
	"template/internal/ent/testquestionanswer"
	"template/internal/ent/testquestioncount"
	"template/internal/ent/testquestionpoint"
	"template/internal/ent/testsession"
	"template/internal/ent/todo"
	"template/internal/ent/user"
	"template/internal/ent/video"
	"template/internal/ent/videoquestiontimestamp"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/google/uuid"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Course is the client for interacting with the Course builders.
	Course *CourseClient
	// CourseSection is the client for interacting with the CourseSection builders.
	CourseSection *CourseSectionClient
	// Media is the client for interacting with the Media builders.
	Media *MediaClient
	// Permission is the client for interacting with the Permission builders.
	Permission *PermissionClient
	// Question is the client for interacting with the Question builders.
	Question *QuestionClient
	// QuestionCollection is the client for interacting with the QuestionCollection builders.
	QuestionCollection *QuestionCollectionClient
	// QuestionOption is the client for interacting with the QuestionOption builders.
	QuestionOption *QuestionOptionClient
	// Role is the client for interacting with the Role builders.
	Role *RoleClient
	// Test is the client for interacting with the Test builders.
	Test *TestClient
	// TestIgnoreQuestion is the client for interacting with the TestIgnoreQuestion builders.
	TestIgnoreQuestion *TestIgnoreQuestionClient
	// TestQuestionAnswer is the client for interacting with the TestQuestionAnswer builders.
	TestQuestionAnswer *TestQuestionAnswerClient
	// TestQuestionCount is the client for interacting with the TestQuestionCount builders.
	TestQuestionCount *TestQuestionCountClient
	// TestQuestionPoint is the client for interacting with the TestQuestionPoint builders.
	TestQuestionPoint *TestQuestionPointClient
	// TestSession is the client for interacting with the TestSession builders.
	TestSession *TestSessionClient
	// Todo is the client for interacting with the Todo builders.
	Todo *TodoClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// Video is the client for interacting with the Video builders.
	Video *VideoClient
	// VideoQuestionTimestamp is the client for interacting with the VideoQuestionTimestamp builders.
	VideoQuestionTimestamp *VideoQuestionTimestampClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Course = NewCourseClient(c.config)
	c.CourseSection = NewCourseSectionClient(c.config)
	c.Media = NewMediaClient(c.config)
	c.Permission = NewPermissionClient(c.config)
	c.Question = NewQuestionClient(c.config)
	c.QuestionCollection = NewQuestionCollectionClient(c.config)
	c.QuestionOption = NewQuestionOptionClient(c.config)
	c.Role = NewRoleClient(c.config)
	c.Test = NewTestClient(c.config)
	c.TestIgnoreQuestion = NewTestIgnoreQuestionClient(c.config)
	c.TestQuestionAnswer = NewTestQuestionAnswerClient(c.config)
	c.TestQuestionCount = NewTestQuestionCountClient(c.config)
	c.TestQuestionPoint = NewTestQuestionPointClient(c.config)
	c.TestSession = NewTestSessionClient(c.config)
	c.Todo = NewTodoClient(c.config)
	c.User = NewUserClient(c.config)
	c.Video = NewVideoClient(c.config)
	c.VideoQuestionTimestamp = NewVideoQuestionTimestampClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                    ctx,
		config:                 cfg,
		Course:                 NewCourseClient(cfg),
		CourseSection:          NewCourseSectionClient(cfg),
		Media:                  NewMediaClient(cfg),
		Permission:             NewPermissionClient(cfg),
		Question:               NewQuestionClient(cfg),
		QuestionCollection:     NewQuestionCollectionClient(cfg),
		QuestionOption:         NewQuestionOptionClient(cfg),
		Role:                   NewRoleClient(cfg),
		Test:                   NewTestClient(cfg),
		TestIgnoreQuestion:     NewTestIgnoreQuestionClient(cfg),
		TestQuestionAnswer:     NewTestQuestionAnswerClient(cfg),
		TestQuestionCount:      NewTestQuestionCountClient(cfg),
		TestQuestionPoint:      NewTestQuestionPointClient(cfg),
		TestSession:            NewTestSessionClient(cfg),
		Todo:                   NewTodoClient(cfg),
		User:                   NewUserClient(cfg),
		Video:                  NewVideoClient(cfg),
		VideoQuestionTimestamp: NewVideoQuestionTimestampClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                    ctx,
		config:                 cfg,
		Course:                 NewCourseClient(cfg),
		CourseSection:          NewCourseSectionClient(cfg),
		Media:                  NewMediaClient(cfg),
		Permission:             NewPermissionClient(cfg),
		Question:               NewQuestionClient(cfg),
		QuestionCollection:     NewQuestionCollectionClient(cfg),
		QuestionOption:         NewQuestionOptionClient(cfg),
		Role:                   NewRoleClient(cfg),
		Test:                   NewTestClient(cfg),
		TestIgnoreQuestion:     NewTestIgnoreQuestionClient(cfg),
		TestQuestionAnswer:     NewTestQuestionAnswerClient(cfg),
		TestQuestionCount:      NewTestQuestionCountClient(cfg),
		TestQuestionPoint:      NewTestQuestionPointClient(cfg),
		TestSession:            NewTestSessionClient(cfg),
		Todo:                   NewTodoClient(cfg),
		User:                   NewUserClient(cfg),
		Video:                  NewVideoClient(cfg),
		VideoQuestionTimestamp: NewVideoQuestionTimestampClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Course.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Course, c.CourseSection, c.Media, c.Permission, c.Question,
		c.QuestionCollection, c.QuestionOption, c.Role, c.Test, c.TestIgnoreQuestion,
		c.TestQuestionAnswer, c.TestQuestionCount, c.TestQuestionPoint, c.TestSession,
		c.Todo, c.User, c.Video, c.VideoQuestionTimestamp,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Course, c.CourseSection, c.Media, c.Permission, c.Question,
		c.QuestionCollection, c.QuestionOption, c.Role, c.Test, c.TestIgnoreQuestion,
		c.TestQuestionAnswer, c.TestQuestionCount, c.TestQuestionPoint, c.TestSession,
		c.Todo, c.User, c.Video, c.VideoQuestionTimestamp,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *CourseMutation:
		return c.Course.mutate(ctx, m)
	case *CourseSectionMutation:
		return c.CourseSection.mutate(ctx, m)
	case *MediaMutation:
		return c.Media.mutate(ctx, m)
	case *PermissionMutation:
		return c.Permission.mutate(ctx, m)
	case *QuestionMutation:
		return c.Question.mutate(ctx, m)
	case *QuestionCollectionMutation:
		return c.QuestionCollection.mutate(ctx, m)
	case *QuestionOptionMutation:
		return c.QuestionOption.mutate(ctx, m)
	case *RoleMutation:
		return c.Role.mutate(ctx, m)
	case *TestMutation:
		return c.Test.mutate(ctx, m)
	case *TestIgnoreQuestionMutation:
		return c.TestIgnoreQuestion.mutate(ctx, m)
	case *TestQuestionAnswerMutation:
		return c.TestQuestionAnswer.mutate(ctx, m)
	case *TestQuestionCountMutation:
		return c.TestQuestionCount.mutate(ctx, m)
	case *TestQuestionPointMutation:
		return c.TestQuestionPoint.mutate(ctx, m)
	case *TestSessionMutation:
		return c.TestSession.mutate(ctx, m)
	case *TodoMutation:
		return c.Todo.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *VideoMutation:
		return c.Video.mutate(ctx, m)
	case *VideoQuestionTimestampMutation:
		return c.VideoQuestionTimestamp.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// CourseClient is a client for the Course schema.
type CourseClient struct {
	config
}

// NewCourseClient returns a client for the Course from the given config.
func NewCourseClient(c config) *CourseClient {
	return &CourseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `course.Hooks(f(g(h())))`.
func (c *CourseClient) Use(hooks ...Hook) {
	c.hooks.Course = append(c.hooks.Course, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `course.Intercept(f(g(h())))`.
func (c *CourseClient) Intercept(interceptors ...Interceptor) {
	c.inters.Course = append(c.inters.Course, interceptors...)
}

// Create returns a builder for creating a Course entity.
func (c *CourseClient) Create() *CourseCreate {
	mutation := newCourseMutation(c.config, OpCreate)
	return &CourseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Course entities.
func (c *CourseClient) CreateBulk(builders ...*CourseCreate) *CourseCreateBulk {
	return &CourseCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CourseClient) MapCreateBulk(slice any, setFunc func(*CourseCreate, int)) *CourseCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CourseCreateBulk{err: fmt.Errorf("calling to CourseClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CourseCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CourseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Course.
func (c *CourseClient) Update() *CourseUpdate {
	mutation := newCourseMutation(c.config, OpUpdate)
	return &CourseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CourseClient) UpdateOne(co *Course) *CourseUpdateOne {
	mutation := newCourseMutation(c.config, OpUpdateOne, withCourse(co))
	return &CourseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CourseClient) UpdateOneID(id uuid.UUID) *CourseUpdateOne {
	mutation := newCourseMutation(c.config, OpUpdateOne, withCourseID(id))
	return &CourseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Course.
func (c *CourseClient) Delete() *CourseDelete {
	mutation := newCourseMutation(c.config, OpDelete)
	return &CourseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CourseClient) DeleteOne(co *Course) *CourseDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CourseClient) DeleteOneID(id uuid.UUID) *CourseDeleteOne {
	builder := c.Delete().Where(course.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CourseDeleteOne{builder}
}

// Query returns a query builder for Course.
func (c *CourseClient) Query() *CourseQuery {
	return &CourseQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCourse},
		inters: c.Interceptors(),
	}
}

// Get returns a Course entity by its id.
func (c *CourseClient) Get(ctx context.Context, id uuid.UUID) (*Course, error) {
	return c.Query().Where(course.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CourseClient) GetX(ctx context.Context, id uuid.UUID) *Course {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMedia queries the media edge of a Course.
func (c *CourseClient) QueryMedia(co *Course) *MediaQuery {
	query := (&MediaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(course.Table, course.FieldID, id),
			sqlgraph.To(media.Table, media.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, course.MediaTable, course.MediaColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreator queries the creator edge of a Course.
func (c *CourseClient) QueryCreator(co *Course) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(course.Table, course.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, course.CreatorTable, course.CreatorColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCourseSections queries the course_sections edge of a Course.
func (c *CourseClient) QueryCourseSections(co *Course) *CourseSectionQuery {
	query := (&CourseSectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(course.Table, course.FieldID, id),
			sqlgraph.To(coursesection.Table, coursesection.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, course.CourseSectionsTable, course.CourseSectionsColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCourseVideos queries the course_videos edge of a Course.
func (c *CourseClient) QueryCourseVideos(co *Course) *VideoQuery {
	query := (&VideoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(course.Table, course.FieldID, id),
			sqlgraph.To(video.Table, video.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, course.CourseVideosTable, course.CourseVideosColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTests queries the tests edge of a Course.
func (c *CourseClient) QueryTests(co *Course) *TestQuery {
	query := (&TestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(course.Table, course.FieldID, id),
			sqlgraph.To(test.Table, test.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, course.TestsTable, course.TestsColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CourseClient) Hooks() []Hook {
	hooks := c.hooks.Course
	return append(hooks[:len(hooks):len(hooks)], course.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *CourseClient) Interceptors() []Interceptor {
	inters := c.inters.Course
	return append(inters[:len(inters):len(inters)], course.Interceptors[:]...)
}

func (c *CourseClient) mutate(ctx context.Context, m *CourseMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CourseCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CourseUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CourseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CourseDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Course mutation op: %q", m.Op())
	}
}

// CourseSectionClient is a client for the CourseSection schema.
type CourseSectionClient struct {
	config
}

// NewCourseSectionClient returns a client for the CourseSection from the given config.
func NewCourseSectionClient(c config) *CourseSectionClient {
	return &CourseSectionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `coursesection.Hooks(f(g(h())))`.
func (c *CourseSectionClient) Use(hooks ...Hook) {
	c.hooks.CourseSection = append(c.hooks.CourseSection, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `coursesection.Intercept(f(g(h())))`.
func (c *CourseSectionClient) Intercept(interceptors ...Interceptor) {
	c.inters.CourseSection = append(c.inters.CourseSection, interceptors...)
}

// Create returns a builder for creating a CourseSection entity.
func (c *CourseSectionClient) Create() *CourseSectionCreate {
	mutation := newCourseSectionMutation(c.config, OpCreate)
	return &CourseSectionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CourseSection entities.
func (c *CourseSectionClient) CreateBulk(builders ...*CourseSectionCreate) *CourseSectionCreateBulk {
	return &CourseSectionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CourseSectionClient) MapCreateBulk(slice any, setFunc func(*CourseSectionCreate, int)) *CourseSectionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CourseSectionCreateBulk{err: fmt.Errorf("calling to CourseSectionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CourseSectionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CourseSectionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CourseSection.
func (c *CourseSectionClient) Update() *CourseSectionUpdate {
	mutation := newCourseSectionMutation(c.config, OpUpdate)
	return &CourseSectionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CourseSectionClient) UpdateOne(cs *CourseSection) *CourseSectionUpdateOne {
	mutation := newCourseSectionMutation(c.config, OpUpdateOne, withCourseSection(cs))
	return &CourseSectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CourseSectionClient) UpdateOneID(id uuid.UUID) *CourseSectionUpdateOne {
	mutation := newCourseSectionMutation(c.config, OpUpdateOne, withCourseSectionID(id))
	return &CourseSectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CourseSection.
func (c *CourseSectionClient) Delete() *CourseSectionDelete {
	mutation := newCourseSectionMutation(c.config, OpDelete)
	return &CourseSectionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CourseSectionClient) DeleteOne(cs *CourseSection) *CourseSectionDeleteOne {
	return c.DeleteOneID(cs.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CourseSectionClient) DeleteOneID(id uuid.UUID) *CourseSectionDeleteOne {
	builder := c.Delete().Where(coursesection.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CourseSectionDeleteOne{builder}
}

// Query returns a query builder for CourseSection.
func (c *CourseSectionClient) Query() *CourseSectionQuery {
	return &CourseSectionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCourseSection},
		inters: c.Interceptors(),
	}
}

// Get returns a CourseSection entity by its id.
func (c *CourseSectionClient) Get(ctx context.Context, id uuid.UUID) (*CourseSection, error) {
	return c.Query().Where(coursesection.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CourseSectionClient) GetX(ctx context.Context, id uuid.UUID) *CourseSection {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCourse queries the course edge of a CourseSection.
func (c *CourseSectionClient) QueryCourse(cs *CourseSection) *CourseQuery {
	query := (&CourseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(coursesection.Table, coursesection.FieldID, id),
			sqlgraph.To(course.Table, course.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, coursesection.CourseTable, coursesection.CourseColumn),
		)
		fromV = sqlgraph.Neighbors(cs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParent queries the parent edge of a CourseSection.
func (c *CourseSectionClient) QueryParent(cs *CourseSection) *CourseSectionQuery {
	query := (&CourseSectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(coursesection.Table, coursesection.FieldID, id),
			sqlgraph.To(coursesection.Table, coursesection.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, coursesection.ParentTable, coursesection.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(cs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a CourseSection.
func (c *CourseSectionClient) QueryChildren(cs *CourseSection) *CourseSectionQuery {
	query := (&CourseSectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(coursesection.Table, coursesection.FieldID, id),
			sqlgraph.To(coursesection.Table, coursesection.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, coursesection.ChildrenTable, coursesection.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(cs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCourseSectionVideos queries the course_section_videos edge of a CourseSection.
func (c *CourseSectionClient) QueryCourseSectionVideos(cs *CourseSection) *VideoQuery {
	query := (&VideoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(coursesection.Table, coursesection.FieldID, id),
			sqlgraph.To(video.Table, video.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, coursesection.CourseSectionVideosTable, coursesection.CourseSectionVideosColumn),
		)
		fromV = sqlgraph.Neighbors(cs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuestionCollections queries the question_collections edge of a CourseSection.
func (c *CourseSectionClient) QueryQuestionCollections(cs *CourseSection) *QuestionCollectionQuery {
	query := (&QuestionCollectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(coursesection.Table, coursesection.FieldID, id),
			sqlgraph.To(questioncollection.Table, questioncollection.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, coursesection.QuestionCollectionsTable, coursesection.QuestionCollectionsColumn),
		)
		fromV = sqlgraph.Neighbors(cs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTestSessions queries the test_sessions edge of a CourseSection.
func (c *CourseSectionClient) QueryTestSessions(cs *CourseSection) *TestSessionQuery {
	query := (&TestSessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(coursesection.Table, coursesection.FieldID, id),
			sqlgraph.To(testsession.Table, testsession.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, coursesection.TestSessionsTable, coursesection.TestSessionsColumn),
		)
		fromV = sqlgraph.Neighbors(cs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTests queries the tests edge of a CourseSection.
func (c *CourseSectionClient) QueryTests(cs *CourseSection) *TestQuery {
	query := (&TestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(coursesection.Table, coursesection.FieldID, id),
			sqlgraph.To(test.Table, test.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, coursesection.TestsTable, coursesection.TestsColumn),
		)
		fromV = sqlgraph.Neighbors(cs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CourseSectionClient) Hooks() []Hook {
	hooks := c.hooks.CourseSection
	return append(hooks[:len(hooks):len(hooks)], coursesection.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *CourseSectionClient) Interceptors() []Interceptor {
	inters := c.inters.CourseSection
	return append(inters[:len(inters):len(inters)], coursesection.Interceptors[:]...)
}

func (c *CourseSectionClient) mutate(ctx context.Context, m *CourseSectionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CourseSectionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CourseSectionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CourseSectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CourseSectionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CourseSection mutation op: %q", m.Op())
	}
}

// MediaClient is a client for the Media schema.
type MediaClient struct {
	config
}

// NewMediaClient returns a client for the Media from the given config.
func NewMediaClient(c config) *MediaClient {
	return &MediaClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `media.Hooks(f(g(h())))`.
func (c *MediaClient) Use(hooks ...Hook) {
	c.hooks.Media = append(c.hooks.Media, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `media.Intercept(f(g(h())))`.
func (c *MediaClient) Intercept(interceptors ...Interceptor) {
	c.inters.Media = append(c.inters.Media, interceptors...)
}

// Create returns a builder for creating a Media entity.
func (c *MediaClient) Create() *MediaCreate {
	mutation := newMediaMutation(c.config, OpCreate)
	return &MediaCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Media entities.
func (c *MediaClient) CreateBulk(builders ...*MediaCreate) *MediaCreateBulk {
	return &MediaCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MediaClient) MapCreateBulk(slice any, setFunc func(*MediaCreate, int)) *MediaCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MediaCreateBulk{err: fmt.Errorf("calling to MediaClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MediaCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MediaCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Media.
func (c *MediaClient) Update() *MediaUpdate {
	mutation := newMediaMutation(c.config, OpUpdate)
	return &MediaUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MediaClient) UpdateOne(m *Media) *MediaUpdateOne {
	mutation := newMediaMutation(c.config, OpUpdateOne, withMedia(m))
	return &MediaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MediaClient) UpdateOneID(id uuid.UUID) *MediaUpdateOne {
	mutation := newMediaMutation(c.config, OpUpdateOne, withMediaID(id))
	return &MediaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Media.
func (c *MediaClient) Delete() *MediaDelete {
	mutation := newMediaMutation(c.config, OpDelete)
	return &MediaDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MediaClient) DeleteOne(m *Media) *MediaDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MediaClient) DeleteOneID(id uuid.UUID) *MediaDeleteOne {
	builder := c.Delete().Where(media.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MediaDeleteOne{builder}
}

// Query returns a query builder for Media.
func (c *MediaClient) Query() *MediaQuery {
	return &MediaQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMedia},
		inters: c.Interceptors(),
	}
}

// Get returns a Media entity by its id.
func (c *MediaClient) Get(ctx context.Context, id uuid.UUID) (*Media, error) {
	return c.Query().Where(media.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MediaClient) GetX(ctx context.Context, id uuid.UUID) *Media {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUserMedia queries the user_media edge of a Media.
func (c *MediaClient) QueryUserMedia(m *Media) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(media.Table, media.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, media.UserMediaTable, media.UserMediaColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a Media.
func (c *MediaClient) QueryUser(m *Media) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(media.Table, media.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, media.UserTable, media.UserColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCourseMedia queries the course_media edge of a Media.
func (c *MediaClient) QueryCourseMedia(m *Media) *CourseQuery {
	query := (&CourseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(media.Table, media.FieldID, id),
			sqlgraph.To(course.Table, course.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, media.CourseMediaTable, media.CourseMediaColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVideoMedia queries the video_media edge of a Media.
func (c *MediaClient) QueryVideoMedia(m *Media) *VideoQuery {
	query := (&VideoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(media.Table, media.FieldID, id),
			sqlgraph.To(video.Table, video.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, media.VideoMediaTable, media.VideoMediaColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MediaClient) Hooks() []Hook {
	hooks := c.hooks.Media
	return append(hooks[:len(hooks):len(hooks)], media.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *MediaClient) Interceptors() []Interceptor {
	inters := c.inters.Media
	return append(inters[:len(inters):len(inters)], media.Interceptors[:]...)
}

func (c *MediaClient) mutate(ctx context.Context, m *MediaMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MediaCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MediaUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MediaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MediaDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Media mutation op: %q", m.Op())
	}
}

// PermissionClient is a client for the Permission schema.
type PermissionClient struct {
	config
}

// NewPermissionClient returns a client for the Permission from the given config.
func NewPermissionClient(c config) *PermissionClient {
	return &PermissionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `permission.Hooks(f(g(h())))`.
func (c *PermissionClient) Use(hooks ...Hook) {
	c.hooks.Permission = append(c.hooks.Permission, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `permission.Intercept(f(g(h())))`.
func (c *PermissionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Permission = append(c.inters.Permission, interceptors...)
}

// Create returns a builder for creating a Permission entity.
func (c *PermissionClient) Create() *PermissionCreate {
	mutation := newPermissionMutation(c.config, OpCreate)
	return &PermissionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Permission entities.
func (c *PermissionClient) CreateBulk(builders ...*PermissionCreate) *PermissionCreateBulk {
	return &PermissionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PermissionClient) MapCreateBulk(slice any, setFunc func(*PermissionCreate, int)) *PermissionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PermissionCreateBulk{err: fmt.Errorf("calling to PermissionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PermissionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PermissionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Permission.
func (c *PermissionClient) Update() *PermissionUpdate {
	mutation := newPermissionMutation(c.config, OpUpdate)
	return &PermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PermissionClient) UpdateOne(pe *Permission) *PermissionUpdateOne {
	mutation := newPermissionMutation(c.config, OpUpdateOne, withPermission(pe))
	return &PermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PermissionClient) UpdateOneID(id uuid.UUID) *PermissionUpdateOne {
	mutation := newPermissionMutation(c.config, OpUpdateOne, withPermissionID(id))
	return &PermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Permission.
func (c *PermissionClient) Delete() *PermissionDelete {
	mutation := newPermissionMutation(c.config, OpDelete)
	return &PermissionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PermissionClient) DeleteOne(pe *Permission) *PermissionDeleteOne {
	return c.DeleteOneID(pe.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PermissionClient) DeleteOneID(id uuid.UUID) *PermissionDeleteOne {
	builder := c.Delete().Where(permission.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PermissionDeleteOne{builder}
}

// Query returns a query builder for Permission.
func (c *PermissionClient) Query() *PermissionQuery {
	return &PermissionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePermission},
		inters: c.Interceptors(),
	}
}

// Get returns a Permission entity by its id.
func (c *PermissionClient) Get(ctx context.Context, id uuid.UUID) (*Permission, error) {
	return c.Query().Where(permission.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PermissionClient) GetX(ctx context.Context, id uuid.UUID) *Permission {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRoles queries the roles edge of a Permission.
func (c *PermissionClient) QueryRoles(pe *Permission) *RoleQuery {
	query := (&RoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(permission.Table, permission.FieldID, id),
			sqlgraph.To(role.Table, role.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, permission.RolesTable, permission.RolesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PermissionClient) Hooks() []Hook {
	hooks := c.hooks.Permission
	return append(hooks[:len(hooks):len(hooks)], permission.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *PermissionClient) Interceptors() []Interceptor {
	inters := c.inters.Permission
	return append(inters[:len(inters):len(inters)], permission.Interceptors[:]...)
}

func (c *PermissionClient) mutate(ctx context.Context, m *PermissionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PermissionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PermissionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Permission mutation op: %q", m.Op())
	}
}

// QuestionClient is a client for the Question schema.
type QuestionClient struct {
	config
}

// NewQuestionClient returns a client for the Question from the given config.
func NewQuestionClient(c config) *QuestionClient {
	return &QuestionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `question.Hooks(f(g(h())))`.
func (c *QuestionClient) Use(hooks ...Hook) {
	c.hooks.Question = append(c.hooks.Question, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `question.Intercept(f(g(h())))`.
func (c *QuestionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Question = append(c.inters.Question, interceptors...)
}

// Create returns a builder for creating a Question entity.
func (c *QuestionClient) Create() *QuestionCreate {
	mutation := newQuestionMutation(c.config, OpCreate)
	return &QuestionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Question entities.
func (c *QuestionClient) CreateBulk(builders ...*QuestionCreate) *QuestionCreateBulk {
	return &QuestionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *QuestionClient) MapCreateBulk(slice any, setFunc func(*QuestionCreate, int)) *QuestionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &QuestionCreateBulk{err: fmt.Errorf("calling to QuestionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*QuestionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &QuestionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Question.
func (c *QuestionClient) Update() *QuestionUpdate {
	mutation := newQuestionMutation(c.config, OpUpdate)
	return &QuestionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *QuestionClient) UpdateOne(q *Question) *QuestionUpdateOne {
	mutation := newQuestionMutation(c.config, OpUpdateOne, withQuestion(q))
	return &QuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *QuestionClient) UpdateOneID(id uuid.UUID) *QuestionUpdateOne {
	mutation := newQuestionMutation(c.config, OpUpdateOne, withQuestionID(id))
	return &QuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Question.
func (c *QuestionClient) Delete() *QuestionDelete {
	mutation := newQuestionMutation(c.config, OpDelete)
	return &QuestionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *QuestionClient) DeleteOne(q *Question) *QuestionDeleteOne {
	return c.DeleteOneID(q.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *QuestionClient) DeleteOneID(id uuid.UUID) *QuestionDeleteOne {
	builder := c.Delete().Where(question.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &QuestionDeleteOne{builder}
}

// Query returns a query builder for Question.
func (c *QuestionClient) Query() *QuestionQuery {
	return &QuestionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeQuestion},
		inters: c.Interceptors(),
	}
}

// Get returns a Question entity by its id.
func (c *QuestionClient) Get(ctx context.Context, id uuid.UUID) (*Question, error) {
	return c.Query().Where(question.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *QuestionClient) GetX(ctx context.Context, id uuid.UUID) *Question {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCollection queries the collection edge of a Question.
func (c *QuestionClient) QueryCollection(q *Question) *QuestionCollectionQuery {
	query := (&QuestionCollectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := q.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(question.Table, question.FieldID, id),
			sqlgraph.To(questioncollection.Table, questioncollection.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, question.CollectionTable, question.CollectionColumn),
		)
		fromV = sqlgraph.Neighbors(q.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuestionOptions queries the question_options edge of a Question.
func (c *QuestionClient) QueryQuestionOptions(q *Question) *QuestionOptionQuery {
	query := (&QuestionOptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := q.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(question.Table, question.FieldID, id),
			sqlgraph.To(questionoption.Table, questionoption.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, question.QuestionOptionsTable, question.QuestionOptionsColumn),
		)
		fromV = sqlgraph.Neighbors(q.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVideoQuestionTimestampsQuestion queries the video_question_timestamps_question edge of a Question.
func (c *QuestionClient) QueryVideoQuestionTimestampsQuestion(q *Question) *VideoQuestionTimestampQuery {
	query := (&VideoQuestionTimestampClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := q.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(question.Table, question.FieldID, id),
			sqlgraph.To(videoquestiontimestamp.Table, videoquestiontimestamp.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, question.VideoQuestionTimestampsQuestionTable, question.VideoQuestionTimestampsQuestionColumn),
		)
		fromV = sqlgraph.Neighbors(q.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserQuestionAnswers queries the user_question_answers edge of a Question.
func (c *QuestionClient) QueryUserQuestionAnswers(q *Question) *TestQuestionAnswerQuery {
	query := (&TestQuestionAnswerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := q.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(question.Table, question.FieldID, id),
			sqlgraph.To(testquestionanswer.Table, testquestionanswer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, question.UserQuestionAnswersTable, question.UserQuestionAnswersColumn),
		)
		fromV = sqlgraph.Neighbors(q.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTests queries the tests edge of a Question.
func (c *QuestionClient) QueryTests(q *Question) *TestQuery {
	query := (&TestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := q.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(question.Table, question.FieldID, id),
			sqlgraph.To(test.Table, test.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, question.TestsTable, question.TestsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(q.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTestIgnoreQuestions queries the test_ignore_questions edge of a Question.
func (c *QuestionClient) QueryTestIgnoreQuestions(q *Question) *TestIgnoreQuestionQuery {
	query := (&TestIgnoreQuestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := q.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(question.Table, question.FieldID, id),
			sqlgraph.To(testignorequestion.Table, testignorequestion.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, question.TestIgnoreQuestionsTable, question.TestIgnoreQuestionsColumn),
		)
		fromV = sqlgraph.Neighbors(q.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTestQuestionPoints queries the test_question_points edge of a Question.
func (c *QuestionClient) QueryTestQuestionPoints(q *Question) *TestQuestionPointQuery {
	query := (&TestQuestionPointClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := q.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(question.Table, question.FieldID, id),
			sqlgraph.To(testquestionpoint.Table, testquestionpoint.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, question.TestQuestionPointsTable, question.TestQuestionPointsColumn),
		)
		fromV = sqlgraph.Neighbors(q.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *QuestionClient) Hooks() []Hook {
	hooks := c.hooks.Question
	return append(hooks[:len(hooks):len(hooks)], question.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *QuestionClient) Interceptors() []Interceptor {
	inters := c.inters.Question
	return append(inters[:len(inters):len(inters)], question.Interceptors[:]...)
}

func (c *QuestionClient) mutate(ctx context.Context, m *QuestionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&QuestionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&QuestionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&QuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&QuestionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Question mutation op: %q", m.Op())
	}
}

// QuestionCollectionClient is a client for the QuestionCollection schema.
type QuestionCollectionClient struct {
	config
}

// NewQuestionCollectionClient returns a client for the QuestionCollection from the given config.
func NewQuestionCollectionClient(c config) *QuestionCollectionClient {
	return &QuestionCollectionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `questioncollection.Hooks(f(g(h())))`.
func (c *QuestionCollectionClient) Use(hooks ...Hook) {
	c.hooks.QuestionCollection = append(c.hooks.QuestionCollection, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `questioncollection.Intercept(f(g(h())))`.
func (c *QuestionCollectionClient) Intercept(interceptors ...Interceptor) {
	c.inters.QuestionCollection = append(c.inters.QuestionCollection, interceptors...)
}

// Create returns a builder for creating a QuestionCollection entity.
func (c *QuestionCollectionClient) Create() *QuestionCollectionCreate {
	mutation := newQuestionCollectionMutation(c.config, OpCreate)
	return &QuestionCollectionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of QuestionCollection entities.
func (c *QuestionCollectionClient) CreateBulk(builders ...*QuestionCollectionCreate) *QuestionCollectionCreateBulk {
	return &QuestionCollectionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *QuestionCollectionClient) MapCreateBulk(slice any, setFunc func(*QuestionCollectionCreate, int)) *QuestionCollectionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &QuestionCollectionCreateBulk{err: fmt.Errorf("calling to QuestionCollectionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*QuestionCollectionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &QuestionCollectionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for QuestionCollection.
func (c *QuestionCollectionClient) Update() *QuestionCollectionUpdate {
	mutation := newQuestionCollectionMutation(c.config, OpUpdate)
	return &QuestionCollectionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *QuestionCollectionClient) UpdateOne(qc *QuestionCollection) *QuestionCollectionUpdateOne {
	mutation := newQuestionCollectionMutation(c.config, OpUpdateOne, withQuestionCollection(qc))
	return &QuestionCollectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *QuestionCollectionClient) UpdateOneID(id uuid.UUID) *QuestionCollectionUpdateOne {
	mutation := newQuestionCollectionMutation(c.config, OpUpdateOne, withQuestionCollectionID(id))
	return &QuestionCollectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for QuestionCollection.
func (c *QuestionCollectionClient) Delete() *QuestionCollectionDelete {
	mutation := newQuestionCollectionMutation(c.config, OpDelete)
	return &QuestionCollectionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *QuestionCollectionClient) DeleteOne(qc *QuestionCollection) *QuestionCollectionDeleteOne {
	return c.DeleteOneID(qc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *QuestionCollectionClient) DeleteOneID(id uuid.UUID) *QuestionCollectionDeleteOne {
	builder := c.Delete().Where(questioncollection.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &QuestionCollectionDeleteOne{builder}
}

// Query returns a query builder for QuestionCollection.
func (c *QuestionCollectionClient) Query() *QuestionCollectionQuery {
	return &QuestionCollectionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeQuestionCollection},
		inters: c.Interceptors(),
	}
}

// Get returns a QuestionCollection entity by its id.
func (c *QuestionCollectionClient) Get(ctx context.Context, id uuid.UUID) (*QuestionCollection, error) {
	return c.Query().Where(questioncollection.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *QuestionCollectionClient) GetX(ctx context.Context, id uuid.UUID) *QuestionCollection {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCreator queries the creator edge of a QuestionCollection.
func (c *QuestionCollectionClient) QueryCreator(qc *QuestionCollection) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := qc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(questioncollection.Table, questioncollection.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, questioncollection.CreatorTable, questioncollection.CreatorColumn),
		)
		fromV = sqlgraph.Neighbors(qc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuestions queries the questions edge of a QuestionCollection.
func (c *QuestionCollectionClient) QueryQuestions(qc *QuestionCollection) *QuestionQuery {
	query := (&QuestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := qc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(questioncollection.Table, questioncollection.FieldID, id),
			sqlgraph.To(question.Table, question.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, questioncollection.QuestionsTable, questioncollection.QuestionsColumn),
		)
		fromV = sqlgraph.Neighbors(qc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCourseSection queries the course_section edge of a QuestionCollection.
func (c *QuestionCollectionClient) QueryCourseSection(qc *QuestionCollection) *CourseSectionQuery {
	query := (&CourseSectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := qc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(questioncollection.Table, questioncollection.FieldID, id),
			sqlgraph.To(coursesection.Table, coursesection.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, questioncollection.CourseSectionTable, questioncollection.CourseSectionColumn),
		)
		fromV = sqlgraph.Neighbors(qc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTest queries the test edge of a QuestionCollection.
func (c *QuestionCollectionClient) QueryTest(qc *QuestionCollection) *TestQuery {
	query := (&TestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := qc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(questioncollection.Table, questioncollection.FieldID, id),
			sqlgraph.To(test.Table, test.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, questioncollection.TestTable, questioncollection.TestPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(qc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *QuestionCollectionClient) Hooks() []Hook {
	hooks := c.hooks.QuestionCollection
	return append(hooks[:len(hooks):len(hooks)], questioncollection.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *QuestionCollectionClient) Interceptors() []Interceptor {
	inters := c.inters.QuestionCollection
	return append(inters[:len(inters):len(inters)], questioncollection.Interceptors[:]...)
}

func (c *QuestionCollectionClient) mutate(ctx context.Context, m *QuestionCollectionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&QuestionCollectionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&QuestionCollectionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&QuestionCollectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&QuestionCollectionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown QuestionCollection mutation op: %q", m.Op())
	}
}

// QuestionOptionClient is a client for the QuestionOption schema.
type QuestionOptionClient struct {
	config
}

// NewQuestionOptionClient returns a client for the QuestionOption from the given config.
func NewQuestionOptionClient(c config) *QuestionOptionClient {
	return &QuestionOptionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `questionoption.Hooks(f(g(h())))`.
func (c *QuestionOptionClient) Use(hooks ...Hook) {
	c.hooks.QuestionOption = append(c.hooks.QuestionOption, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `questionoption.Intercept(f(g(h())))`.
func (c *QuestionOptionClient) Intercept(interceptors ...Interceptor) {
	c.inters.QuestionOption = append(c.inters.QuestionOption, interceptors...)
}

// Create returns a builder for creating a QuestionOption entity.
func (c *QuestionOptionClient) Create() *QuestionOptionCreate {
	mutation := newQuestionOptionMutation(c.config, OpCreate)
	return &QuestionOptionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of QuestionOption entities.
func (c *QuestionOptionClient) CreateBulk(builders ...*QuestionOptionCreate) *QuestionOptionCreateBulk {
	return &QuestionOptionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *QuestionOptionClient) MapCreateBulk(slice any, setFunc func(*QuestionOptionCreate, int)) *QuestionOptionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &QuestionOptionCreateBulk{err: fmt.Errorf("calling to QuestionOptionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*QuestionOptionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &QuestionOptionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for QuestionOption.
func (c *QuestionOptionClient) Update() *QuestionOptionUpdate {
	mutation := newQuestionOptionMutation(c.config, OpUpdate)
	return &QuestionOptionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *QuestionOptionClient) UpdateOne(qo *QuestionOption) *QuestionOptionUpdateOne {
	mutation := newQuestionOptionMutation(c.config, OpUpdateOne, withQuestionOption(qo))
	return &QuestionOptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *QuestionOptionClient) UpdateOneID(id uuid.UUID) *QuestionOptionUpdateOne {
	mutation := newQuestionOptionMutation(c.config, OpUpdateOne, withQuestionOptionID(id))
	return &QuestionOptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for QuestionOption.
func (c *QuestionOptionClient) Delete() *QuestionOptionDelete {
	mutation := newQuestionOptionMutation(c.config, OpDelete)
	return &QuestionOptionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *QuestionOptionClient) DeleteOne(qo *QuestionOption) *QuestionOptionDeleteOne {
	return c.DeleteOneID(qo.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *QuestionOptionClient) DeleteOneID(id uuid.UUID) *QuestionOptionDeleteOne {
	builder := c.Delete().Where(questionoption.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &QuestionOptionDeleteOne{builder}
}

// Query returns a query builder for QuestionOption.
func (c *QuestionOptionClient) Query() *QuestionOptionQuery {
	return &QuestionOptionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeQuestionOption},
		inters: c.Interceptors(),
	}
}

// Get returns a QuestionOption entity by its id.
func (c *QuestionOptionClient) Get(ctx context.Context, id uuid.UUID) (*QuestionOption, error) {
	return c.Query().Where(questionoption.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *QuestionOptionClient) GetX(ctx context.Context, id uuid.UUID) *QuestionOption {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryQuestion queries the question edge of a QuestionOption.
func (c *QuestionOptionClient) QueryQuestion(qo *QuestionOption) *QuestionQuery {
	query := (&QuestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := qo.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(questionoption.Table, questionoption.FieldID, id),
			sqlgraph.To(question.Table, question.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, questionoption.QuestionTable, questionoption.QuestionColumn),
		)
		fromV = sqlgraph.Neighbors(qo.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserQuestionAnswers queries the user_question_answers edge of a QuestionOption.
func (c *QuestionOptionClient) QueryUserQuestionAnswers(qo *QuestionOption) *TestQuestionAnswerQuery {
	query := (&TestQuestionAnswerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := qo.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(questionoption.Table, questionoption.FieldID, id),
			sqlgraph.To(testquestionanswer.Table, testquestionanswer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, questionoption.UserQuestionAnswersTable, questionoption.UserQuestionAnswersColumn),
		)
		fromV = sqlgraph.Neighbors(qo.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *QuestionOptionClient) Hooks() []Hook {
	hooks := c.hooks.QuestionOption
	return append(hooks[:len(hooks):len(hooks)], questionoption.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *QuestionOptionClient) Interceptors() []Interceptor {
	inters := c.inters.QuestionOption
	return append(inters[:len(inters):len(inters)], questionoption.Interceptors[:]...)
}

func (c *QuestionOptionClient) mutate(ctx context.Context, m *QuestionOptionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&QuestionOptionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&QuestionOptionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&QuestionOptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&QuestionOptionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown QuestionOption mutation op: %q", m.Op())
	}
}

// RoleClient is a client for the Role schema.
type RoleClient struct {
	config
}

// NewRoleClient returns a client for the Role from the given config.
func NewRoleClient(c config) *RoleClient {
	return &RoleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `role.Hooks(f(g(h())))`.
func (c *RoleClient) Use(hooks ...Hook) {
	c.hooks.Role = append(c.hooks.Role, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `role.Intercept(f(g(h())))`.
func (c *RoleClient) Intercept(interceptors ...Interceptor) {
	c.inters.Role = append(c.inters.Role, interceptors...)
}

// Create returns a builder for creating a Role entity.
func (c *RoleClient) Create() *RoleCreate {
	mutation := newRoleMutation(c.config, OpCreate)
	return &RoleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Role entities.
func (c *RoleClient) CreateBulk(builders ...*RoleCreate) *RoleCreateBulk {
	return &RoleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RoleClient) MapCreateBulk(slice any, setFunc func(*RoleCreate, int)) *RoleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RoleCreateBulk{err: fmt.Errorf("calling to RoleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RoleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RoleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Role.
func (c *RoleClient) Update() *RoleUpdate {
	mutation := newRoleMutation(c.config, OpUpdate)
	return &RoleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RoleClient) UpdateOne(r *Role) *RoleUpdateOne {
	mutation := newRoleMutation(c.config, OpUpdateOne, withRole(r))
	return &RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RoleClient) UpdateOneID(id uuid.UUID) *RoleUpdateOne {
	mutation := newRoleMutation(c.config, OpUpdateOne, withRoleID(id))
	return &RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Role.
func (c *RoleClient) Delete() *RoleDelete {
	mutation := newRoleMutation(c.config, OpDelete)
	return &RoleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RoleClient) DeleteOne(r *Role) *RoleDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RoleClient) DeleteOneID(id uuid.UUID) *RoleDeleteOne {
	builder := c.Delete().Where(role.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RoleDeleteOne{builder}
}

// Query returns a query builder for Role.
func (c *RoleClient) Query() *RoleQuery {
	return &RoleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRole},
		inters: c.Interceptors(),
	}
}

// Get returns a Role entity by its id.
func (c *RoleClient) Get(ctx context.Context, id uuid.UUID) (*Role, error) {
	return c.Query().Where(role.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RoleClient) GetX(ctx context.Context, id uuid.UUID) *Role {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUsers queries the users edge of a Role.
func (c *RoleClient) QueryUsers(r *Role) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(role.Table, role.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, role.UsersTable, role.UsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPermissions queries the permissions edge of a Role.
func (c *RoleClient) QueryPermissions(r *Role) *PermissionQuery {
	query := (&PermissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(role.Table, role.FieldID, id),
			sqlgraph.To(permission.Table, permission.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, role.PermissionsTable, role.PermissionsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RoleClient) Hooks() []Hook {
	hooks := c.hooks.Role
	return append(hooks[:len(hooks):len(hooks)], role.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *RoleClient) Interceptors() []Interceptor {
	inters := c.inters.Role
	return append(inters[:len(inters):len(inters)], role.Interceptors[:]...)
}

func (c *RoleClient) mutate(ctx context.Context, m *RoleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RoleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RoleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RoleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Role mutation op: %q", m.Op())
	}
}

// TestClient is a client for the Test schema.
type TestClient struct {
	config
}

// NewTestClient returns a client for the Test from the given config.
func NewTestClient(c config) *TestClient {
	return &TestClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `test.Hooks(f(g(h())))`.
func (c *TestClient) Use(hooks ...Hook) {
	c.hooks.Test = append(c.hooks.Test, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `test.Intercept(f(g(h())))`.
func (c *TestClient) Intercept(interceptors ...Interceptor) {
	c.inters.Test = append(c.inters.Test, interceptors...)
}

// Create returns a builder for creating a Test entity.
func (c *TestClient) Create() *TestCreate {
	mutation := newTestMutation(c.config, OpCreate)
	return &TestCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Test entities.
func (c *TestClient) CreateBulk(builders ...*TestCreate) *TestCreateBulk {
	return &TestCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TestClient) MapCreateBulk(slice any, setFunc func(*TestCreate, int)) *TestCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TestCreateBulk{err: fmt.Errorf("calling to TestClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TestCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TestCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Test.
func (c *TestClient) Update() *TestUpdate {
	mutation := newTestMutation(c.config, OpUpdate)
	return &TestUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TestClient) UpdateOne(t *Test) *TestUpdateOne {
	mutation := newTestMutation(c.config, OpUpdateOne, withTest(t))
	return &TestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TestClient) UpdateOneID(id uuid.UUID) *TestUpdateOne {
	mutation := newTestMutation(c.config, OpUpdateOne, withTestID(id))
	return &TestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Test.
func (c *TestClient) Delete() *TestDelete {
	mutation := newTestMutation(c.config, OpDelete)
	return &TestDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TestClient) DeleteOne(t *Test) *TestDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TestClient) DeleteOneID(id uuid.UUID) *TestDeleteOne {
	builder := c.Delete().Where(test.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TestDeleteOne{builder}
}

// Query returns a query builder for Test.
func (c *TestClient) Query() *TestQuery {
	return &TestQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTest},
		inters: c.Interceptors(),
	}
}

// Get returns a Test entity by its id.
func (c *TestClient) Get(ctx context.Context, id uuid.UUID) (*Test, error) {
	return c.Query().Where(test.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TestClient) GetX(ctx context.Context, id uuid.UUID) *Test {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCourseSection queries the course_section edge of a Test.
func (c *TestClient) QueryCourseSection(t *Test) *CourseSectionQuery {
	query := (&CourseSectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(test.Table, test.FieldID, id),
			sqlgraph.To(coursesection.Table, coursesection.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, test.CourseSectionTable, test.CourseSectionColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCourse queries the course edge of a Test.
func (c *TestClient) QueryCourse(t *Test) *CourseQuery {
	query := (&CourseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(test.Table, test.FieldID, id),
			sqlgraph.To(course.Table, course.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, test.CourseTable, test.CourseColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTestSessions queries the test_sessions edge of a Test.
func (c *TestClient) QueryTestSessions(t *Test) *TestSessionQuery {
	query := (&TestSessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(test.Table, test.FieldID, id),
			sqlgraph.To(testsession.Table, testsession.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, test.TestSessionsTable, test.TestSessionsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuestions queries the questions edge of a Test.
func (c *TestClient) QueryQuestions(t *Test) *QuestionQuery {
	query := (&QuestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(test.Table, test.FieldID, id),
			sqlgraph.To(question.Table, question.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, test.QuestionsTable, test.QuestionsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuestionCollections queries the question_collections edge of a Test.
func (c *TestClient) QueryQuestionCollections(t *Test) *QuestionCollectionQuery {
	query := (&QuestionCollectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(test.Table, test.FieldID, id),
			sqlgraph.To(questioncollection.Table, questioncollection.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, test.QuestionCollectionsTable, test.QuestionCollectionsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTestQuestionCounts queries the test_question_counts edge of a Test.
func (c *TestClient) QueryTestQuestionCounts(t *Test) *TestQuestionCountQuery {
	query := (&TestQuestionCountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(test.Table, test.FieldID, id),
			sqlgraph.To(testquestioncount.Table, testquestioncount.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, test.TestQuestionCountsTable, test.TestQuestionCountsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTestIgnoreQuestions queries the test_ignore_questions edge of a Test.
func (c *TestClient) QueryTestIgnoreQuestions(t *Test) *TestIgnoreQuestionQuery {
	query := (&TestIgnoreQuestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(test.Table, test.FieldID, id),
			sqlgraph.To(testignorequestion.Table, testignorequestion.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, test.TestIgnoreQuestionsTable, test.TestIgnoreQuestionsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTestQuestionPoints queries the test_question_points edge of a Test.
func (c *TestClient) QueryTestQuestionPoints(t *Test) *TestQuestionPointQuery {
	query := (&TestQuestionPointClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(test.Table, test.FieldID, id),
			sqlgraph.To(testquestionpoint.Table, testquestionpoint.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, test.TestQuestionPointsTable, test.TestQuestionPointsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TestClient) Hooks() []Hook {
	hooks := c.hooks.Test
	return append(hooks[:len(hooks):len(hooks)], test.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TestClient) Interceptors() []Interceptor {
	inters := c.inters.Test
	return append(inters[:len(inters):len(inters)], test.Interceptors[:]...)
}

func (c *TestClient) mutate(ctx context.Context, m *TestMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TestCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TestUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TestDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Test mutation op: %q", m.Op())
	}
}

// TestIgnoreQuestionClient is a client for the TestIgnoreQuestion schema.
type TestIgnoreQuestionClient struct {
	config
}

// NewTestIgnoreQuestionClient returns a client for the TestIgnoreQuestion from the given config.
func NewTestIgnoreQuestionClient(c config) *TestIgnoreQuestionClient {
	return &TestIgnoreQuestionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `testignorequestion.Hooks(f(g(h())))`.
func (c *TestIgnoreQuestionClient) Use(hooks ...Hook) {
	c.hooks.TestIgnoreQuestion = append(c.hooks.TestIgnoreQuestion, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `testignorequestion.Intercept(f(g(h())))`.
func (c *TestIgnoreQuestionClient) Intercept(interceptors ...Interceptor) {
	c.inters.TestIgnoreQuestion = append(c.inters.TestIgnoreQuestion, interceptors...)
}

// Create returns a builder for creating a TestIgnoreQuestion entity.
func (c *TestIgnoreQuestionClient) Create() *TestIgnoreQuestionCreate {
	mutation := newTestIgnoreQuestionMutation(c.config, OpCreate)
	return &TestIgnoreQuestionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TestIgnoreQuestion entities.
func (c *TestIgnoreQuestionClient) CreateBulk(builders ...*TestIgnoreQuestionCreate) *TestIgnoreQuestionCreateBulk {
	return &TestIgnoreQuestionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TestIgnoreQuestionClient) MapCreateBulk(slice any, setFunc func(*TestIgnoreQuestionCreate, int)) *TestIgnoreQuestionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TestIgnoreQuestionCreateBulk{err: fmt.Errorf("calling to TestIgnoreQuestionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TestIgnoreQuestionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TestIgnoreQuestionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TestIgnoreQuestion.
func (c *TestIgnoreQuestionClient) Update() *TestIgnoreQuestionUpdate {
	mutation := newTestIgnoreQuestionMutation(c.config, OpUpdate)
	return &TestIgnoreQuestionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TestIgnoreQuestionClient) UpdateOne(tiq *TestIgnoreQuestion) *TestIgnoreQuestionUpdateOne {
	mutation := newTestIgnoreQuestionMutation(c.config, OpUpdateOne, withTestIgnoreQuestion(tiq))
	return &TestIgnoreQuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TestIgnoreQuestionClient) UpdateOneID(id uuid.UUID) *TestIgnoreQuestionUpdateOne {
	mutation := newTestIgnoreQuestionMutation(c.config, OpUpdateOne, withTestIgnoreQuestionID(id))
	return &TestIgnoreQuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TestIgnoreQuestion.
func (c *TestIgnoreQuestionClient) Delete() *TestIgnoreQuestionDelete {
	mutation := newTestIgnoreQuestionMutation(c.config, OpDelete)
	return &TestIgnoreQuestionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TestIgnoreQuestionClient) DeleteOne(tiq *TestIgnoreQuestion) *TestIgnoreQuestionDeleteOne {
	return c.DeleteOneID(tiq.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TestIgnoreQuestionClient) DeleteOneID(id uuid.UUID) *TestIgnoreQuestionDeleteOne {
	builder := c.Delete().Where(testignorequestion.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TestIgnoreQuestionDeleteOne{builder}
}

// Query returns a query builder for TestIgnoreQuestion.
func (c *TestIgnoreQuestionClient) Query() *TestIgnoreQuestionQuery {
	return &TestIgnoreQuestionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTestIgnoreQuestion},
		inters: c.Interceptors(),
	}
}

// Get returns a TestIgnoreQuestion entity by its id.
func (c *TestIgnoreQuestionClient) Get(ctx context.Context, id uuid.UUID) (*TestIgnoreQuestion, error) {
	return c.Query().Where(testignorequestion.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TestIgnoreQuestionClient) GetX(ctx context.Context, id uuid.UUID) *TestIgnoreQuestion {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTest queries the test edge of a TestIgnoreQuestion.
func (c *TestIgnoreQuestionClient) QueryTest(tiq *TestIgnoreQuestion) *TestQuery {
	query := (&TestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tiq.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testignorequestion.Table, testignorequestion.FieldID, id),
			sqlgraph.To(test.Table, test.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, testignorequestion.TestTable, testignorequestion.TestColumn),
		)
		fromV = sqlgraph.Neighbors(tiq.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuestion queries the question edge of a TestIgnoreQuestion.
func (c *TestIgnoreQuestionClient) QueryQuestion(tiq *TestIgnoreQuestion) *QuestionQuery {
	query := (&QuestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tiq.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testignorequestion.Table, testignorequestion.FieldID, id),
			sqlgraph.To(question.Table, question.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, testignorequestion.QuestionTable, testignorequestion.QuestionColumn),
		)
		fromV = sqlgraph.Neighbors(tiq.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TestIgnoreQuestionClient) Hooks() []Hook {
	hooks := c.hooks.TestIgnoreQuestion
	return append(hooks[:len(hooks):len(hooks)], testignorequestion.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TestIgnoreQuestionClient) Interceptors() []Interceptor {
	inters := c.inters.TestIgnoreQuestion
	return append(inters[:len(inters):len(inters)], testignorequestion.Interceptors[:]...)
}

func (c *TestIgnoreQuestionClient) mutate(ctx context.Context, m *TestIgnoreQuestionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TestIgnoreQuestionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TestIgnoreQuestionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TestIgnoreQuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TestIgnoreQuestionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TestIgnoreQuestion mutation op: %q", m.Op())
	}
}

// TestQuestionAnswerClient is a client for the TestQuestionAnswer schema.
type TestQuestionAnswerClient struct {
	config
}

// NewTestQuestionAnswerClient returns a client for the TestQuestionAnswer from the given config.
func NewTestQuestionAnswerClient(c config) *TestQuestionAnswerClient {
	return &TestQuestionAnswerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `testquestionanswer.Hooks(f(g(h())))`.
func (c *TestQuestionAnswerClient) Use(hooks ...Hook) {
	c.hooks.TestQuestionAnswer = append(c.hooks.TestQuestionAnswer, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `testquestionanswer.Intercept(f(g(h())))`.
func (c *TestQuestionAnswerClient) Intercept(interceptors ...Interceptor) {
	c.inters.TestQuestionAnswer = append(c.inters.TestQuestionAnswer, interceptors...)
}

// Create returns a builder for creating a TestQuestionAnswer entity.
func (c *TestQuestionAnswerClient) Create() *TestQuestionAnswerCreate {
	mutation := newTestQuestionAnswerMutation(c.config, OpCreate)
	return &TestQuestionAnswerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TestQuestionAnswer entities.
func (c *TestQuestionAnswerClient) CreateBulk(builders ...*TestQuestionAnswerCreate) *TestQuestionAnswerCreateBulk {
	return &TestQuestionAnswerCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TestQuestionAnswerClient) MapCreateBulk(slice any, setFunc func(*TestQuestionAnswerCreate, int)) *TestQuestionAnswerCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TestQuestionAnswerCreateBulk{err: fmt.Errorf("calling to TestQuestionAnswerClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TestQuestionAnswerCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TestQuestionAnswerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TestQuestionAnswer.
func (c *TestQuestionAnswerClient) Update() *TestQuestionAnswerUpdate {
	mutation := newTestQuestionAnswerMutation(c.config, OpUpdate)
	return &TestQuestionAnswerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TestQuestionAnswerClient) UpdateOne(tqa *TestQuestionAnswer) *TestQuestionAnswerUpdateOne {
	mutation := newTestQuestionAnswerMutation(c.config, OpUpdateOne, withTestQuestionAnswer(tqa))
	return &TestQuestionAnswerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TestQuestionAnswerClient) UpdateOneID(id uuid.UUID) *TestQuestionAnswerUpdateOne {
	mutation := newTestQuestionAnswerMutation(c.config, OpUpdateOne, withTestQuestionAnswerID(id))
	return &TestQuestionAnswerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TestQuestionAnswer.
func (c *TestQuestionAnswerClient) Delete() *TestQuestionAnswerDelete {
	mutation := newTestQuestionAnswerMutation(c.config, OpDelete)
	return &TestQuestionAnswerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TestQuestionAnswerClient) DeleteOne(tqa *TestQuestionAnswer) *TestQuestionAnswerDeleteOne {
	return c.DeleteOneID(tqa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TestQuestionAnswerClient) DeleteOneID(id uuid.UUID) *TestQuestionAnswerDeleteOne {
	builder := c.Delete().Where(testquestionanswer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TestQuestionAnswerDeleteOne{builder}
}

// Query returns a query builder for TestQuestionAnswer.
func (c *TestQuestionAnswerClient) Query() *TestQuestionAnswerQuery {
	return &TestQuestionAnswerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTestQuestionAnswer},
		inters: c.Interceptors(),
	}
}

// Get returns a TestQuestionAnswer entity by its id.
func (c *TestQuestionAnswerClient) Get(ctx context.Context, id uuid.UUID) (*TestQuestionAnswer, error) {
	return c.Query().Where(testquestionanswer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TestQuestionAnswerClient) GetX(ctx context.Context, id uuid.UUID) *TestQuestionAnswer {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a TestQuestionAnswer.
func (c *TestQuestionAnswerClient) QueryUser(tqa *TestQuestionAnswer) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tqa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testquestionanswer.Table, testquestionanswer.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, testquestionanswer.UserTable, testquestionanswer.UserColumn),
		)
		fromV = sqlgraph.Neighbors(tqa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuestion queries the question edge of a TestQuestionAnswer.
func (c *TestQuestionAnswerClient) QueryQuestion(tqa *TestQuestionAnswer) *QuestionQuery {
	query := (&QuestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tqa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testquestionanswer.Table, testquestionanswer.FieldID, id),
			sqlgraph.To(question.Table, question.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, testquestionanswer.QuestionTable, testquestionanswer.QuestionColumn),
		)
		fromV = sqlgraph.Neighbors(tqa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySelectedOption queries the selected_option edge of a TestQuestionAnswer.
func (c *TestQuestionAnswerClient) QuerySelectedOption(tqa *TestQuestionAnswer) *QuestionOptionQuery {
	query := (&QuestionOptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tqa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testquestionanswer.Table, testquestionanswer.FieldID, id),
			sqlgraph.To(questionoption.Table, questionoption.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, testquestionanswer.SelectedOptionTable, testquestionanswer.SelectedOptionColumn),
		)
		fromV = sqlgraph.Neighbors(tqa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTestSession queries the test_session edge of a TestQuestionAnswer.
func (c *TestQuestionAnswerClient) QueryTestSession(tqa *TestQuestionAnswer) *TestSessionQuery {
	query := (&TestSessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tqa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testquestionanswer.Table, testquestionanswer.FieldID, id),
			sqlgraph.To(testsession.Table, testsession.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, testquestionanswer.TestSessionTable, testquestionanswer.TestSessionColumn),
		)
		fromV = sqlgraph.Neighbors(tqa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TestQuestionAnswerClient) Hooks() []Hook {
	hooks := c.hooks.TestQuestionAnswer
	return append(hooks[:len(hooks):len(hooks)], testquestionanswer.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TestQuestionAnswerClient) Interceptors() []Interceptor {
	inters := c.inters.TestQuestionAnswer
	return append(inters[:len(inters):len(inters)], testquestionanswer.Interceptors[:]...)
}

func (c *TestQuestionAnswerClient) mutate(ctx context.Context, m *TestQuestionAnswerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TestQuestionAnswerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TestQuestionAnswerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TestQuestionAnswerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TestQuestionAnswerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TestQuestionAnswer mutation op: %q", m.Op())
	}
}

// TestQuestionCountClient is a client for the TestQuestionCount schema.
type TestQuestionCountClient struct {
	config
}

// NewTestQuestionCountClient returns a client for the TestQuestionCount from the given config.
func NewTestQuestionCountClient(c config) *TestQuestionCountClient {
	return &TestQuestionCountClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `testquestioncount.Hooks(f(g(h())))`.
func (c *TestQuestionCountClient) Use(hooks ...Hook) {
	c.hooks.TestQuestionCount = append(c.hooks.TestQuestionCount, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `testquestioncount.Intercept(f(g(h())))`.
func (c *TestQuestionCountClient) Intercept(interceptors ...Interceptor) {
	c.inters.TestQuestionCount = append(c.inters.TestQuestionCount, interceptors...)
}

// Create returns a builder for creating a TestQuestionCount entity.
func (c *TestQuestionCountClient) Create() *TestQuestionCountCreate {
	mutation := newTestQuestionCountMutation(c.config, OpCreate)
	return &TestQuestionCountCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TestQuestionCount entities.
func (c *TestQuestionCountClient) CreateBulk(builders ...*TestQuestionCountCreate) *TestQuestionCountCreateBulk {
	return &TestQuestionCountCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TestQuestionCountClient) MapCreateBulk(slice any, setFunc func(*TestQuestionCountCreate, int)) *TestQuestionCountCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TestQuestionCountCreateBulk{err: fmt.Errorf("calling to TestQuestionCountClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TestQuestionCountCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TestQuestionCountCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TestQuestionCount.
func (c *TestQuestionCountClient) Update() *TestQuestionCountUpdate {
	mutation := newTestQuestionCountMutation(c.config, OpUpdate)
	return &TestQuestionCountUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TestQuestionCountClient) UpdateOne(tqc *TestQuestionCount) *TestQuestionCountUpdateOne {
	mutation := newTestQuestionCountMutation(c.config, OpUpdateOne, withTestQuestionCount(tqc))
	return &TestQuestionCountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TestQuestionCountClient) UpdateOneID(id uuid.UUID) *TestQuestionCountUpdateOne {
	mutation := newTestQuestionCountMutation(c.config, OpUpdateOne, withTestQuestionCountID(id))
	return &TestQuestionCountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TestQuestionCount.
func (c *TestQuestionCountClient) Delete() *TestQuestionCountDelete {
	mutation := newTestQuestionCountMutation(c.config, OpDelete)
	return &TestQuestionCountDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TestQuestionCountClient) DeleteOne(tqc *TestQuestionCount) *TestQuestionCountDeleteOne {
	return c.DeleteOneID(tqc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TestQuestionCountClient) DeleteOneID(id uuid.UUID) *TestQuestionCountDeleteOne {
	builder := c.Delete().Where(testquestioncount.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TestQuestionCountDeleteOne{builder}
}

// Query returns a query builder for TestQuestionCount.
func (c *TestQuestionCountClient) Query() *TestQuestionCountQuery {
	return &TestQuestionCountQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTestQuestionCount},
		inters: c.Interceptors(),
	}
}

// Get returns a TestQuestionCount entity by its id.
func (c *TestQuestionCountClient) Get(ctx context.Context, id uuid.UUID) (*TestQuestionCount, error) {
	return c.Query().Where(testquestioncount.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TestQuestionCountClient) GetX(ctx context.Context, id uuid.UUID) *TestQuestionCount {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTest queries the test edge of a TestQuestionCount.
func (c *TestQuestionCountClient) QueryTest(tqc *TestQuestionCount) *TestQuery {
	query := (&TestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tqc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testquestioncount.Table, testquestioncount.FieldID, id),
			sqlgraph.To(test.Table, test.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, testquestioncount.TestTable, testquestioncount.TestColumn),
		)
		fromV = sqlgraph.Neighbors(tqc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TestQuestionCountClient) Hooks() []Hook {
	hooks := c.hooks.TestQuestionCount
	return append(hooks[:len(hooks):len(hooks)], testquestioncount.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TestQuestionCountClient) Interceptors() []Interceptor {
	inters := c.inters.TestQuestionCount
	return append(inters[:len(inters):len(inters)], testquestioncount.Interceptors[:]...)
}

func (c *TestQuestionCountClient) mutate(ctx context.Context, m *TestQuestionCountMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TestQuestionCountCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TestQuestionCountUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TestQuestionCountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TestQuestionCountDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TestQuestionCount mutation op: %q", m.Op())
	}
}

// TestQuestionPointClient is a client for the TestQuestionPoint schema.
type TestQuestionPointClient struct {
	config
}

// NewTestQuestionPointClient returns a client for the TestQuestionPoint from the given config.
func NewTestQuestionPointClient(c config) *TestQuestionPointClient {
	return &TestQuestionPointClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `testquestionpoint.Hooks(f(g(h())))`.
func (c *TestQuestionPointClient) Use(hooks ...Hook) {
	c.hooks.TestQuestionPoint = append(c.hooks.TestQuestionPoint, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `testquestionpoint.Intercept(f(g(h())))`.
func (c *TestQuestionPointClient) Intercept(interceptors ...Interceptor) {
	c.inters.TestQuestionPoint = append(c.inters.TestQuestionPoint, interceptors...)
}

// Create returns a builder for creating a TestQuestionPoint entity.
func (c *TestQuestionPointClient) Create() *TestQuestionPointCreate {
	mutation := newTestQuestionPointMutation(c.config, OpCreate)
	return &TestQuestionPointCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TestQuestionPoint entities.
func (c *TestQuestionPointClient) CreateBulk(builders ...*TestQuestionPointCreate) *TestQuestionPointCreateBulk {
	return &TestQuestionPointCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TestQuestionPointClient) MapCreateBulk(slice any, setFunc func(*TestQuestionPointCreate, int)) *TestQuestionPointCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TestQuestionPointCreateBulk{err: fmt.Errorf("calling to TestQuestionPointClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TestQuestionPointCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TestQuestionPointCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TestQuestionPoint.
func (c *TestQuestionPointClient) Update() *TestQuestionPointUpdate {
	mutation := newTestQuestionPointMutation(c.config, OpUpdate)
	return &TestQuestionPointUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TestQuestionPointClient) UpdateOne(tqp *TestQuestionPoint) *TestQuestionPointUpdateOne {
	mutation := newTestQuestionPointMutation(c.config, OpUpdateOne, withTestQuestionPoint(tqp))
	return &TestQuestionPointUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TestQuestionPointClient) UpdateOneID(id uuid.UUID) *TestQuestionPointUpdateOne {
	mutation := newTestQuestionPointMutation(c.config, OpUpdateOne, withTestQuestionPointID(id))
	return &TestQuestionPointUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TestQuestionPoint.
func (c *TestQuestionPointClient) Delete() *TestQuestionPointDelete {
	mutation := newTestQuestionPointMutation(c.config, OpDelete)
	return &TestQuestionPointDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TestQuestionPointClient) DeleteOne(tqp *TestQuestionPoint) *TestQuestionPointDeleteOne {
	return c.DeleteOneID(tqp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TestQuestionPointClient) DeleteOneID(id uuid.UUID) *TestQuestionPointDeleteOne {
	builder := c.Delete().Where(testquestionpoint.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TestQuestionPointDeleteOne{builder}
}

// Query returns a query builder for TestQuestionPoint.
func (c *TestQuestionPointClient) Query() *TestQuestionPointQuery {
	return &TestQuestionPointQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTestQuestionPoint},
		inters: c.Interceptors(),
	}
}

// Get returns a TestQuestionPoint entity by its id.
func (c *TestQuestionPointClient) Get(ctx context.Context, id uuid.UUID) (*TestQuestionPoint, error) {
	return c.Query().Where(testquestionpoint.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TestQuestionPointClient) GetX(ctx context.Context, id uuid.UUID) *TestQuestionPoint {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTest queries the test edge of a TestQuestionPoint.
func (c *TestQuestionPointClient) QueryTest(tqp *TestQuestionPoint) *TestQuery {
	query := (&TestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tqp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testquestionpoint.Table, testquestionpoint.FieldID, id),
			sqlgraph.To(test.Table, test.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, testquestionpoint.TestTable, testquestionpoint.TestColumn),
		)
		fromV = sqlgraph.Neighbors(tqp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuestion queries the question edge of a TestQuestionPoint.
func (c *TestQuestionPointClient) QueryQuestion(tqp *TestQuestionPoint) *QuestionQuery {
	query := (&QuestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tqp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testquestionpoint.Table, testquestionpoint.FieldID, id),
			sqlgraph.To(question.Table, question.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, testquestionpoint.QuestionTable, testquestionpoint.QuestionColumn),
		)
		fromV = sqlgraph.Neighbors(tqp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TestQuestionPointClient) Hooks() []Hook {
	hooks := c.hooks.TestQuestionPoint
	return append(hooks[:len(hooks):len(hooks)], testquestionpoint.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TestQuestionPointClient) Interceptors() []Interceptor {
	inters := c.inters.TestQuestionPoint
	return append(inters[:len(inters):len(inters)], testquestionpoint.Interceptors[:]...)
}

func (c *TestQuestionPointClient) mutate(ctx context.Context, m *TestQuestionPointMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TestQuestionPointCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TestQuestionPointUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TestQuestionPointUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TestQuestionPointDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TestQuestionPoint mutation op: %q", m.Op())
	}
}

// TestSessionClient is a client for the TestSession schema.
type TestSessionClient struct {
	config
}

// NewTestSessionClient returns a client for the TestSession from the given config.
func NewTestSessionClient(c config) *TestSessionClient {
	return &TestSessionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `testsession.Hooks(f(g(h())))`.
func (c *TestSessionClient) Use(hooks ...Hook) {
	c.hooks.TestSession = append(c.hooks.TestSession, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `testsession.Intercept(f(g(h())))`.
func (c *TestSessionClient) Intercept(interceptors ...Interceptor) {
	c.inters.TestSession = append(c.inters.TestSession, interceptors...)
}

// Create returns a builder for creating a TestSession entity.
func (c *TestSessionClient) Create() *TestSessionCreate {
	mutation := newTestSessionMutation(c.config, OpCreate)
	return &TestSessionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TestSession entities.
func (c *TestSessionClient) CreateBulk(builders ...*TestSessionCreate) *TestSessionCreateBulk {
	return &TestSessionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TestSessionClient) MapCreateBulk(slice any, setFunc func(*TestSessionCreate, int)) *TestSessionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TestSessionCreateBulk{err: fmt.Errorf("calling to TestSessionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TestSessionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TestSessionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TestSession.
func (c *TestSessionClient) Update() *TestSessionUpdate {
	mutation := newTestSessionMutation(c.config, OpUpdate)
	return &TestSessionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TestSessionClient) UpdateOne(ts *TestSession) *TestSessionUpdateOne {
	mutation := newTestSessionMutation(c.config, OpUpdateOne, withTestSession(ts))
	return &TestSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TestSessionClient) UpdateOneID(id uuid.UUID) *TestSessionUpdateOne {
	mutation := newTestSessionMutation(c.config, OpUpdateOne, withTestSessionID(id))
	return &TestSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TestSession.
func (c *TestSessionClient) Delete() *TestSessionDelete {
	mutation := newTestSessionMutation(c.config, OpDelete)
	return &TestSessionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TestSessionClient) DeleteOne(ts *TestSession) *TestSessionDeleteOne {
	return c.DeleteOneID(ts.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TestSessionClient) DeleteOneID(id uuid.UUID) *TestSessionDeleteOne {
	builder := c.Delete().Where(testsession.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TestSessionDeleteOne{builder}
}

// Query returns a query builder for TestSession.
func (c *TestSessionClient) Query() *TestSessionQuery {
	return &TestSessionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTestSession},
		inters: c.Interceptors(),
	}
}

// Get returns a TestSession entity by its id.
func (c *TestSessionClient) Get(ctx context.Context, id uuid.UUID) (*TestSession, error) {
	return c.Query().Where(testsession.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TestSessionClient) GetX(ctx context.Context, id uuid.UUID) *TestSession {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a TestSession.
func (c *TestSessionClient) QueryUser(ts *TestSession) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ts.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testsession.Table, testsession.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, testsession.UserTable, testsession.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ts.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCourseSection queries the course_section edge of a TestSession.
func (c *TestSessionClient) QueryCourseSection(ts *TestSession) *CourseSectionQuery {
	query := (&CourseSectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ts.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testsession.Table, testsession.FieldID, id),
			sqlgraph.To(coursesection.Table, coursesection.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, testsession.CourseSectionTable, testsession.CourseSectionColumn),
		)
		fromV = sqlgraph.Neighbors(ts.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTest queries the test edge of a TestSession.
func (c *TestSessionClient) QueryTest(ts *TestSession) *TestQuery {
	query := (&TestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ts.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testsession.Table, testsession.FieldID, id),
			sqlgraph.To(test.Table, test.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, testsession.TestTable, testsession.TestColumn),
		)
		fromV = sqlgraph.Neighbors(ts.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserQuestionAnswers queries the user_question_answers edge of a TestSession.
func (c *TestSessionClient) QueryUserQuestionAnswers(ts *TestSession) *TestQuestionAnswerQuery {
	query := (&TestQuestionAnswerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ts.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testsession.Table, testsession.FieldID, id),
			sqlgraph.To(testquestionanswer.Table, testquestionanswer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, testsession.UserQuestionAnswersTable, testsession.UserQuestionAnswersColumn),
		)
		fromV = sqlgraph.Neighbors(ts.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TestSessionClient) Hooks() []Hook {
	hooks := c.hooks.TestSession
	return append(hooks[:len(hooks):len(hooks)], testsession.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TestSessionClient) Interceptors() []Interceptor {
	inters := c.inters.TestSession
	return append(inters[:len(inters):len(inters)], testsession.Interceptors[:]...)
}

func (c *TestSessionClient) mutate(ctx context.Context, m *TestSessionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TestSessionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TestSessionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TestSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TestSessionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TestSession mutation op: %q", m.Op())
	}
}

// TodoClient is a client for the Todo schema.
type TodoClient struct {
	config
}

// NewTodoClient returns a client for the Todo from the given config.
func NewTodoClient(c config) *TodoClient {
	return &TodoClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `todo.Hooks(f(g(h())))`.
func (c *TodoClient) Use(hooks ...Hook) {
	c.hooks.Todo = append(c.hooks.Todo, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `todo.Intercept(f(g(h())))`.
func (c *TodoClient) Intercept(interceptors ...Interceptor) {
	c.inters.Todo = append(c.inters.Todo, interceptors...)
}

// Create returns a builder for creating a Todo entity.
func (c *TodoClient) Create() *TodoCreate {
	mutation := newTodoMutation(c.config, OpCreate)
	return &TodoCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Todo entities.
func (c *TodoClient) CreateBulk(builders ...*TodoCreate) *TodoCreateBulk {
	return &TodoCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TodoClient) MapCreateBulk(slice any, setFunc func(*TodoCreate, int)) *TodoCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TodoCreateBulk{err: fmt.Errorf("calling to TodoClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TodoCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TodoCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Todo.
func (c *TodoClient) Update() *TodoUpdate {
	mutation := newTodoMutation(c.config, OpUpdate)
	return &TodoUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TodoClient) UpdateOne(t *Todo) *TodoUpdateOne {
	mutation := newTodoMutation(c.config, OpUpdateOne, withTodo(t))
	return &TodoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TodoClient) UpdateOneID(id uuid.UUID) *TodoUpdateOne {
	mutation := newTodoMutation(c.config, OpUpdateOne, withTodoID(id))
	return &TodoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Todo.
func (c *TodoClient) Delete() *TodoDelete {
	mutation := newTodoMutation(c.config, OpDelete)
	return &TodoDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TodoClient) DeleteOne(t *Todo) *TodoDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TodoClient) DeleteOneID(id uuid.UUID) *TodoDeleteOne {
	builder := c.Delete().Where(todo.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TodoDeleteOne{builder}
}

// Query returns a query builder for Todo.
func (c *TodoClient) Query() *TodoQuery {
	return &TodoQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTodo},
		inters: c.Interceptors(),
	}
}

// Get returns a Todo entity by its id.
func (c *TodoClient) Get(ctx context.Context, id uuid.UUID) (*Todo, error) {
	return c.Query().Where(todo.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TodoClient) GetX(ctx context.Context, id uuid.UUID) *Todo {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TodoClient) Hooks() []Hook {
	hooks := c.hooks.Todo
	return append(hooks[:len(hooks):len(hooks)], todo.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TodoClient) Interceptors() []Interceptor {
	inters := c.inters.Todo
	return append(inters[:len(inters):len(inters)], todo.Interceptors[:]...)
}

func (c *TodoClient) mutate(ctx context.Context, m *TodoMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TodoCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TodoUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TodoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TodoDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Todo mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id uuid.UUID) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id uuid.UUID) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id uuid.UUID) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id uuid.UUID) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMedia queries the media edge of a User.
func (c *UserClient) QueryMedia(u *User) *MediaQuery {
	query := (&MediaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(media.Table, media.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, user.MediaTable, user.MediaColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMediaUploader queries the media_uploader edge of a User.
func (c *UserClient) QueryMediaUploader(u *User) *MediaQuery {
	query := (&MediaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(media.Table, media.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.MediaUploaderTable, user.MediaUploaderColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRoles queries the roles edge of a User.
func (c *UserClient) QueryRoles(u *User) *RoleQuery {
	query := (&RoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(role.Table, role.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.RolesTable, user.RolesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCourseCreator queries the course_creator edge of a User.
func (c *UserClient) QueryCourseCreator(u *User) *CourseQuery {
	query := (&CourseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(course.Table, course.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CourseCreatorTable, user.CourseCreatorColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuestionCollections queries the question_collections edge of a User.
func (c *UserClient) QueryQuestionCollections(u *User) *QuestionCollectionQuery {
	query := (&QuestionCollectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(questioncollection.Table, questioncollection.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.QuestionCollectionsTable, user.QuestionCollectionsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserQuestionAnswers queries the user_question_answers edge of a User.
func (c *UserClient) QueryUserQuestionAnswers(u *User) *TestQuestionAnswerQuery {
	query := (&TestQuestionAnswerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(testquestionanswer.Table, testquestionanswer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.UserQuestionAnswersTable, user.UserQuestionAnswersColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTestSessions queries the test_sessions edge of a User.
func (c *UserClient) QueryTestSessions(u *User) *TestSessionQuery {
	query := (&TestSessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(testsession.Table, testsession.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.TestSessionsTable, user.TestSessionsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	hooks := c.hooks.User
	return append(hooks[:len(hooks):len(hooks)], user.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	inters := c.inters.User
	return append(inters[:len(inters):len(inters)], user.Interceptors[:]...)
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// VideoClient is a client for the Video schema.
type VideoClient struct {
	config
}

// NewVideoClient returns a client for the Video from the given config.
func NewVideoClient(c config) *VideoClient {
	return &VideoClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `video.Hooks(f(g(h())))`.
func (c *VideoClient) Use(hooks ...Hook) {
	c.hooks.Video = append(c.hooks.Video, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `video.Intercept(f(g(h())))`.
func (c *VideoClient) Intercept(interceptors ...Interceptor) {
	c.inters.Video = append(c.inters.Video, interceptors...)
}

// Create returns a builder for creating a Video entity.
func (c *VideoClient) Create() *VideoCreate {
	mutation := newVideoMutation(c.config, OpCreate)
	return &VideoCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Video entities.
func (c *VideoClient) CreateBulk(builders ...*VideoCreate) *VideoCreateBulk {
	return &VideoCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VideoClient) MapCreateBulk(slice any, setFunc func(*VideoCreate, int)) *VideoCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VideoCreateBulk{err: fmt.Errorf("calling to VideoClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VideoCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VideoCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Video.
func (c *VideoClient) Update() *VideoUpdate {
	mutation := newVideoMutation(c.config, OpUpdate)
	return &VideoUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VideoClient) UpdateOne(v *Video) *VideoUpdateOne {
	mutation := newVideoMutation(c.config, OpUpdateOne, withVideo(v))
	return &VideoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VideoClient) UpdateOneID(id uuid.UUID) *VideoUpdateOne {
	mutation := newVideoMutation(c.config, OpUpdateOne, withVideoID(id))
	return &VideoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Video.
func (c *VideoClient) Delete() *VideoDelete {
	mutation := newVideoMutation(c.config, OpDelete)
	return &VideoDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VideoClient) DeleteOne(v *Video) *VideoDeleteOne {
	return c.DeleteOneID(v.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VideoClient) DeleteOneID(id uuid.UUID) *VideoDeleteOne {
	builder := c.Delete().Where(video.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VideoDeleteOne{builder}
}

// Query returns a query builder for Video.
func (c *VideoClient) Query() *VideoQuery {
	return &VideoQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVideo},
		inters: c.Interceptors(),
	}
}

// Get returns a Video entity by its id.
func (c *VideoClient) Get(ctx context.Context, id uuid.UUID) (*Video, error) {
	return c.Query().Where(video.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VideoClient) GetX(ctx context.Context, id uuid.UUID) *Video {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCourseSection queries the course_section edge of a Video.
func (c *VideoClient) QueryCourseSection(v *Video) *CourseSectionQuery {
	query := (&CourseSectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(video.Table, video.FieldID, id),
			sqlgraph.To(coursesection.Table, coursesection.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, video.CourseSectionTable, video.CourseSectionColumn),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMedia queries the media edge of a Video.
func (c *VideoClient) QueryMedia(v *Video) *MediaQuery {
	query := (&MediaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(video.Table, video.FieldID, id),
			sqlgraph.To(media.Table, media.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, video.MediaTable, video.MediaColumn),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCourse queries the course edge of a Video.
func (c *VideoClient) QueryCourse(v *Video) *CourseQuery {
	query := (&CourseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(video.Table, video.FieldID, id),
			sqlgraph.To(course.Table, course.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, video.CourseTable, video.CourseColumn),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVideoQuestionTimestampsVideo queries the video_question_timestamps_video edge of a Video.
func (c *VideoClient) QueryVideoQuestionTimestampsVideo(v *Video) *VideoQuestionTimestampQuery {
	query := (&VideoQuestionTimestampClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(video.Table, video.FieldID, id),
			sqlgraph.To(videoquestiontimestamp.Table, videoquestiontimestamp.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, video.VideoQuestionTimestampsVideoTable, video.VideoQuestionTimestampsVideoColumn),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VideoClient) Hooks() []Hook {
	hooks := c.hooks.Video
	return append(hooks[:len(hooks):len(hooks)], video.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *VideoClient) Interceptors() []Interceptor {
	inters := c.inters.Video
	return append(inters[:len(inters):len(inters)], video.Interceptors[:]...)
}

func (c *VideoClient) mutate(ctx context.Context, m *VideoMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VideoCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VideoUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VideoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VideoDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Video mutation op: %q", m.Op())
	}
}

// VideoQuestionTimestampClient is a client for the VideoQuestionTimestamp schema.
type VideoQuestionTimestampClient struct {
	config
}

// NewVideoQuestionTimestampClient returns a client for the VideoQuestionTimestamp from the given config.
func NewVideoQuestionTimestampClient(c config) *VideoQuestionTimestampClient {
	return &VideoQuestionTimestampClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `videoquestiontimestamp.Hooks(f(g(h())))`.
func (c *VideoQuestionTimestampClient) Use(hooks ...Hook) {
	c.hooks.VideoQuestionTimestamp = append(c.hooks.VideoQuestionTimestamp, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `videoquestiontimestamp.Intercept(f(g(h())))`.
func (c *VideoQuestionTimestampClient) Intercept(interceptors ...Interceptor) {
	c.inters.VideoQuestionTimestamp = append(c.inters.VideoQuestionTimestamp, interceptors...)
}

// Create returns a builder for creating a VideoQuestionTimestamp entity.
func (c *VideoQuestionTimestampClient) Create() *VideoQuestionTimestampCreate {
	mutation := newVideoQuestionTimestampMutation(c.config, OpCreate)
	return &VideoQuestionTimestampCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VideoQuestionTimestamp entities.
func (c *VideoQuestionTimestampClient) CreateBulk(builders ...*VideoQuestionTimestampCreate) *VideoQuestionTimestampCreateBulk {
	return &VideoQuestionTimestampCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VideoQuestionTimestampClient) MapCreateBulk(slice any, setFunc func(*VideoQuestionTimestampCreate, int)) *VideoQuestionTimestampCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VideoQuestionTimestampCreateBulk{err: fmt.Errorf("calling to VideoQuestionTimestampClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VideoQuestionTimestampCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VideoQuestionTimestampCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VideoQuestionTimestamp.
func (c *VideoQuestionTimestampClient) Update() *VideoQuestionTimestampUpdate {
	mutation := newVideoQuestionTimestampMutation(c.config, OpUpdate)
	return &VideoQuestionTimestampUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VideoQuestionTimestampClient) UpdateOne(vqt *VideoQuestionTimestamp) *VideoQuestionTimestampUpdateOne {
	mutation := newVideoQuestionTimestampMutation(c.config, OpUpdateOne, withVideoQuestionTimestamp(vqt))
	return &VideoQuestionTimestampUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VideoQuestionTimestampClient) UpdateOneID(id uuid.UUID) *VideoQuestionTimestampUpdateOne {
	mutation := newVideoQuestionTimestampMutation(c.config, OpUpdateOne, withVideoQuestionTimestampID(id))
	return &VideoQuestionTimestampUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VideoQuestionTimestamp.
func (c *VideoQuestionTimestampClient) Delete() *VideoQuestionTimestampDelete {
	mutation := newVideoQuestionTimestampMutation(c.config, OpDelete)
	return &VideoQuestionTimestampDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VideoQuestionTimestampClient) DeleteOne(vqt *VideoQuestionTimestamp) *VideoQuestionTimestampDeleteOne {
	return c.DeleteOneID(vqt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VideoQuestionTimestampClient) DeleteOneID(id uuid.UUID) *VideoQuestionTimestampDeleteOne {
	builder := c.Delete().Where(videoquestiontimestamp.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VideoQuestionTimestampDeleteOne{builder}
}

// Query returns a query builder for VideoQuestionTimestamp.
func (c *VideoQuestionTimestampClient) Query() *VideoQuestionTimestampQuery {
	return &VideoQuestionTimestampQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVideoQuestionTimestamp},
		inters: c.Interceptors(),
	}
}

// Get returns a VideoQuestionTimestamp entity by its id.
func (c *VideoQuestionTimestampClient) Get(ctx context.Context, id uuid.UUID) (*VideoQuestionTimestamp, error) {
	return c.Query().Where(videoquestiontimestamp.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VideoQuestionTimestampClient) GetX(ctx context.Context, id uuid.UUID) *VideoQuestionTimestamp {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVideo queries the video edge of a VideoQuestionTimestamp.
func (c *VideoQuestionTimestampClient) QueryVideo(vqt *VideoQuestionTimestamp) *VideoQuery {
	query := (&VideoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vqt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(videoquestiontimestamp.Table, videoquestiontimestamp.FieldID, id),
			sqlgraph.To(video.Table, video.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, videoquestiontimestamp.VideoTable, videoquestiontimestamp.VideoColumn),
		)
		fromV = sqlgraph.Neighbors(vqt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuestion queries the question edge of a VideoQuestionTimestamp.
func (c *VideoQuestionTimestampClient) QueryQuestion(vqt *VideoQuestionTimestamp) *QuestionQuery {
	query := (&QuestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vqt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(videoquestiontimestamp.Table, videoquestiontimestamp.FieldID, id),
			sqlgraph.To(question.Table, question.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, videoquestiontimestamp.QuestionTable, videoquestiontimestamp.QuestionColumn),
		)
		fromV = sqlgraph.Neighbors(vqt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VideoQuestionTimestampClient) Hooks() []Hook {
	hooks := c.hooks.VideoQuestionTimestamp
	return append(hooks[:len(hooks):len(hooks)], videoquestiontimestamp.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *VideoQuestionTimestampClient) Interceptors() []Interceptor {
	inters := c.inters.VideoQuestionTimestamp
	return append(inters[:len(inters):len(inters)], videoquestiontimestamp.Interceptors[:]...)
}

func (c *VideoQuestionTimestampClient) mutate(ctx context.Context, m *VideoQuestionTimestampMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VideoQuestionTimestampCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VideoQuestionTimestampUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VideoQuestionTimestampUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VideoQuestionTimestampDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VideoQuestionTimestamp mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Course, CourseSection, Media, Permission, Question, QuestionCollection,
		QuestionOption, Role, Test, TestIgnoreQuestion, TestQuestionAnswer,
		TestQuestionCount, TestQuestionPoint, TestSession, Todo, User, Video,
		VideoQuestionTimestamp []ent.Hook
	}
	inters struct {
		Course, CourseSection, Media, Permission, Question, QuestionCollection,
		QuestionOption, Role, Test, TestIgnoreQuestion, TestQuestionAnswer,
		TestQuestionCount, TestQuestionPoint, TestSession, Todo, User, Video,
		VideoQuestionTimestamp []ent.Interceptor
	}
)
