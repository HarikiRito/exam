// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"template/internal/ent/migrate"

	"template/internal/ent/course"
	"template/internal/ent/coursesection"
	"template/internal/ent/media"
	"template/internal/ent/permission"
	"template/internal/ent/question"
	"template/internal/ent/questionoption"
	"template/internal/ent/role"
	"template/internal/ent/test"
	"template/internal/ent/testsession"
	"template/internal/ent/todo"
	"template/internal/ent/user"
	"template/internal/ent/userquestionanswer"
	"template/internal/ent/userrole"
	"template/internal/ent/video"
	"template/internal/ent/videoquestiontimestamp"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/google/uuid"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Course is the client for interacting with the Course builders.
	Course *CourseClient
	// CourseSection is the client for interacting with the CourseSection builders.
	CourseSection *CourseSectionClient
	// Media is the client for interacting with the Media builders.
	Media *MediaClient
	// Permission is the client for interacting with the Permission builders.
	Permission *PermissionClient
	// Question is the client for interacting with the Question builders.
	Question *QuestionClient
	// QuestionOption is the client for interacting with the QuestionOption builders.
	QuestionOption *QuestionOptionClient
	// Role is the client for interacting with the Role builders.
	Role *RoleClient
	// Test is the client for interacting with the Test builders.
	Test *TestClient
	// TestSession is the client for interacting with the TestSession builders.
	TestSession *TestSessionClient
	// Todo is the client for interacting with the Todo builders.
	Todo *TodoClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserQuestionAnswer is the client for interacting with the UserQuestionAnswer builders.
	UserQuestionAnswer *UserQuestionAnswerClient
	// UserRole is the client for interacting with the UserRole builders.
	UserRole *UserRoleClient
	// Video is the client for interacting with the Video builders.
	Video *VideoClient
	// VideoQuestionTimestamp is the client for interacting with the VideoQuestionTimestamp builders.
	VideoQuestionTimestamp *VideoQuestionTimestampClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Course = NewCourseClient(c.config)
	c.CourseSection = NewCourseSectionClient(c.config)
	c.Media = NewMediaClient(c.config)
	c.Permission = NewPermissionClient(c.config)
	c.Question = NewQuestionClient(c.config)
	c.QuestionOption = NewQuestionOptionClient(c.config)
	c.Role = NewRoleClient(c.config)
	c.Test = NewTestClient(c.config)
	c.TestSession = NewTestSessionClient(c.config)
	c.Todo = NewTodoClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserQuestionAnswer = NewUserQuestionAnswerClient(c.config)
	c.UserRole = NewUserRoleClient(c.config)
	c.Video = NewVideoClient(c.config)
	c.VideoQuestionTimestamp = NewVideoQuestionTimestampClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                    ctx,
		config:                 cfg,
		Course:                 NewCourseClient(cfg),
		CourseSection:          NewCourseSectionClient(cfg),
		Media:                  NewMediaClient(cfg),
		Permission:             NewPermissionClient(cfg),
		Question:               NewQuestionClient(cfg),
		QuestionOption:         NewQuestionOptionClient(cfg),
		Role:                   NewRoleClient(cfg),
		Test:                   NewTestClient(cfg),
		TestSession:            NewTestSessionClient(cfg),
		Todo:                   NewTodoClient(cfg),
		User:                   NewUserClient(cfg),
		UserQuestionAnswer:     NewUserQuestionAnswerClient(cfg),
		UserRole:               NewUserRoleClient(cfg),
		Video:                  NewVideoClient(cfg),
		VideoQuestionTimestamp: NewVideoQuestionTimestampClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                    ctx,
		config:                 cfg,
		Course:                 NewCourseClient(cfg),
		CourseSection:          NewCourseSectionClient(cfg),
		Media:                  NewMediaClient(cfg),
		Permission:             NewPermissionClient(cfg),
		Question:               NewQuestionClient(cfg),
		QuestionOption:         NewQuestionOptionClient(cfg),
		Role:                   NewRoleClient(cfg),
		Test:                   NewTestClient(cfg),
		TestSession:            NewTestSessionClient(cfg),
		Todo:                   NewTodoClient(cfg),
		User:                   NewUserClient(cfg),
		UserQuestionAnswer:     NewUserQuestionAnswerClient(cfg),
		UserRole:               NewUserRoleClient(cfg),
		Video:                  NewVideoClient(cfg),
		VideoQuestionTimestamp: NewVideoQuestionTimestampClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Course.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Course, c.CourseSection, c.Media, c.Permission, c.Question, c.QuestionOption,
		c.Role, c.Test, c.TestSession, c.Todo, c.User, c.UserQuestionAnswer,
		c.UserRole, c.Video, c.VideoQuestionTimestamp,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Course, c.CourseSection, c.Media, c.Permission, c.Question, c.QuestionOption,
		c.Role, c.Test, c.TestSession, c.Todo, c.User, c.UserQuestionAnswer,
		c.UserRole, c.Video, c.VideoQuestionTimestamp,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *CourseMutation:
		return c.Course.mutate(ctx, m)
	case *CourseSectionMutation:
		return c.CourseSection.mutate(ctx, m)
	case *MediaMutation:
		return c.Media.mutate(ctx, m)
	case *PermissionMutation:
		return c.Permission.mutate(ctx, m)
	case *QuestionMutation:
		return c.Question.mutate(ctx, m)
	case *QuestionOptionMutation:
		return c.QuestionOption.mutate(ctx, m)
	case *RoleMutation:
		return c.Role.mutate(ctx, m)
	case *TestMutation:
		return c.Test.mutate(ctx, m)
	case *TestSessionMutation:
		return c.TestSession.mutate(ctx, m)
	case *TodoMutation:
		return c.Todo.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserQuestionAnswerMutation:
		return c.UserQuestionAnswer.mutate(ctx, m)
	case *UserRoleMutation:
		return c.UserRole.mutate(ctx, m)
	case *VideoMutation:
		return c.Video.mutate(ctx, m)
	case *VideoQuestionTimestampMutation:
		return c.VideoQuestionTimestamp.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// CourseClient is a client for the Course schema.
type CourseClient struct {
	config
}

// NewCourseClient returns a client for the Course from the given config.
func NewCourseClient(c config) *CourseClient {
	return &CourseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `course.Hooks(f(g(h())))`.
func (c *CourseClient) Use(hooks ...Hook) {
	c.hooks.Course = append(c.hooks.Course, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `course.Intercept(f(g(h())))`.
func (c *CourseClient) Intercept(interceptors ...Interceptor) {
	c.inters.Course = append(c.inters.Course, interceptors...)
}

// Create returns a builder for creating a Course entity.
func (c *CourseClient) Create() *CourseCreate {
	mutation := newCourseMutation(c.config, OpCreate)
	return &CourseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Course entities.
func (c *CourseClient) CreateBulk(builders ...*CourseCreate) *CourseCreateBulk {
	return &CourseCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CourseClient) MapCreateBulk(slice any, setFunc func(*CourseCreate, int)) *CourseCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CourseCreateBulk{err: fmt.Errorf("calling to CourseClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CourseCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CourseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Course.
func (c *CourseClient) Update() *CourseUpdate {
	mutation := newCourseMutation(c.config, OpUpdate)
	return &CourseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CourseClient) UpdateOne(co *Course) *CourseUpdateOne {
	mutation := newCourseMutation(c.config, OpUpdateOne, withCourse(co))
	return &CourseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CourseClient) UpdateOneID(id uuid.UUID) *CourseUpdateOne {
	mutation := newCourseMutation(c.config, OpUpdateOne, withCourseID(id))
	return &CourseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Course.
func (c *CourseClient) Delete() *CourseDelete {
	mutation := newCourseMutation(c.config, OpDelete)
	return &CourseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CourseClient) DeleteOne(co *Course) *CourseDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CourseClient) DeleteOneID(id uuid.UUID) *CourseDeleteOne {
	builder := c.Delete().Where(course.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CourseDeleteOne{builder}
}

// Query returns a query builder for Course.
func (c *CourseClient) Query() *CourseQuery {
	return &CourseQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCourse},
		inters: c.Interceptors(),
	}
}

// Get returns a Course entity by its id.
func (c *CourseClient) Get(ctx context.Context, id uuid.UUID) (*Course, error) {
	return c.Query().Where(course.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CourseClient) GetX(ctx context.Context, id uuid.UUID) *Course {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMedia queries the media edge of a Course.
func (c *CourseClient) QueryMedia(co *Course) *MediaQuery {
	query := (&MediaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(course.Table, course.FieldID, id),
			sqlgraph.To(media.Table, media.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, course.MediaTable, course.MediaColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreator queries the creator edge of a Course.
func (c *CourseClient) QueryCreator(co *Course) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(course.Table, course.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, course.CreatorTable, course.CreatorColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCourseSections queries the course_sections edge of a Course.
func (c *CourseClient) QueryCourseSections(co *Course) *CourseSectionQuery {
	query := (&CourseSectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(course.Table, course.FieldID, id),
			sqlgraph.To(coursesection.Table, coursesection.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, course.CourseSectionsTable, course.CourseSectionsColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCourseVideos queries the course_videos edge of a Course.
func (c *CourseClient) QueryCourseVideos(co *Course) *VideoQuery {
	query := (&VideoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(course.Table, course.FieldID, id),
			sqlgraph.To(video.Table, video.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, course.CourseVideosTable, course.CourseVideosColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTests queries the tests edge of a Course.
func (c *CourseClient) QueryTests(co *Course) *TestQuery {
	query := (&TestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(course.Table, course.FieldID, id),
			sqlgraph.To(test.Table, test.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, course.TestsTable, course.TestsColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CourseClient) Hooks() []Hook {
	hooks := c.hooks.Course
	return append(hooks[:len(hooks):len(hooks)], course.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *CourseClient) Interceptors() []Interceptor {
	inters := c.inters.Course
	return append(inters[:len(inters):len(inters)], course.Interceptors[:]...)
}

func (c *CourseClient) mutate(ctx context.Context, m *CourseMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CourseCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CourseUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CourseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CourseDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Course mutation op: %q", m.Op())
	}
}

// CourseSectionClient is a client for the CourseSection schema.
type CourseSectionClient struct {
	config
}

// NewCourseSectionClient returns a client for the CourseSection from the given config.
func NewCourseSectionClient(c config) *CourseSectionClient {
	return &CourseSectionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `coursesection.Hooks(f(g(h())))`.
func (c *CourseSectionClient) Use(hooks ...Hook) {
	c.hooks.CourseSection = append(c.hooks.CourseSection, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `coursesection.Intercept(f(g(h())))`.
func (c *CourseSectionClient) Intercept(interceptors ...Interceptor) {
	c.inters.CourseSection = append(c.inters.CourseSection, interceptors...)
}

// Create returns a builder for creating a CourseSection entity.
func (c *CourseSectionClient) Create() *CourseSectionCreate {
	mutation := newCourseSectionMutation(c.config, OpCreate)
	return &CourseSectionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CourseSection entities.
func (c *CourseSectionClient) CreateBulk(builders ...*CourseSectionCreate) *CourseSectionCreateBulk {
	return &CourseSectionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CourseSectionClient) MapCreateBulk(slice any, setFunc func(*CourseSectionCreate, int)) *CourseSectionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CourseSectionCreateBulk{err: fmt.Errorf("calling to CourseSectionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CourseSectionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CourseSectionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CourseSection.
func (c *CourseSectionClient) Update() *CourseSectionUpdate {
	mutation := newCourseSectionMutation(c.config, OpUpdate)
	return &CourseSectionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CourseSectionClient) UpdateOne(cs *CourseSection) *CourseSectionUpdateOne {
	mutation := newCourseSectionMutation(c.config, OpUpdateOne, withCourseSection(cs))
	return &CourseSectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CourseSectionClient) UpdateOneID(id uuid.UUID) *CourseSectionUpdateOne {
	mutation := newCourseSectionMutation(c.config, OpUpdateOne, withCourseSectionID(id))
	return &CourseSectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CourseSection.
func (c *CourseSectionClient) Delete() *CourseSectionDelete {
	mutation := newCourseSectionMutation(c.config, OpDelete)
	return &CourseSectionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CourseSectionClient) DeleteOne(cs *CourseSection) *CourseSectionDeleteOne {
	return c.DeleteOneID(cs.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CourseSectionClient) DeleteOneID(id uuid.UUID) *CourseSectionDeleteOne {
	builder := c.Delete().Where(coursesection.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CourseSectionDeleteOne{builder}
}

// Query returns a query builder for CourseSection.
func (c *CourseSectionClient) Query() *CourseSectionQuery {
	return &CourseSectionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCourseSection},
		inters: c.Interceptors(),
	}
}

// Get returns a CourseSection entity by its id.
func (c *CourseSectionClient) Get(ctx context.Context, id uuid.UUID) (*CourseSection, error) {
	return c.Query().Where(coursesection.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CourseSectionClient) GetX(ctx context.Context, id uuid.UUID) *CourseSection {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCourse queries the course edge of a CourseSection.
func (c *CourseSectionClient) QueryCourse(cs *CourseSection) *CourseQuery {
	query := (&CourseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(coursesection.Table, coursesection.FieldID, id),
			sqlgraph.To(course.Table, course.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, coursesection.CourseTable, coursesection.CourseColumn),
		)
		fromV = sqlgraph.Neighbors(cs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParent queries the parent edge of a CourseSection.
func (c *CourseSectionClient) QueryParent(cs *CourseSection) *CourseSectionQuery {
	query := (&CourseSectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(coursesection.Table, coursesection.FieldID, id),
			sqlgraph.To(coursesection.Table, coursesection.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, coursesection.ParentTable, coursesection.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(cs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a CourseSection.
func (c *CourseSectionClient) QueryChildren(cs *CourseSection) *CourseSectionQuery {
	query := (&CourseSectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(coursesection.Table, coursesection.FieldID, id),
			sqlgraph.To(coursesection.Table, coursesection.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, coursesection.ChildrenTable, coursesection.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(cs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCourseSectionVideos queries the course_section_videos edge of a CourseSection.
func (c *CourseSectionClient) QueryCourseSectionVideos(cs *CourseSection) *VideoQuery {
	query := (&VideoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(coursesection.Table, coursesection.FieldID, id),
			sqlgraph.To(video.Table, video.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, coursesection.CourseSectionVideosTable, coursesection.CourseSectionVideosColumn),
		)
		fromV = sqlgraph.Neighbors(cs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuestions queries the questions edge of a CourseSection.
func (c *CourseSectionClient) QueryQuestions(cs *CourseSection) *QuestionQuery {
	query := (&QuestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(coursesection.Table, coursesection.FieldID, id),
			sqlgraph.To(question.Table, question.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, coursesection.QuestionsTable, coursesection.QuestionsColumn),
		)
		fromV = sqlgraph.Neighbors(cs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTestSessions queries the test_sessions edge of a CourseSection.
func (c *CourseSectionClient) QueryTestSessions(cs *CourseSection) *TestSessionQuery {
	query := (&TestSessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(coursesection.Table, coursesection.FieldID, id),
			sqlgraph.To(testsession.Table, testsession.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, coursesection.TestSessionsTable, coursesection.TestSessionsColumn),
		)
		fromV = sqlgraph.Neighbors(cs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTests queries the tests edge of a CourseSection.
func (c *CourseSectionClient) QueryTests(cs *CourseSection) *TestQuery {
	query := (&TestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(coursesection.Table, coursesection.FieldID, id),
			sqlgraph.To(test.Table, test.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, coursesection.TestsTable, coursesection.TestsColumn),
		)
		fromV = sqlgraph.Neighbors(cs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CourseSectionClient) Hooks() []Hook {
	hooks := c.hooks.CourseSection
	return append(hooks[:len(hooks):len(hooks)], coursesection.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *CourseSectionClient) Interceptors() []Interceptor {
	inters := c.inters.CourseSection
	return append(inters[:len(inters):len(inters)], coursesection.Interceptors[:]...)
}

func (c *CourseSectionClient) mutate(ctx context.Context, m *CourseSectionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CourseSectionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CourseSectionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CourseSectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CourseSectionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CourseSection mutation op: %q", m.Op())
	}
}

// MediaClient is a client for the Media schema.
type MediaClient struct {
	config
}

// NewMediaClient returns a client for the Media from the given config.
func NewMediaClient(c config) *MediaClient {
	return &MediaClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `media.Hooks(f(g(h())))`.
func (c *MediaClient) Use(hooks ...Hook) {
	c.hooks.Media = append(c.hooks.Media, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `media.Intercept(f(g(h())))`.
func (c *MediaClient) Intercept(interceptors ...Interceptor) {
	c.inters.Media = append(c.inters.Media, interceptors...)
}

// Create returns a builder for creating a Media entity.
func (c *MediaClient) Create() *MediaCreate {
	mutation := newMediaMutation(c.config, OpCreate)
	return &MediaCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Media entities.
func (c *MediaClient) CreateBulk(builders ...*MediaCreate) *MediaCreateBulk {
	return &MediaCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MediaClient) MapCreateBulk(slice any, setFunc func(*MediaCreate, int)) *MediaCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MediaCreateBulk{err: fmt.Errorf("calling to MediaClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MediaCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MediaCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Media.
func (c *MediaClient) Update() *MediaUpdate {
	mutation := newMediaMutation(c.config, OpUpdate)
	return &MediaUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MediaClient) UpdateOne(m *Media) *MediaUpdateOne {
	mutation := newMediaMutation(c.config, OpUpdateOne, withMedia(m))
	return &MediaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MediaClient) UpdateOneID(id uuid.UUID) *MediaUpdateOne {
	mutation := newMediaMutation(c.config, OpUpdateOne, withMediaID(id))
	return &MediaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Media.
func (c *MediaClient) Delete() *MediaDelete {
	mutation := newMediaMutation(c.config, OpDelete)
	return &MediaDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MediaClient) DeleteOne(m *Media) *MediaDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MediaClient) DeleteOneID(id uuid.UUID) *MediaDeleteOne {
	builder := c.Delete().Where(media.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MediaDeleteOne{builder}
}

// Query returns a query builder for Media.
func (c *MediaClient) Query() *MediaQuery {
	return &MediaQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMedia},
		inters: c.Interceptors(),
	}
}

// Get returns a Media entity by its id.
func (c *MediaClient) Get(ctx context.Context, id uuid.UUID) (*Media, error) {
	return c.Query().Where(media.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MediaClient) GetX(ctx context.Context, id uuid.UUID) *Media {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUserMedia queries the user_media edge of a Media.
func (c *MediaClient) QueryUserMedia(m *Media) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(media.Table, media.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, media.UserMediaTable, media.UserMediaColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a Media.
func (c *MediaClient) QueryUser(m *Media) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(media.Table, media.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, media.UserTable, media.UserColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCourseMedia queries the course_media edge of a Media.
func (c *MediaClient) QueryCourseMedia(m *Media) *CourseQuery {
	query := (&CourseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(media.Table, media.FieldID, id),
			sqlgraph.To(course.Table, course.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, media.CourseMediaTable, media.CourseMediaColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVideoMedia queries the video_media edge of a Media.
func (c *MediaClient) QueryVideoMedia(m *Media) *VideoQuery {
	query := (&VideoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(media.Table, media.FieldID, id),
			sqlgraph.To(video.Table, video.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, media.VideoMediaTable, media.VideoMediaColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MediaClient) Hooks() []Hook {
	hooks := c.hooks.Media
	return append(hooks[:len(hooks):len(hooks)], media.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *MediaClient) Interceptors() []Interceptor {
	inters := c.inters.Media
	return append(inters[:len(inters):len(inters)], media.Interceptors[:]...)
}

func (c *MediaClient) mutate(ctx context.Context, m *MediaMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MediaCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MediaUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MediaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MediaDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Media mutation op: %q", m.Op())
	}
}

// PermissionClient is a client for the Permission schema.
type PermissionClient struct {
	config
}

// NewPermissionClient returns a client for the Permission from the given config.
func NewPermissionClient(c config) *PermissionClient {
	return &PermissionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `permission.Hooks(f(g(h())))`.
func (c *PermissionClient) Use(hooks ...Hook) {
	c.hooks.Permission = append(c.hooks.Permission, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `permission.Intercept(f(g(h())))`.
func (c *PermissionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Permission = append(c.inters.Permission, interceptors...)
}

// Create returns a builder for creating a Permission entity.
func (c *PermissionClient) Create() *PermissionCreate {
	mutation := newPermissionMutation(c.config, OpCreate)
	return &PermissionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Permission entities.
func (c *PermissionClient) CreateBulk(builders ...*PermissionCreate) *PermissionCreateBulk {
	return &PermissionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PermissionClient) MapCreateBulk(slice any, setFunc func(*PermissionCreate, int)) *PermissionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PermissionCreateBulk{err: fmt.Errorf("calling to PermissionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PermissionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PermissionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Permission.
func (c *PermissionClient) Update() *PermissionUpdate {
	mutation := newPermissionMutation(c.config, OpUpdate)
	return &PermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PermissionClient) UpdateOne(pe *Permission) *PermissionUpdateOne {
	mutation := newPermissionMutation(c.config, OpUpdateOne, withPermission(pe))
	return &PermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PermissionClient) UpdateOneID(id uuid.UUID) *PermissionUpdateOne {
	mutation := newPermissionMutation(c.config, OpUpdateOne, withPermissionID(id))
	return &PermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Permission.
func (c *PermissionClient) Delete() *PermissionDelete {
	mutation := newPermissionMutation(c.config, OpDelete)
	return &PermissionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PermissionClient) DeleteOne(pe *Permission) *PermissionDeleteOne {
	return c.DeleteOneID(pe.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PermissionClient) DeleteOneID(id uuid.UUID) *PermissionDeleteOne {
	builder := c.Delete().Where(permission.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PermissionDeleteOne{builder}
}

// Query returns a query builder for Permission.
func (c *PermissionClient) Query() *PermissionQuery {
	return &PermissionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePermission},
		inters: c.Interceptors(),
	}
}

// Get returns a Permission entity by its id.
func (c *PermissionClient) Get(ctx context.Context, id uuid.UUID) (*Permission, error) {
	return c.Query().Where(permission.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PermissionClient) GetX(ctx context.Context, id uuid.UUID) *Permission {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRoles queries the roles edge of a Permission.
func (c *PermissionClient) QueryRoles(pe *Permission) *RoleQuery {
	query := (&RoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(permission.Table, permission.FieldID, id),
			sqlgraph.To(role.Table, role.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, permission.RolesTable, permission.RolesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PermissionClient) Hooks() []Hook {
	hooks := c.hooks.Permission
	return append(hooks[:len(hooks):len(hooks)], permission.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *PermissionClient) Interceptors() []Interceptor {
	inters := c.inters.Permission
	return append(inters[:len(inters):len(inters)], permission.Interceptors[:]...)
}

func (c *PermissionClient) mutate(ctx context.Context, m *PermissionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PermissionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PermissionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Permission mutation op: %q", m.Op())
	}
}

// QuestionClient is a client for the Question schema.
type QuestionClient struct {
	config
}

// NewQuestionClient returns a client for the Question from the given config.
func NewQuestionClient(c config) *QuestionClient {
	return &QuestionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `question.Hooks(f(g(h())))`.
func (c *QuestionClient) Use(hooks ...Hook) {
	c.hooks.Question = append(c.hooks.Question, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `question.Intercept(f(g(h())))`.
func (c *QuestionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Question = append(c.inters.Question, interceptors...)
}

// Create returns a builder for creating a Question entity.
func (c *QuestionClient) Create() *QuestionCreate {
	mutation := newQuestionMutation(c.config, OpCreate)
	return &QuestionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Question entities.
func (c *QuestionClient) CreateBulk(builders ...*QuestionCreate) *QuestionCreateBulk {
	return &QuestionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *QuestionClient) MapCreateBulk(slice any, setFunc func(*QuestionCreate, int)) *QuestionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &QuestionCreateBulk{err: fmt.Errorf("calling to QuestionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*QuestionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &QuestionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Question.
func (c *QuestionClient) Update() *QuestionUpdate {
	mutation := newQuestionMutation(c.config, OpUpdate)
	return &QuestionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *QuestionClient) UpdateOne(q *Question) *QuestionUpdateOne {
	mutation := newQuestionMutation(c.config, OpUpdateOne, withQuestion(q))
	return &QuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *QuestionClient) UpdateOneID(id uuid.UUID) *QuestionUpdateOne {
	mutation := newQuestionMutation(c.config, OpUpdateOne, withQuestionID(id))
	return &QuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Question.
func (c *QuestionClient) Delete() *QuestionDelete {
	mutation := newQuestionMutation(c.config, OpDelete)
	return &QuestionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *QuestionClient) DeleteOne(q *Question) *QuestionDeleteOne {
	return c.DeleteOneID(q.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *QuestionClient) DeleteOneID(id uuid.UUID) *QuestionDeleteOne {
	builder := c.Delete().Where(question.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &QuestionDeleteOne{builder}
}

// Query returns a query builder for Question.
func (c *QuestionClient) Query() *QuestionQuery {
	return &QuestionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeQuestion},
		inters: c.Interceptors(),
	}
}

// Get returns a Question entity by its id.
func (c *QuestionClient) Get(ctx context.Context, id uuid.UUID) (*Question, error) {
	return c.Query().Where(question.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *QuestionClient) GetX(ctx context.Context, id uuid.UUID) *Question {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySection queries the section edge of a Question.
func (c *QuestionClient) QuerySection(q *Question) *CourseSectionQuery {
	query := (&CourseSectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := q.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(question.Table, question.FieldID, id),
			sqlgraph.To(coursesection.Table, coursesection.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, question.SectionTable, question.SectionColumn),
		)
		fromV = sqlgraph.Neighbors(q.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuestionOptions queries the question_options edge of a Question.
func (c *QuestionClient) QueryQuestionOptions(q *Question) *QuestionOptionQuery {
	query := (&QuestionOptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := q.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(question.Table, question.FieldID, id),
			sqlgraph.To(questionoption.Table, questionoption.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, question.QuestionOptionsTable, question.QuestionOptionsColumn),
		)
		fromV = sqlgraph.Neighbors(q.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVideoQuestionTimestampsQuestion queries the video_question_timestamps_question edge of a Question.
func (c *QuestionClient) QueryVideoQuestionTimestampsQuestion(q *Question) *VideoQuestionTimestampQuery {
	query := (&VideoQuestionTimestampClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := q.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(question.Table, question.FieldID, id),
			sqlgraph.To(videoquestiontimestamp.Table, videoquestiontimestamp.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, question.VideoQuestionTimestampsQuestionTable, question.VideoQuestionTimestampsQuestionColumn),
		)
		fromV = sqlgraph.Neighbors(q.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserQuestionAnswers queries the user_question_answers edge of a Question.
func (c *QuestionClient) QueryUserQuestionAnswers(q *Question) *UserQuestionAnswerQuery {
	query := (&UserQuestionAnswerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := q.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(question.Table, question.FieldID, id),
			sqlgraph.To(userquestionanswer.Table, userquestionanswer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, question.UserQuestionAnswersTable, question.UserQuestionAnswersColumn),
		)
		fromV = sqlgraph.Neighbors(q.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTests queries the tests edge of a Question.
func (c *QuestionClient) QueryTests(q *Question) *TestQuery {
	query := (&TestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := q.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(question.Table, question.FieldID, id),
			sqlgraph.To(test.Table, test.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, question.TestsTable, question.TestsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(q.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *QuestionClient) Hooks() []Hook {
	hooks := c.hooks.Question
	return append(hooks[:len(hooks):len(hooks)], question.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *QuestionClient) Interceptors() []Interceptor {
	inters := c.inters.Question
	return append(inters[:len(inters):len(inters)], question.Interceptors[:]...)
}

func (c *QuestionClient) mutate(ctx context.Context, m *QuestionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&QuestionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&QuestionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&QuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&QuestionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Question mutation op: %q", m.Op())
	}
}

// QuestionOptionClient is a client for the QuestionOption schema.
type QuestionOptionClient struct {
	config
}

// NewQuestionOptionClient returns a client for the QuestionOption from the given config.
func NewQuestionOptionClient(c config) *QuestionOptionClient {
	return &QuestionOptionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `questionoption.Hooks(f(g(h())))`.
func (c *QuestionOptionClient) Use(hooks ...Hook) {
	c.hooks.QuestionOption = append(c.hooks.QuestionOption, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `questionoption.Intercept(f(g(h())))`.
func (c *QuestionOptionClient) Intercept(interceptors ...Interceptor) {
	c.inters.QuestionOption = append(c.inters.QuestionOption, interceptors...)
}

// Create returns a builder for creating a QuestionOption entity.
func (c *QuestionOptionClient) Create() *QuestionOptionCreate {
	mutation := newQuestionOptionMutation(c.config, OpCreate)
	return &QuestionOptionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of QuestionOption entities.
func (c *QuestionOptionClient) CreateBulk(builders ...*QuestionOptionCreate) *QuestionOptionCreateBulk {
	return &QuestionOptionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *QuestionOptionClient) MapCreateBulk(slice any, setFunc func(*QuestionOptionCreate, int)) *QuestionOptionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &QuestionOptionCreateBulk{err: fmt.Errorf("calling to QuestionOptionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*QuestionOptionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &QuestionOptionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for QuestionOption.
func (c *QuestionOptionClient) Update() *QuestionOptionUpdate {
	mutation := newQuestionOptionMutation(c.config, OpUpdate)
	return &QuestionOptionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *QuestionOptionClient) UpdateOne(qo *QuestionOption) *QuestionOptionUpdateOne {
	mutation := newQuestionOptionMutation(c.config, OpUpdateOne, withQuestionOption(qo))
	return &QuestionOptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *QuestionOptionClient) UpdateOneID(id uuid.UUID) *QuestionOptionUpdateOne {
	mutation := newQuestionOptionMutation(c.config, OpUpdateOne, withQuestionOptionID(id))
	return &QuestionOptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for QuestionOption.
func (c *QuestionOptionClient) Delete() *QuestionOptionDelete {
	mutation := newQuestionOptionMutation(c.config, OpDelete)
	return &QuestionOptionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *QuestionOptionClient) DeleteOne(qo *QuestionOption) *QuestionOptionDeleteOne {
	return c.DeleteOneID(qo.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *QuestionOptionClient) DeleteOneID(id uuid.UUID) *QuestionOptionDeleteOne {
	builder := c.Delete().Where(questionoption.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &QuestionOptionDeleteOne{builder}
}

// Query returns a query builder for QuestionOption.
func (c *QuestionOptionClient) Query() *QuestionOptionQuery {
	return &QuestionOptionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeQuestionOption},
		inters: c.Interceptors(),
	}
}

// Get returns a QuestionOption entity by its id.
func (c *QuestionOptionClient) Get(ctx context.Context, id uuid.UUID) (*QuestionOption, error) {
	return c.Query().Where(questionoption.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *QuestionOptionClient) GetX(ctx context.Context, id uuid.UUID) *QuestionOption {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryQuestion queries the question edge of a QuestionOption.
func (c *QuestionOptionClient) QueryQuestion(qo *QuestionOption) *QuestionQuery {
	query := (&QuestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := qo.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(questionoption.Table, questionoption.FieldID, id),
			sqlgraph.To(question.Table, question.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, questionoption.QuestionTable, questionoption.QuestionColumn),
		)
		fromV = sqlgraph.Neighbors(qo.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserQuestionAnswers queries the user_question_answers edge of a QuestionOption.
func (c *QuestionOptionClient) QueryUserQuestionAnswers(qo *QuestionOption) *UserQuestionAnswerQuery {
	query := (&UserQuestionAnswerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := qo.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(questionoption.Table, questionoption.FieldID, id),
			sqlgraph.To(userquestionanswer.Table, userquestionanswer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, questionoption.UserQuestionAnswersTable, questionoption.UserQuestionAnswersColumn),
		)
		fromV = sqlgraph.Neighbors(qo.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *QuestionOptionClient) Hooks() []Hook {
	hooks := c.hooks.QuestionOption
	return append(hooks[:len(hooks):len(hooks)], questionoption.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *QuestionOptionClient) Interceptors() []Interceptor {
	inters := c.inters.QuestionOption
	return append(inters[:len(inters):len(inters)], questionoption.Interceptors[:]...)
}

func (c *QuestionOptionClient) mutate(ctx context.Context, m *QuestionOptionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&QuestionOptionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&QuestionOptionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&QuestionOptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&QuestionOptionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown QuestionOption mutation op: %q", m.Op())
	}
}

// RoleClient is a client for the Role schema.
type RoleClient struct {
	config
}

// NewRoleClient returns a client for the Role from the given config.
func NewRoleClient(c config) *RoleClient {
	return &RoleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `role.Hooks(f(g(h())))`.
func (c *RoleClient) Use(hooks ...Hook) {
	c.hooks.Role = append(c.hooks.Role, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `role.Intercept(f(g(h())))`.
func (c *RoleClient) Intercept(interceptors ...Interceptor) {
	c.inters.Role = append(c.inters.Role, interceptors...)
}

// Create returns a builder for creating a Role entity.
func (c *RoleClient) Create() *RoleCreate {
	mutation := newRoleMutation(c.config, OpCreate)
	return &RoleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Role entities.
func (c *RoleClient) CreateBulk(builders ...*RoleCreate) *RoleCreateBulk {
	return &RoleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RoleClient) MapCreateBulk(slice any, setFunc func(*RoleCreate, int)) *RoleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RoleCreateBulk{err: fmt.Errorf("calling to RoleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RoleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RoleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Role.
func (c *RoleClient) Update() *RoleUpdate {
	mutation := newRoleMutation(c.config, OpUpdate)
	return &RoleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RoleClient) UpdateOne(r *Role) *RoleUpdateOne {
	mutation := newRoleMutation(c.config, OpUpdateOne, withRole(r))
	return &RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RoleClient) UpdateOneID(id uuid.UUID) *RoleUpdateOne {
	mutation := newRoleMutation(c.config, OpUpdateOne, withRoleID(id))
	return &RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Role.
func (c *RoleClient) Delete() *RoleDelete {
	mutation := newRoleMutation(c.config, OpDelete)
	return &RoleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RoleClient) DeleteOne(r *Role) *RoleDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RoleClient) DeleteOneID(id uuid.UUID) *RoleDeleteOne {
	builder := c.Delete().Where(role.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RoleDeleteOne{builder}
}

// Query returns a query builder for Role.
func (c *RoleClient) Query() *RoleQuery {
	return &RoleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRole},
		inters: c.Interceptors(),
	}
}

// Get returns a Role entity by its id.
func (c *RoleClient) Get(ctx context.Context, id uuid.UUID) (*Role, error) {
	return c.Query().Where(role.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RoleClient) GetX(ctx context.Context, id uuid.UUID) *Role {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUsers queries the users edge of a Role.
func (c *RoleClient) QueryUsers(r *Role) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(role.Table, role.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, role.UsersTable, role.UsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPermissions queries the permissions edge of a Role.
func (c *RoleClient) QueryPermissions(r *Role) *PermissionQuery {
	query := (&PermissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(role.Table, role.FieldID, id),
			sqlgraph.To(permission.Table, permission.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, role.PermissionsTable, role.PermissionsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserRoles queries the user_roles edge of a Role.
func (c *RoleClient) QueryUserRoles(r *Role) *UserRoleQuery {
	query := (&UserRoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(role.Table, role.FieldID, id),
			sqlgraph.To(userrole.Table, userrole.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, role.UserRolesTable, role.UserRolesColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RoleClient) Hooks() []Hook {
	hooks := c.hooks.Role
	return append(hooks[:len(hooks):len(hooks)], role.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *RoleClient) Interceptors() []Interceptor {
	inters := c.inters.Role
	return append(inters[:len(inters):len(inters)], role.Interceptors[:]...)
}

func (c *RoleClient) mutate(ctx context.Context, m *RoleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RoleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RoleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RoleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Role mutation op: %q", m.Op())
	}
}

// TestClient is a client for the Test schema.
type TestClient struct {
	config
}

// NewTestClient returns a client for the Test from the given config.
func NewTestClient(c config) *TestClient {
	return &TestClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `test.Hooks(f(g(h())))`.
func (c *TestClient) Use(hooks ...Hook) {
	c.hooks.Test = append(c.hooks.Test, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `test.Intercept(f(g(h())))`.
func (c *TestClient) Intercept(interceptors ...Interceptor) {
	c.inters.Test = append(c.inters.Test, interceptors...)
}

// Create returns a builder for creating a Test entity.
func (c *TestClient) Create() *TestCreate {
	mutation := newTestMutation(c.config, OpCreate)
	return &TestCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Test entities.
func (c *TestClient) CreateBulk(builders ...*TestCreate) *TestCreateBulk {
	return &TestCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TestClient) MapCreateBulk(slice any, setFunc func(*TestCreate, int)) *TestCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TestCreateBulk{err: fmt.Errorf("calling to TestClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TestCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TestCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Test.
func (c *TestClient) Update() *TestUpdate {
	mutation := newTestMutation(c.config, OpUpdate)
	return &TestUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TestClient) UpdateOne(t *Test) *TestUpdateOne {
	mutation := newTestMutation(c.config, OpUpdateOne, withTest(t))
	return &TestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TestClient) UpdateOneID(id uuid.UUID) *TestUpdateOne {
	mutation := newTestMutation(c.config, OpUpdateOne, withTestID(id))
	return &TestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Test.
func (c *TestClient) Delete() *TestDelete {
	mutation := newTestMutation(c.config, OpDelete)
	return &TestDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TestClient) DeleteOne(t *Test) *TestDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TestClient) DeleteOneID(id uuid.UUID) *TestDeleteOne {
	builder := c.Delete().Where(test.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TestDeleteOne{builder}
}

// Query returns a query builder for Test.
func (c *TestClient) Query() *TestQuery {
	return &TestQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTest},
		inters: c.Interceptors(),
	}
}

// Get returns a Test entity by its id.
func (c *TestClient) Get(ctx context.Context, id uuid.UUID) (*Test, error) {
	return c.Query().Where(test.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TestClient) GetX(ctx context.Context, id uuid.UUID) *Test {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCourseSection queries the course_section edge of a Test.
func (c *TestClient) QueryCourseSection(t *Test) *CourseSectionQuery {
	query := (&CourseSectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(test.Table, test.FieldID, id),
			sqlgraph.To(coursesection.Table, coursesection.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, test.CourseSectionTable, test.CourseSectionColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCourse queries the course edge of a Test.
func (c *TestClient) QueryCourse(t *Test) *CourseQuery {
	query := (&CourseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(test.Table, test.FieldID, id),
			sqlgraph.To(course.Table, course.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, test.CourseTable, test.CourseColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTestSessions queries the test_sessions edge of a Test.
func (c *TestClient) QueryTestSessions(t *Test) *TestSessionQuery {
	query := (&TestSessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(test.Table, test.FieldID, id),
			sqlgraph.To(testsession.Table, testsession.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, test.TestSessionsTable, test.TestSessionsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuestions queries the questions edge of a Test.
func (c *TestClient) QueryQuestions(t *Test) *QuestionQuery {
	query := (&QuestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(test.Table, test.FieldID, id),
			sqlgraph.To(question.Table, question.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, test.QuestionsTable, test.QuestionsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TestClient) Hooks() []Hook {
	hooks := c.hooks.Test
	return append(hooks[:len(hooks):len(hooks)], test.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TestClient) Interceptors() []Interceptor {
	inters := c.inters.Test
	return append(inters[:len(inters):len(inters)], test.Interceptors[:]...)
}

func (c *TestClient) mutate(ctx context.Context, m *TestMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TestCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TestUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TestDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Test mutation op: %q", m.Op())
	}
}

// TestSessionClient is a client for the TestSession schema.
type TestSessionClient struct {
	config
}

// NewTestSessionClient returns a client for the TestSession from the given config.
func NewTestSessionClient(c config) *TestSessionClient {
	return &TestSessionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `testsession.Hooks(f(g(h())))`.
func (c *TestSessionClient) Use(hooks ...Hook) {
	c.hooks.TestSession = append(c.hooks.TestSession, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `testsession.Intercept(f(g(h())))`.
func (c *TestSessionClient) Intercept(interceptors ...Interceptor) {
	c.inters.TestSession = append(c.inters.TestSession, interceptors...)
}

// Create returns a builder for creating a TestSession entity.
func (c *TestSessionClient) Create() *TestSessionCreate {
	mutation := newTestSessionMutation(c.config, OpCreate)
	return &TestSessionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TestSession entities.
func (c *TestSessionClient) CreateBulk(builders ...*TestSessionCreate) *TestSessionCreateBulk {
	return &TestSessionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TestSessionClient) MapCreateBulk(slice any, setFunc func(*TestSessionCreate, int)) *TestSessionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TestSessionCreateBulk{err: fmt.Errorf("calling to TestSessionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TestSessionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TestSessionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TestSession.
func (c *TestSessionClient) Update() *TestSessionUpdate {
	mutation := newTestSessionMutation(c.config, OpUpdate)
	return &TestSessionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TestSessionClient) UpdateOne(ts *TestSession) *TestSessionUpdateOne {
	mutation := newTestSessionMutation(c.config, OpUpdateOne, withTestSession(ts))
	return &TestSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TestSessionClient) UpdateOneID(id uuid.UUID) *TestSessionUpdateOne {
	mutation := newTestSessionMutation(c.config, OpUpdateOne, withTestSessionID(id))
	return &TestSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TestSession.
func (c *TestSessionClient) Delete() *TestSessionDelete {
	mutation := newTestSessionMutation(c.config, OpDelete)
	return &TestSessionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TestSessionClient) DeleteOne(ts *TestSession) *TestSessionDeleteOne {
	return c.DeleteOneID(ts.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TestSessionClient) DeleteOneID(id uuid.UUID) *TestSessionDeleteOne {
	builder := c.Delete().Where(testsession.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TestSessionDeleteOne{builder}
}

// Query returns a query builder for TestSession.
func (c *TestSessionClient) Query() *TestSessionQuery {
	return &TestSessionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTestSession},
		inters: c.Interceptors(),
	}
}

// Get returns a TestSession entity by its id.
func (c *TestSessionClient) Get(ctx context.Context, id uuid.UUID) (*TestSession, error) {
	return c.Query().Where(testsession.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TestSessionClient) GetX(ctx context.Context, id uuid.UUID) *TestSession {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a TestSession.
func (c *TestSessionClient) QueryUser(ts *TestSession) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ts.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testsession.Table, testsession.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, testsession.UserTable, testsession.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ts.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCourseSection queries the course_section edge of a TestSession.
func (c *TestSessionClient) QueryCourseSection(ts *TestSession) *CourseSectionQuery {
	query := (&CourseSectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ts.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testsession.Table, testsession.FieldID, id),
			sqlgraph.To(coursesection.Table, coursesection.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, testsession.CourseSectionTable, testsession.CourseSectionColumn),
		)
		fromV = sqlgraph.Neighbors(ts.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTest queries the test edge of a TestSession.
func (c *TestSessionClient) QueryTest(ts *TestSession) *TestQuery {
	query := (&TestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ts.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testsession.Table, testsession.FieldID, id),
			sqlgraph.To(test.Table, test.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, testsession.TestTable, testsession.TestColumn),
		)
		fromV = sqlgraph.Neighbors(ts.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserQuestionAnswers queries the user_question_answers edge of a TestSession.
func (c *TestSessionClient) QueryUserQuestionAnswers(ts *TestSession) *UserQuestionAnswerQuery {
	query := (&UserQuestionAnswerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ts.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testsession.Table, testsession.FieldID, id),
			sqlgraph.To(userquestionanswer.Table, userquestionanswer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, testsession.UserQuestionAnswersTable, testsession.UserQuestionAnswersColumn),
		)
		fromV = sqlgraph.Neighbors(ts.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TestSessionClient) Hooks() []Hook {
	hooks := c.hooks.TestSession
	return append(hooks[:len(hooks):len(hooks)], testsession.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TestSessionClient) Interceptors() []Interceptor {
	inters := c.inters.TestSession
	return append(inters[:len(inters):len(inters)], testsession.Interceptors[:]...)
}

func (c *TestSessionClient) mutate(ctx context.Context, m *TestSessionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TestSessionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TestSessionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TestSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TestSessionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TestSession mutation op: %q", m.Op())
	}
}

// TodoClient is a client for the Todo schema.
type TodoClient struct {
	config
}

// NewTodoClient returns a client for the Todo from the given config.
func NewTodoClient(c config) *TodoClient {
	return &TodoClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `todo.Hooks(f(g(h())))`.
func (c *TodoClient) Use(hooks ...Hook) {
	c.hooks.Todo = append(c.hooks.Todo, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `todo.Intercept(f(g(h())))`.
func (c *TodoClient) Intercept(interceptors ...Interceptor) {
	c.inters.Todo = append(c.inters.Todo, interceptors...)
}

// Create returns a builder for creating a Todo entity.
func (c *TodoClient) Create() *TodoCreate {
	mutation := newTodoMutation(c.config, OpCreate)
	return &TodoCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Todo entities.
func (c *TodoClient) CreateBulk(builders ...*TodoCreate) *TodoCreateBulk {
	return &TodoCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TodoClient) MapCreateBulk(slice any, setFunc func(*TodoCreate, int)) *TodoCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TodoCreateBulk{err: fmt.Errorf("calling to TodoClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TodoCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TodoCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Todo.
func (c *TodoClient) Update() *TodoUpdate {
	mutation := newTodoMutation(c.config, OpUpdate)
	return &TodoUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TodoClient) UpdateOne(t *Todo) *TodoUpdateOne {
	mutation := newTodoMutation(c.config, OpUpdateOne, withTodo(t))
	return &TodoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TodoClient) UpdateOneID(id uuid.UUID) *TodoUpdateOne {
	mutation := newTodoMutation(c.config, OpUpdateOne, withTodoID(id))
	return &TodoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Todo.
func (c *TodoClient) Delete() *TodoDelete {
	mutation := newTodoMutation(c.config, OpDelete)
	return &TodoDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TodoClient) DeleteOne(t *Todo) *TodoDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TodoClient) DeleteOneID(id uuid.UUID) *TodoDeleteOne {
	builder := c.Delete().Where(todo.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TodoDeleteOne{builder}
}

// Query returns a query builder for Todo.
func (c *TodoClient) Query() *TodoQuery {
	return &TodoQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTodo},
		inters: c.Interceptors(),
	}
}

// Get returns a Todo entity by its id.
func (c *TodoClient) Get(ctx context.Context, id uuid.UUID) (*Todo, error) {
	return c.Query().Where(todo.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TodoClient) GetX(ctx context.Context, id uuid.UUID) *Todo {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TodoClient) Hooks() []Hook {
	hooks := c.hooks.Todo
	return append(hooks[:len(hooks):len(hooks)], todo.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TodoClient) Interceptors() []Interceptor {
	inters := c.inters.Todo
	return append(inters[:len(inters):len(inters)], todo.Interceptors[:]...)
}

func (c *TodoClient) mutate(ctx context.Context, m *TodoMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TodoCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TodoUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TodoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TodoDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Todo mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id uuid.UUID) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id uuid.UUID) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id uuid.UUID) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id uuid.UUID) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMedia queries the media edge of a User.
func (c *UserClient) QueryMedia(u *User) *MediaQuery {
	query := (&MediaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(media.Table, media.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, user.MediaTable, user.MediaColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMediaUploader queries the media_uploader edge of a User.
func (c *UserClient) QueryMediaUploader(u *User) *MediaQuery {
	query := (&MediaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(media.Table, media.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.MediaUploaderTable, user.MediaUploaderColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRoles queries the roles edge of a User.
func (c *UserClient) QueryRoles(u *User) *RoleQuery {
	query := (&RoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(role.Table, role.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, user.RolesTable, user.RolesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCourseCreator queries the course_creator edge of a User.
func (c *UserClient) QueryCourseCreator(u *User) *CourseQuery {
	query := (&CourseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(course.Table, course.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CourseCreatorTable, user.CourseCreatorColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserQuestionAnswers queries the user_question_answers edge of a User.
func (c *UserClient) QueryUserQuestionAnswers(u *User) *UserQuestionAnswerQuery {
	query := (&UserQuestionAnswerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userquestionanswer.Table, userquestionanswer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.UserQuestionAnswersTable, user.UserQuestionAnswersColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTestSessions queries the test_sessions edge of a User.
func (c *UserClient) QueryTestSessions(u *User) *TestSessionQuery {
	query := (&TestSessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(testsession.Table, testsession.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.TestSessionsTable, user.TestSessionsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserRoles queries the user_roles edge of a User.
func (c *UserClient) QueryUserRoles(u *User) *UserRoleQuery {
	query := (&UserRoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userrole.Table, userrole.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.UserRolesTable, user.UserRolesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	hooks := c.hooks.User
	return append(hooks[:len(hooks):len(hooks)], user.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	inters := c.inters.User
	return append(inters[:len(inters):len(inters)], user.Interceptors[:]...)
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// UserQuestionAnswerClient is a client for the UserQuestionAnswer schema.
type UserQuestionAnswerClient struct {
	config
}

// NewUserQuestionAnswerClient returns a client for the UserQuestionAnswer from the given config.
func NewUserQuestionAnswerClient(c config) *UserQuestionAnswerClient {
	return &UserQuestionAnswerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userquestionanswer.Hooks(f(g(h())))`.
func (c *UserQuestionAnswerClient) Use(hooks ...Hook) {
	c.hooks.UserQuestionAnswer = append(c.hooks.UserQuestionAnswer, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userquestionanswer.Intercept(f(g(h())))`.
func (c *UserQuestionAnswerClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserQuestionAnswer = append(c.inters.UserQuestionAnswer, interceptors...)
}

// Create returns a builder for creating a UserQuestionAnswer entity.
func (c *UserQuestionAnswerClient) Create() *UserQuestionAnswerCreate {
	mutation := newUserQuestionAnswerMutation(c.config, OpCreate)
	return &UserQuestionAnswerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserQuestionAnswer entities.
func (c *UserQuestionAnswerClient) CreateBulk(builders ...*UserQuestionAnswerCreate) *UserQuestionAnswerCreateBulk {
	return &UserQuestionAnswerCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserQuestionAnswerClient) MapCreateBulk(slice any, setFunc func(*UserQuestionAnswerCreate, int)) *UserQuestionAnswerCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserQuestionAnswerCreateBulk{err: fmt.Errorf("calling to UserQuestionAnswerClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserQuestionAnswerCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserQuestionAnswerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserQuestionAnswer.
func (c *UserQuestionAnswerClient) Update() *UserQuestionAnswerUpdate {
	mutation := newUserQuestionAnswerMutation(c.config, OpUpdate)
	return &UserQuestionAnswerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserQuestionAnswerClient) UpdateOne(uqa *UserQuestionAnswer) *UserQuestionAnswerUpdateOne {
	mutation := newUserQuestionAnswerMutation(c.config, OpUpdateOne, withUserQuestionAnswer(uqa))
	return &UserQuestionAnswerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserQuestionAnswerClient) UpdateOneID(id uuid.UUID) *UserQuestionAnswerUpdateOne {
	mutation := newUserQuestionAnswerMutation(c.config, OpUpdateOne, withUserQuestionAnswerID(id))
	return &UserQuestionAnswerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserQuestionAnswer.
func (c *UserQuestionAnswerClient) Delete() *UserQuestionAnswerDelete {
	mutation := newUserQuestionAnswerMutation(c.config, OpDelete)
	return &UserQuestionAnswerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserQuestionAnswerClient) DeleteOne(uqa *UserQuestionAnswer) *UserQuestionAnswerDeleteOne {
	return c.DeleteOneID(uqa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserQuestionAnswerClient) DeleteOneID(id uuid.UUID) *UserQuestionAnswerDeleteOne {
	builder := c.Delete().Where(userquestionanswer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserQuestionAnswerDeleteOne{builder}
}

// Query returns a query builder for UserQuestionAnswer.
func (c *UserQuestionAnswerClient) Query() *UserQuestionAnswerQuery {
	return &UserQuestionAnswerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserQuestionAnswer},
		inters: c.Interceptors(),
	}
}

// Get returns a UserQuestionAnswer entity by its id.
func (c *UserQuestionAnswerClient) Get(ctx context.Context, id uuid.UUID) (*UserQuestionAnswer, error) {
	return c.Query().Where(userquestionanswer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserQuestionAnswerClient) GetX(ctx context.Context, id uuid.UUID) *UserQuestionAnswer {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserQuestionAnswer.
func (c *UserQuestionAnswerClient) QueryUser(uqa *UserQuestionAnswer) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := uqa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userquestionanswer.Table, userquestionanswer.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userquestionanswer.UserTable, userquestionanswer.UserColumn),
		)
		fromV = sqlgraph.Neighbors(uqa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuestion queries the question edge of a UserQuestionAnswer.
func (c *UserQuestionAnswerClient) QueryQuestion(uqa *UserQuestionAnswer) *QuestionQuery {
	query := (&QuestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := uqa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userquestionanswer.Table, userquestionanswer.FieldID, id),
			sqlgraph.To(question.Table, question.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userquestionanswer.QuestionTable, userquestionanswer.QuestionColumn),
		)
		fromV = sqlgraph.Neighbors(uqa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySelectedOption queries the selected_option edge of a UserQuestionAnswer.
func (c *UserQuestionAnswerClient) QuerySelectedOption(uqa *UserQuestionAnswer) *QuestionOptionQuery {
	query := (&QuestionOptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := uqa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userquestionanswer.Table, userquestionanswer.FieldID, id),
			sqlgraph.To(questionoption.Table, questionoption.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userquestionanswer.SelectedOptionTable, userquestionanswer.SelectedOptionColumn),
		)
		fromV = sqlgraph.Neighbors(uqa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTestSession queries the test_session edge of a UserQuestionAnswer.
func (c *UserQuestionAnswerClient) QueryTestSession(uqa *UserQuestionAnswer) *TestSessionQuery {
	query := (&TestSessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := uqa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userquestionanswer.Table, userquestionanswer.FieldID, id),
			sqlgraph.To(testsession.Table, testsession.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userquestionanswer.TestSessionTable, userquestionanswer.TestSessionColumn),
		)
		fromV = sqlgraph.Neighbors(uqa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserQuestionAnswerClient) Hooks() []Hook {
	hooks := c.hooks.UserQuestionAnswer
	return append(hooks[:len(hooks):len(hooks)], userquestionanswer.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *UserQuestionAnswerClient) Interceptors() []Interceptor {
	inters := c.inters.UserQuestionAnswer
	return append(inters[:len(inters):len(inters)], userquestionanswer.Interceptors[:]...)
}

func (c *UserQuestionAnswerClient) mutate(ctx context.Context, m *UserQuestionAnswerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserQuestionAnswerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserQuestionAnswerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserQuestionAnswerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserQuestionAnswerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserQuestionAnswer mutation op: %q", m.Op())
	}
}

// UserRoleClient is a client for the UserRole schema.
type UserRoleClient struct {
	config
}

// NewUserRoleClient returns a client for the UserRole from the given config.
func NewUserRoleClient(c config) *UserRoleClient {
	return &UserRoleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userrole.Hooks(f(g(h())))`.
func (c *UserRoleClient) Use(hooks ...Hook) {
	c.hooks.UserRole = append(c.hooks.UserRole, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userrole.Intercept(f(g(h())))`.
func (c *UserRoleClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserRole = append(c.inters.UserRole, interceptors...)
}

// Create returns a builder for creating a UserRole entity.
func (c *UserRoleClient) Create() *UserRoleCreate {
	mutation := newUserRoleMutation(c.config, OpCreate)
	return &UserRoleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserRole entities.
func (c *UserRoleClient) CreateBulk(builders ...*UserRoleCreate) *UserRoleCreateBulk {
	return &UserRoleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserRoleClient) MapCreateBulk(slice any, setFunc func(*UserRoleCreate, int)) *UserRoleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserRoleCreateBulk{err: fmt.Errorf("calling to UserRoleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserRoleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserRoleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserRole.
func (c *UserRoleClient) Update() *UserRoleUpdate {
	mutation := newUserRoleMutation(c.config, OpUpdate)
	return &UserRoleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserRoleClient) UpdateOne(ur *UserRole) *UserRoleUpdateOne {
	mutation := newUserRoleMutation(c.config, OpUpdateOne, withUserRole(ur))
	return &UserRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserRoleClient) UpdateOneID(id uuid.UUID) *UserRoleUpdateOne {
	mutation := newUserRoleMutation(c.config, OpUpdateOne, withUserRoleID(id))
	return &UserRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserRole.
func (c *UserRoleClient) Delete() *UserRoleDelete {
	mutation := newUserRoleMutation(c.config, OpDelete)
	return &UserRoleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserRoleClient) DeleteOne(ur *UserRole) *UserRoleDeleteOne {
	return c.DeleteOneID(ur.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserRoleClient) DeleteOneID(id uuid.UUID) *UserRoleDeleteOne {
	builder := c.Delete().Where(userrole.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserRoleDeleteOne{builder}
}

// Query returns a query builder for UserRole.
func (c *UserRoleClient) Query() *UserRoleQuery {
	return &UserRoleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserRole},
		inters: c.Interceptors(),
	}
}

// Get returns a UserRole entity by its id.
func (c *UserRoleClient) Get(ctx context.Context, id uuid.UUID) (*UserRole, error) {
	return c.Query().Where(userrole.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserRoleClient) GetX(ctx context.Context, id uuid.UUID) *UserRole {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserRole.
func (c *UserRoleClient) QueryUser(ur *UserRole) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ur.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userrole.Table, userrole.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, userrole.UserTable, userrole.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ur.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRole queries the role edge of a UserRole.
func (c *UserRoleClient) QueryRole(ur *UserRole) *RoleQuery {
	query := (&RoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ur.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userrole.Table, userrole.FieldID, id),
			sqlgraph.To(role.Table, role.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, userrole.RoleTable, userrole.RoleColumn),
		)
		fromV = sqlgraph.Neighbors(ur.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserRoleClient) Hooks() []Hook {
	hooks := c.hooks.UserRole
	return append(hooks[:len(hooks):len(hooks)], userrole.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *UserRoleClient) Interceptors() []Interceptor {
	inters := c.inters.UserRole
	return append(inters[:len(inters):len(inters)], userrole.Interceptors[:]...)
}

func (c *UserRoleClient) mutate(ctx context.Context, m *UserRoleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserRoleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserRoleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserRoleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserRole mutation op: %q", m.Op())
	}
}

// VideoClient is a client for the Video schema.
type VideoClient struct {
	config
}

// NewVideoClient returns a client for the Video from the given config.
func NewVideoClient(c config) *VideoClient {
	return &VideoClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `video.Hooks(f(g(h())))`.
func (c *VideoClient) Use(hooks ...Hook) {
	c.hooks.Video = append(c.hooks.Video, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `video.Intercept(f(g(h())))`.
func (c *VideoClient) Intercept(interceptors ...Interceptor) {
	c.inters.Video = append(c.inters.Video, interceptors...)
}

// Create returns a builder for creating a Video entity.
func (c *VideoClient) Create() *VideoCreate {
	mutation := newVideoMutation(c.config, OpCreate)
	return &VideoCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Video entities.
func (c *VideoClient) CreateBulk(builders ...*VideoCreate) *VideoCreateBulk {
	return &VideoCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VideoClient) MapCreateBulk(slice any, setFunc func(*VideoCreate, int)) *VideoCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VideoCreateBulk{err: fmt.Errorf("calling to VideoClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VideoCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VideoCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Video.
func (c *VideoClient) Update() *VideoUpdate {
	mutation := newVideoMutation(c.config, OpUpdate)
	return &VideoUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VideoClient) UpdateOne(v *Video) *VideoUpdateOne {
	mutation := newVideoMutation(c.config, OpUpdateOne, withVideo(v))
	return &VideoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VideoClient) UpdateOneID(id uuid.UUID) *VideoUpdateOne {
	mutation := newVideoMutation(c.config, OpUpdateOne, withVideoID(id))
	return &VideoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Video.
func (c *VideoClient) Delete() *VideoDelete {
	mutation := newVideoMutation(c.config, OpDelete)
	return &VideoDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VideoClient) DeleteOne(v *Video) *VideoDeleteOne {
	return c.DeleteOneID(v.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VideoClient) DeleteOneID(id uuid.UUID) *VideoDeleteOne {
	builder := c.Delete().Where(video.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VideoDeleteOne{builder}
}

// Query returns a query builder for Video.
func (c *VideoClient) Query() *VideoQuery {
	return &VideoQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVideo},
		inters: c.Interceptors(),
	}
}

// Get returns a Video entity by its id.
func (c *VideoClient) Get(ctx context.Context, id uuid.UUID) (*Video, error) {
	return c.Query().Where(video.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VideoClient) GetX(ctx context.Context, id uuid.UUID) *Video {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCourseSection queries the course_section edge of a Video.
func (c *VideoClient) QueryCourseSection(v *Video) *CourseSectionQuery {
	query := (&CourseSectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(video.Table, video.FieldID, id),
			sqlgraph.To(coursesection.Table, coursesection.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, video.CourseSectionTable, video.CourseSectionColumn),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMedia queries the media edge of a Video.
func (c *VideoClient) QueryMedia(v *Video) *MediaQuery {
	query := (&MediaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(video.Table, video.FieldID, id),
			sqlgraph.To(media.Table, media.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, video.MediaTable, video.MediaColumn),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCourse queries the course edge of a Video.
func (c *VideoClient) QueryCourse(v *Video) *CourseQuery {
	query := (&CourseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(video.Table, video.FieldID, id),
			sqlgraph.To(course.Table, course.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, video.CourseTable, video.CourseColumn),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVideoQuestionTimestampsVideo queries the video_question_timestamps_video edge of a Video.
func (c *VideoClient) QueryVideoQuestionTimestampsVideo(v *Video) *VideoQuestionTimestampQuery {
	query := (&VideoQuestionTimestampClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(video.Table, video.FieldID, id),
			sqlgraph.To(videoquestiontimestamp.Table, videoquestiontimestamp.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, video.VideoQuestionTimestampsVideoTable, video.VideoQuestionTimestampsVideoColumn),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VideoClient) Hooks() []Hook {
	hooks := c.hooks.Video
	return append(hooks[:len(hooks):len(hooks)], video.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *VideoClient) Interceptors() []Interceptor {
	inters := c.inters.Video
	return append(inters[:len(inters):len(inters)], video.Interceptors[:]...)
}

func (c *VideoClient) mutate(ctx context.Context, m *VideoMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VideoCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VideoUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VideoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VideoDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Video mutation op: %q", m.Op())
	}
}

// VideoQuestionTimestampClient is a client for the VideoQuestionTimestamp schema.
type VideoQuestionTimestampClient struct {
	config
}

// NewVideoQuestionTimestampClient returns a client for the VideoQuestionTimestamp from the given config.
func NewVideoQuestionTimestampClient(c config) *VideoQuestionTimestampClient {
	return &VideoQuestionTimestampClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `videoquestiontimestamp.Hooks(f(g(h())))`.
func (c *VideoQuestionTimestampClient) Use(hooks ...Hook) {
	c.hooks.VideoQuestionTimestamp = append(c.hooks.VideoQuestionTimestamp, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `videoquestiontimestamp.Intercept(f(g(h())))`.
func (c *VideoQuestionTimestampClient) Intercept(interceptors ...Interceptor) {
	c.inters.VideoQuestionTimestamp = append(c.inters.VideoQuestionTimestamp, interceptors...)
}

// Create returns a builder for creating a VideoQuestionTimestamp entity.
func (c *VideoQuestionTimestampClient) Create() *VideoQuestionTimestampCreate {
	mutation := newVideoQuestionTimestampMutation(c.config, OpCreate)
	return &VideoQuestionTimestampCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VideoQuestionTimestamp entities.
func (c *VideoQuestionTimestampClient) CreateBulk(builders ...*VideoQuestionTimestampCreate) *VideoQuestionTimestampCreateBulk {
	return &VideoQuestionTimestampCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VideoQuestionTimestampClient) MapCreateBulk(slice any, setFunc func(*VideoQuestionTimestampCreate, int)) *VideoQuestionTimestampCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VideoQuestionTimestampCreateBulk{err: fmt.Errorf("calling to VideoQuestionTimestampClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VideoQuestionTimestampCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VideoQuestionTimestampCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VideoQuestionTimestamp.
func (c *VideoQuestionTimestampClient) Update() *VideoQuestionTimestampUpdate {
	mutation := newVideoQuestionTimestampMutation(c.config, OpUpdate)
	return &VideoQuestionTimestampUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VideoQuestionTimestampClient) UpdateOne(vqt *VideoQuestionTimestamp) *VideoQuestionTimestampUpdateOne {
	mutation := newVideoQuestionTimestampMutation(c.config, OpUpdateOne, withVideoQuestionTimestamp(vqt))
	return &VideoQuestionTimestampUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VideoQuestionTimestampClient) UpdateOneID(id uuid.UUID) *VideoQuestionTimestampUpdateOne {
	mutation := newVideoQuestionTimestampMutation(c.config, OpUpdateOne, withVideoQuestionTimestampID(id))
	return &VideoQuestionTimestampUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VideoQuestionTimestamp.
func (c *VideoQuestionTimestampClient) Delete() *VideoQuestionTimestampDelete {
	mutation := newVideoQuestionTimestampMutation(c.config, OpDelete)
	return &VideoQuestionTimestampDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VideoQuestionTimestampClient) DeleteOne(vqt *VideoQuestionTimestamp) *VideoQuestionTimestampDeleteOne {
	return c.DeleteOneID(vqt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VideoQuestionTimestampClient) DeleteOneID(id uuid.UUID) *VideoQuestionTimestampDeleteOne {
	builder := c.Delete().Where(videoquestiontimestamp.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VideoQuestionTimestampDeleteOne{builder}
}

// Query returns a query builder for VideoQuestionTimestamp.
func (c *VideoQuestionTimestampClient) Query() *VideoQuestionTimestampQuery {
	return &VideoQuestionTimestampQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVideoQuestionTimestamp},
		inters: c.Interceptors(),
	}
}

// Get returns a VideoQuestionTimestamp entity by its id.
func (c *VideoQuestionTimestampClient) Get(ctx context.Context, id uuid.UUID) (*VideoQuestionTimestamp, error) {
	return c.Query().Where(videoquestiontimestamp.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VideoQuestionTimestampClient) GetX(ctx context.Context, id uuid.UUID) *VideoQuestionTimestamp {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVideo queries the video edge of a VideoQuestionTimestamp.
func (c *VideoQuestionTimestampClient) QueryVideo(vqt *VideoQuestionTimestamp) *VideoQuery {
	query := (&VideoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vqt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(videoquestiontimestamp.Table, videoquestiontimestamp.FieldID, id),
			sqlgraph.To(video.Table, video.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, videoquestiontimestamp.VideoTable, videoquestiontimestamp.VideoColumn),
		)
		fromV = sqlgraph.Neighbors(vqt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuestion queries the question edge of a VideoQuestionTimestamp.
func (c *VideoQuestionTimestampClient) QueryQuestion(vqt *VideoQuestionTimestamp) *QuestionQuery {
	query := (&QuestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vqt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(videoquestiontimestamp.Table, videoquestiontimestamp.FieldID, id),
			sqlgraph.To(question.Table, question.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, videoquestiontimestamp.QuestionTable, videoquestiontimestamp.QuestionColumn),
		)
		fromV = sqlgraph.Neighbors(vqt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VideoQuestionTimestampClient) Hooks() []Hook {
	hooks := c.hooks.VideoQuestionTimestamp
	return append(hooks[:len(hooks):len(hooks)], videoquestiontimestamp.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *VideoQuestionTimestampClient) Interceptors() []Interceptor {
	inters := c.inters.VideoQuestionTimestamp
	return append(inters[:len(inters):len(inters)], videoquestiontimestamp.Interceptors[:]...)
}

func (c *VideoQuestionTimestampClient) mutate(ctx context.Context, m *VideoQuestionTimestampMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VideoQuestionTimestampCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VideoQuestionTimestampUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VideoQuestionTimestampUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VideoQuestionTimestampDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VideoQuestionTimestamp mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Course, CourseSection, Media, Permission, Question, QuestionOption, Role, Test,
		TestSession, Todo, User, UserQuestionAnswer, UserRole, Video,
		VideoQuestionTimestamp []ent.Hook
	}
	inters struct {
		Course, CourseSection, Media, Permission, Question, QuestionOption, Role, Test,
		TestSession, Todo, User, UserQuestionAnswer, UserRole, Video,
		VideoQuestionTimestamp []ent.Interceptor
	}
)
