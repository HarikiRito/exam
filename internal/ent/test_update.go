// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"template/internal/ent/course"
	"template/internal/ent/coursesection"
	"template/internal/ent/predicate"
	"template/internal/ent/question"
	"template/internal/ent/questioncollection"
	"template/internal/ent/test"
	"template/internal/ent/testignorequestion"
	"template/internal/ent/testquestioncount"
	"template/internal/ent/testquestionpoint"
	"template/internal/ent/testsession"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/google/uuid"
)

// TestUpdate is the builder for updating Test entities.
type TestUpdate struct {
	config
	hooks    []Hook
	mutation *TestMutation
}

// Where appends a list predicates to the TestUpdate builder.
func (tu *TestUpdate) Where(ps ...predicate.Test) *TestUpdate {
	tu.mutation.Where(ps...)
	return tu
}

// SetCreatedAt sets the "created_at" field.
func (tu *TestUpdate) SetCreatedAt(t time.Time) *TestUpdate {
	tu.mutation.SetCreatedAt(t)
	return tu
}

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (tu *TestUpdate) SetNillableCreatedAt(t *time.Time) *TestUpdate {
	if t != nil {
		tu.SetCreatedAt(*t)
	}
	return tu
}

// SetUpdatedAt sets the "updated_at" field.
func (tu *TestUpdate) SetUpdatedAt(t time.Time) *TestUpdate {
	tu.mutation.SetUpdatedAt(t)
	return tu
}

// SetDeletedAt sets the "deleted_at" field.
func (tu *TestUpdate) SetDeletedAt(t time.Time) *TestUpdate {
	tu.mutation.SetDeletedAt(t)
	return tu
}

// SetNillableDeletedAt sets the "deleted_at" field if the given value is not nil.
func (tu *TestUpdate) SetNillableDeletedAt(t *time.Time) *TestUpdate {
	if t != nil {
		tu.SetDeletedAt(*t)
	}
	return tu
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (tu *TestUpdate) ClearDeletedAt() *TestUpdate {
	tu.mutation.ClearDeletedAt()
	return tu
}

// SetName sets the "name" field.
func (tu *TestUpdate) SetName(s string) *TestUpdate {
	tu.mutation.SetName(s)
	return tu
}

// SetNillableName sets the "name" field if the given value is not nil.
func (tu *TestUpdate) SetNillableName(s *string) *TestUpdate {
	if s != nil {
		tu.SetName(*s)
	}
	return tu
}

// SetCourseSectionID sets the "course_section_id" field.
func (tu *TestUpdate) SetCourseSectionID(u uuid.UUID) *TestUpdate {
	tu.mutation.SetCourseSectionID(u)
	return tu
}

// SetNillableCourseSectionID sets the "course_section_id" field if the given value is not nil.
func (tu *TestUpdate) SetNillableCourseSectionID(u *uuid.UUID) *TestUpdate {
	if u != nil {
		tu.SetCourseSectionID(*u)
	}
	return tu
}

// ClearCourseSectionID clears the value of the "course_section_id" field.
func (tu *TestUpdate) ClearCourseSectionID() *TestUpdate {
	tu.mutation.ClearCourseSectionID()
	return tu
}

// SetCourseID sets the "course_id" field.
func (tu *TestUpdate) SetCourseID(u uuid.UUID) *TestUpdate {
	tu.mutation.SetCourseID(u)
	return tu
}

// SetNillableCourseID sets the "course_id" field if the given value is not nil.
func (tu *TestUpdate) SetNillableCourseID(u *uuid.UUID) *TestUpdate {
	if u != nil {
		tu.SetCourseID(*u)
	}
	return tu
}

// ClearCourseID clears the value of the "course_id" field.
func (tu *TestUpdate) ClearCourseID() *TestUpdate {
	tu.mutation.ClearCourseID()
	return tu
}

// SetTotalPoints sets the "total_points" field.
func (tu *TestUpdate) SetTotalPoints(i int) *TestUpdate {
	tu.mutation.ResetTotalPoints()
	tu.mutation.SetTotalPoints(i)
	return tu
}

// SetNillableTotalPoints sets the "total_points" field if the given value is not nil.
func (tu *TestUpdate) SetNillableTotalPoints(i *int) *TestUpdate {
	if i != nil {
		tu.SetTotalPoints(*i)
	}
	return tu
}

// AddTotalPoints adds i to the "total_points" field.
func (tu *TestUpdate) AddTotalPoints(i int) *TestUpdate {
	tu.mutation.AddTotalPoints(i)
	return tu
}

// SetCourseSection sets the "course_section" edge to the CourseSection entity.
func (tu *TestUpdate) SetCourseSection(c *CourseSection) *TestUpdate {
	return tu.SetCourseSectionID(c.ID)
}

// SetCourse sets the "course" edge to the Course entity.
func (tu *TestUpdate) SetCourse(c *Course) *TestUpdate {
	return tu.SetCourseID(c.ID)
}

// AddTestSessionIDs adds the "test_sessions" edge to the TestSession entity by IDs.
func (tu *TestUpdate) AddTestSessionIDs(ids ...uuid.UUID) *TestUpdate {
	tu.mutation.AddTestSessionIDs(ids...)
	return tu
}

// AddTestSessions adds the "test_sessions" edges to the TestSession entity.
func (tu *TestUpdate) AddTestSessions(t ...*TestSession) *TestUpdate {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tu.AddTestSessionIDs(ids...)
}

// AddQuestionIDs adds the "questions" edge to the Question entity by IDs.
func (tu *TestUpdate) AddQuestionIDs(ids ...uuid.UUID) *TestUpdate {
	tu.mutation.AddQuestionIDs(ids...)
	return tu
}

// AddQuestions adds the "questions" edges to the Question entity.
func (tu *TestUpdate) AddQuestions(q ...*Question) *TestUpdate {
	ids := make([]uuid.UUID, len(q))
	for i := range q {
		ids[i] = q[i].ID
	}
	return tu.AddQuestionIDs(ids...)
}

// AddQuestionCollectionIDs adds the "question_collections" edge to the QuestionCollection entity by IDs.
func (tu *TestUpdate) AddQuestionCollectionIDs(ids ...uuid.UUID) *TestUpdate {
	tu.mutation.AddQuestionCollectionIDs(ids...)
	return tu
}

// AddQuestionCollections adds the "question_collections" edges to the QuestionCollection entity.
func (tu *TestUpdate) AddQuestionCollections(q ...*QuestionCollection) *TestUpdate {
	ids := make([]uuid.UUID, len(q))
	for i := range q {
		ids[i] = q[i].ID
	}
	return tu.AddQuestionCollectionIDs(ids...)
}

// AddTestQuestionCountIDs adds the "test_question_counts" edge to the TestQuestionCount entity by IDs.
func (tu *TestUpdate) AddTestQuestionCountIDs(ids ...uuid.UUID) *TestUpdate {
	tu.mutation.AddTestQuestionCountIDs(ids...)
	return tu
}

// AddTestQuestionCounts adds the "test_question_counts" edges to the TestQuestionCount entity.
func (tu *TestUpdate) AddTestQuestionCounts(t ...*TestQuestionCount) *TestUpdate {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tu.AddTestQuestionCountIDs(ids...)
}

// AddTestIgnoreQuestionIDs adds the "test_ignore_questions" edge to the TestIgnoreQuestion entity by IDs.
func (tu *TestUpdate) AddTestIgnoreQuestionIDs(ids ...uuid.UUID) *TestUpdate {
	tu.mutation.AddTestIgnoreQuestionIDs(ids...)
	return tu
}

// AddTestIgnoreQuestions adds the "test_ignore_questions" edges to the TestIgnoreQuestion entity.
func (tu *TestUpdate) AddTestIgnoreQuestions(t ...*TestIgnoreQuestion) *TestUpdate {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tu.AddTestIgnoreQuestionIDs(ids...)
}

// AddTestQuestionPointIDs adds the "test_question_points" edge to the TestQuestionPoint entity by IDs.
func (tu *TestUpdate) AddTestQuestionPointIDs(ids ...uuid.UUID) *TestUpdate {
	tu.mutation.AddTestQuestionPointIDs(ids...)
	return tu
}

// AddTestQuestionPoints adds the "test_question_points" edges to the TestQuestionPoint entity.
func (tu *TestUpdate) AddTestQuestionPoints(t ...*TestQuestionPoint) *TestUpdate {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tu.AddTestQuestionPointIDs(ids...)
}

// Mutation returns the TestMutation object of the builder.
func (tu *TestUpdate) Mutation() *TestMutation {
	return tu.mutation
}

// ClearCourseSection clears the "course_section" edge to the CourseSection entity.
func (tu *TestUpdate) ClearCourseSection() *TestUpdate {
	tu.mutation.ClearCourseSection()
	return tu
}

// ClearCourse clears the "course" edge to the Course entity.
func (tu *TestUpdate) ClearCourse() *TestUpdate {
	tu.mutation.ClearCourse()
	return tu
}

// ClearTestSessions clears all "test_sessions" edges to the TestSession entity.
func (tu *TestUpdate) ClearTestSessions() *TestUpdate {
	tu.mutation.ClearTestSessions()
	return tu
}

// RemoveTestSessionIDs removes the "test_sessions" edge to TestSession entities by IDs.
func (tu *TestUpdate) RemoveTestSessionIDs(ids ...uuid.UUID) *TestUpdate {
	tu.mutation.RemoveTestSessionIDs(ids...)
	return tu
}

// RemoveTestSessions removes "test_sessions" edges to TestSession entities.
func (tu *TestUpdate) RemoveTestSessions(t ...*TestSession) *TestUpdate {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tu.RemoveTestSessionIDs(ids...)
}

// ClearQuestions clears all "questions" edges to the Question entity.
func (tu *TestUpdate) ClearQuestions() *TestUpdate {
	tu.mutation.ClearQuestions()
	return tu
}

// RemoveQuestionIDs removes the "questions" edge to Question entities by IDs.
func (tu *TestUpdate) RemoveQuestionIDs(ids ...uuid.UUID) *TestUpdate {
	tu.mutation.RemoveQuestionIDs(ids...)
	return tu
}

// RemoveQuestions removes "questions" edges to Question entities.
func (tu *TestUpdate) RemoveQuestions(q ...*Question) *TestUpdate {
	ids := make([]uuid.UUID, len(q))
	for i := range q {
		ids[i] = q[i].ID
	}
	return tu.RemoveQuestionIDs(ids...)
}

// ClearQuestionCollections clears all "question_collections" edges to the QuestionCollection entity.
func (tu *TestUpdate) ClearQuestionCollections() *TestUpdate {
	tu.mutation.ClearQuestionCollections()
	return tu
}

// RemoveQuestionCollectionIDs removes the "question_collections" edge to QuestionCollection entities by IDs.
func (tu *TestUpdate) RemoveQuestionCollectionIDs(ids ...uuid.UUID) *TestUpdate {
	tu.mutation.RemoveQuestionCollectionIDs(ids...)
	return tu
}

// RemoveQuestionCollections removes "question_collections" edges to QuestionCollection entities.
func (tu *TestUpdate) RemoveQuestionCollections(q ...*QuestionCollection) *TestUpdate {
	ids := make([]uuid.UUID, len(q))
	for i := range q {
		ids[i] = q[i].ID
	}
	return tu.RemoveQuestionCollectionIDs(ids...)
}

// ClearTestQuestionCounts clears all "test_question_counts" edges to the TestQuestionCount entity.
func (tu *TestUpdate) ClearTestQuestionCounts() *TestUpdate {
	tu.mutation.ClearTestQuestionCounts()
	return tu
}

// RemoveTestQuestionCountIDs removes the "test_question_counts" edge to TestQuestionCount entities by IDs.
func (tu *TestUpdate) RemoveTestQuestionCountIDs(ids ...uuid.UUID) *TestUpdate {
	tu.mutation.RemoveTestQuestionCountIDs(ids...)
	return tu
}

// RemoveTestQuestionCounts removes "test_question_counts" edges to TestQuestionCount entities.
func (tu *TestUpdate) RemoveTestQuestionCounts(t ...*TestQuestionCount) *TestUpdate {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tu.RemoveTestQuestionCountIDs(ids...)
}

// ClearTestIgnoreQuestions clears all "test_ignore_questions" edges to the TestIgnoreQuestion entity.
func (tu *TestUpdate) ClearTestIgnoreQuestions() *TestUpdate {
	tu.mutation.ClearTestIgnoreQuestions()
	return tu
}

// RemoveTestIgnoreQuestionIDs removes the "test_ignore_questions" edge to TestIgnoreQuestion entities by IDs.
func (tu *TestUpdate) RemoveTestIgnoreQuestionIDs(ids ...uuid.UUID) *TestUpdate {
	tu.mutation.RemoveTestIgnoreQuestionIDs(ids...)
	return tu
}

// RemoveTestIgnoreQuestions removes "test_ignore_questions" edges to TestIgnoreQuestion entities.
func (tu *TestUpdate) RemoveTestIgnoreQuestions(t ...*TestIgnoreQuestion) *TestUpdate {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tu.RemoveTestIgnoreQuestionIDs(ids...)
}

// ClearTestQuestionPoints clears all "test_question_points" edges to the TestQuestionPoint entity.
func (tu *TestUpdate) ClearTestQuestionPoints() *TestUpdate {
	tu.mutation.ClearTestQuestionPoints()
	return tu
}

// RemoveTestQuestionPointIDs removes the "test_question_points" edge to TestQuestionPoint entities by IDs.
func (tu *TestUpdate) RemoveTestQuestionPointIDs(ids ...uuid.UUID) *TestUpdate {
	tu.mutation.RemoveTestQuestionPointIDs(ids...)
	return tu
}

// RemoveTestQuestionPoints removes "test_question_points" edges to TestQuestionPoint entities.
func (tu *TestUpdate) RemoveTestQuestionPoints(t ...*TestQuestionPoint) *TestUpdate {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tu.RemoveTestQuestionPointIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (tu *TestUpdate) Save(ctx context.Context) (int, error) {
	if err := tu.defaults(); err != nil {
		return 0, err
	}
	return withHooks(ctx, tu.sqlSave, tu.mutation, tu.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (tu *TestUpdate) SaveX(ctx context.Context) int {
	affected, err := tu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (tu *TestUpdate) Exec(ctx context.Context) error {
	_, err := tu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (tu *TestUpdate) ExecX(ctx context.Context) {
	if err := tu.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (tu *TestUpdate) defaults() error {
	if _, ok := tu.mutation.UpdatedAt(); !ok {
		if test.UpdateDefaultUpdatedAt == nil {
			return fmt.Errorf("ent: uninitialized test.UpdateDefaultUpdatedAt (forgotten import ent/runtime?)")
		}
		v := test.UpdateDefaultUpdatedAt()
		tu.mutation.SetUpdatedAt(v)
	}
	return nil
}

// check runs all checks and user-defined validators on the builder.
func (tu *TestUpdate) check() error {
	if v, ok := tu.mutation.Name(); ok {
		if err := test.NameValidator(v); err != nil {
			return &ValidationError{Name: "name", err: fmt.Errorf(`ent: validator failed for field "Test.name": %w`, err)}
		}
	}
	if v, ok := tu.mutation.TotalPoints(); ok {
		if err := test.TotalPointsValidator(v); err != nil {
			return &ValidationError{Name: "total_points", err: fmt.Errorf(`ent: validator failed for field "Test.total_points": %w`, err)}
		}
	}
	return nil
}

func (tu *TestUpdate) sqlSave(ctx context.Context) (n int, err error) {
	if err := tu.check(); err != nil {
		return n, err
	}
	_spec := sqlgraph.NewUpdateSpec(test.Table, test.Columns, sqlgraph.NewFieldSpec(test.FieldID, field.TypeUUID))
	if ps := tu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := tu.mutation.CreatedAt(); ok {
		_spec.SetField(test.FieldCreatedAt, field.TypeTime, value)
	}
	if value, ok := tu.mutation.UpdatedAt(); ok {
		_spec.SetField(test.FieldUpdatedAt, field.TypeTime, value)
	}
	if value, ok := tu.mutation.DeletedAt(); ok {
		_spec.SetField(test.FieldDeletedAt, field.TypeTime, value)
	}
	if tu.mutation.DeletedAtCleared() {
		_spec.ClearField(test.FieldDeletedAt, field.TypeTime)
	}
	if value, ok := tu.mutation.Name(); ok {
		_spec.SetField(test.FieldName, field.TypeString, value)
	}
	if value, ok := tu.mutation.TotalPoints(); ok {
		_spec.SetField(test.FieldTotalPoints, field.TypeInt, value)
	}
	if value, ok := tu.mutation.AddedTotalPoints(); ok {
		_spec.AddField(test.FieldTotalPoints, field.TypeInt, value)
	}
	if tu.mutation.CourseSectionCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   test.CourseSectionTable,
			Columns: []string{test.CourseSectionColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(coursesection.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tu.mutation.CourseSectionIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   test.CourseSectionTable,
			Columns: []string{test.CourseSectionColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(coursesection.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tu.mutation.CourseCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   test.CourseTable,
			Columns: []string{test.CourseColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(course.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tu.mutation.CourseIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   test.CourseTable,
			Columns: []string{test.CourseColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(course.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tu.mutation.TestSessionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   test.TestSessionsTable,
			Columns: []string{test.TestSessionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(testsession.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tu.mutation.RemovedTestSessionsIDs(); len(nodes) > 0 && !tu.mutation.TestSessionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   test.TestSessionsTable,
			Columns: []string{test.TestSessionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(testsession.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tu.mutation.TestSessionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   test.TestSessionsTable,
			Columns: []string{test.TestSessionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(testsession.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tu.mutation.QuestionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   test.QuestionsTable,
			Columns: test.QuestionsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(question.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tu.mutation.RemovedQuestionsIDs(); len(nodes) > 0 && !tu.mutation.QuestionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   test.QuestionsTable,
			Columns: test.QuestionsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(question.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tu.mutation.QuestionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   test.QuestionsTable,
			Columns: test.QuestionsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(question.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tu.mutation.QuestionCollectionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   test.QuestionCollectionsTable,
			Columns: test.QuestionCollectionsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(questioncollection.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tu.mutation.RemovedQuestionCollectionsIDs(); len(nodes) > 0 && !tu.mutation.QuestionCollectionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   test.QuestionCollectionsTable,
			Columns: test.QuestionCollectionsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(questioncollection.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tu.mutation.QuestionCollectionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   test.QuestionCollectionsTable,
			Columns: test.QuestionCollectionsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(questioncollection.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tu.mutation.TestQuestionCountsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   test.TestQuestionCountsTable,
			Columns: []string{test.TestQuestionCountsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(testquestioncount.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tu.mutation.RemovedTestQuestionCountsIDs(); len(nodes) > 0 && !tu.mutation.TestQuestionCountsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   test.TestQuestionCountsTable,
			Columns: []string{test.TestQuestionCountsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(testquestioncount.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tu.mutation.TestQuestionCountsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   test.TestQuestionCountsTable,
			Columns: []string{test.TestQuestionCountsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(testquestioncount.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tu.mutation.TestIgnoreQuestionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   test.TestIgnoreQuestionsTable,
			Columns: []string{test.TestIgnoreQuestionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(testignorequestion.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tu.mutation.RemovedTestIgnoreQuestionsIDs(); len(nodes) > 0 && !tu.mutation.TestIgnoreQuestionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   test.TestIgnoreQuestionsTable,
			Columns: []string{test.TestIgnoreQuestionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(testignorequestion.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tu.mutation.TestIgnoreQuestionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   test.TestIgnoreQuestionsTable,
			Columns: []string{test.TestIgnoreQuestionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(testignorequestion.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tu.mutation.TestQuestionPointsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   test.TestQuestionPointsTable,
			Columns: []string{test.TestQuestionPointsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(testquestionpoint.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tu.mutation.RemovedTestQuestionPointsIDs(); len(nodes) > 0 && !tu.mutation.TestQuestionPointsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   test.TestQuestionPointsTable,
			Columns: []string{test.TestQuestionPointsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(testquestionpoint.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tu.mutation.TestQuestionPointsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   test.TestQuestionPointsTable,
			Columns: []string{test.TestQuestionPointsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(testquestionpoint.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, tu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{test.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	tu.mutation.done = true
	return n, nil
}

// TestUpdateOne is the builder for updating a single Test entity.
type TestUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *TestMutation
}

// SetCreatedAt sets the "created_at" field.
func (tuo *TestUpdateOne) SetCreatedAt(t time.Time) *TestUpdateOne {
	tuo.mutation.SetCreatedAt(t)
	return tuo
}

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (tuo *TestUpdateOne) SetNillableCreatedAt(t *time.Time) *TestUpdateOne {
	if t != nil {
		tuo.SetCreatedAt(*t)
	}
	return tuo
}

// SetUpdatedAt sets the "updated_at" field.
func (tuo *TestUpdateOne) SetUpdatedAt(t time.Time) *TestUpdateOne {
	tuo.mutation.SetUpdatedAt(t)
	return tuo
}

// SetDeletedAt sets the "deleted_at" field.
func (tuo *TestUpdateOne) SetDeletedAt(t time.Time) *TestUpdateOne {
	tuo.mutation.SetDeletedAt(t)
	return tuo
}

// SetNillableDeletedAt sets the "deleted_at" field if the given value is not nil.
func (tuo *TestUpdateOne) SetNillableDeletedAt(t *time.Time) *TestUpdateOne {
	if t != nil {
		tuo.SetDeletedAt(*t)
	}
	return tuo
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (tuo *TestUpdateOne) ClearDeletedAt() *TestUpdateOne {
	tuo.mutation.ClearDeletedAt()
	return tuo
}

// SetName sets the "name" field.
func (tuo *TestUpdateOne) SetName(s string) *TestUpdateOne {
	tuo.mutation.SetName(s)
	return tuo
}

// SetNillableName sets the "name" field if the given value is not nil.
func (tuo *TestUpdateOne) SetNillableName(s *string) *TestUpdateOne {
	if s != nil {
		tuo.SetName(*s)
	}
	return tuo
}

// SetCourseSectionID sets the "course_section_id" field.
func (tuo *TestUpdateOne) SetCourseSectionID(u uuid.UUID) *TestUpdateOne {
	tuo.mutation.SetCourseSectionID(u)
	return tuo
}

// SetNillableCourseSectionID sets the "course_section_id" field if the given value is not nil.
func (tuo *TestUpdateOne) SetNillableCourseSectionID(u *uuid.UUID) *TestUpdateOne {
	if u != nil {
		tuo.SetCourseSectionID(*u)
	}
	return tuo
}

// ClearCourseSectionID clears the value of the "course_section_id" field.
func (tuo *TestUpdateOne) ClearCourseSectionID() *TestUpdateOne {
	tuo.mutation.ClearCourseSectionID()
	return tuo
}

// SetCourseID sets the "course_id" field.
func (tuo *TestUpdateOne) SetCourseID(u uuid.UUID) *TestUpdateOne {
	tuo.mutation.SetCourseID(u)
	return tuo
}

// SetNillableCourseID sets the "course_id" field if the given value is not nil.
func (tuo *TestUpdateOne) SetNillableCourseID(u *uuid.UUID) *TestUpdateOne {
	if u != nil {
		tuo.SetCourseID(*u)
	}
	return tuo
}

// ClearCourseID clears the value of the "course_id" field.
func (tuo *TestUpdateOne) ClearCourseID() *TestUpdateOne {
	tuo.mutation.ClearCourseID()
	return tuo
}

// SetTotalPoints sets the "total_points" field.
func (tuo *TestUpdateOne) SetTotalPoints(i int) *TestUpdateOne {
	tuo.mutation.ResetTotalPoints()
	tuo.mutation.SetTotalPoints(i)
	return tuo
}

// SetNillableTotalPoints sets the "total_points" field if the given value is not nil.
func (tuo *TestUpdateOne) SetNillableTotalPoints(i *int) *TestUpdateOne {
	if i != nil {
		tuo.SetTotalPoints(*i)
	}
	return tuo
}

// AddTotalPoints adds i to the "total_points" field.
func (tuo *TestUpdateOne) AddTotalPoints(i int) *TestUpdateOne {
	tuo.mutation.AddTotalPoints(i)
	return tuo
}

// SetCourseSection sets the "course_section" edge to the CourseSection entity.
func (tuo *TestUpdateOne) SetCourseSection(c *CourseSection) *TestUpdateOne {
	return tuo.SetCourseSectionID(c.ID)
}

// SetCourse sets the "course" edge to the Course entity.
func (tuo *TestUpdateOne) SetCourse(c *Course) *TestUpdateOne {
	return tuo.SetCourseID(c.ID)
}

// AddTestSessionIDs adds the "test_sessions" edge to the TestSession entity by IDs.
func (tuo *TestUpdateOne) AddTestSessionIDs(ids ...uuid.UUID) *TestUpdateOne {
	tuo.mutation.AddTestSessionIDs(ids...)
	return tuo
}

// AddTestSessions adds the "test_sessions" edges to the TestSession entity.
func (tuo *TestUpdateOne) AddTestSessions(t ...*TestSession) *TestUpdateOne {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tuo.AddTestSessionIDs(ids...)
}

// AddQuestionIDs adds the "questions" edge to the Question entity by IDs.
func (tuo *TestUpdateOne) AddQuestionIDs(ids ...uuid.UUID) *TestUpdateOne {
	tuo.mutation.AddQuestionIDs(ids...)
	return tuo
}

// AddQuestions adds the "questions" edges to the Question entity.
func (tuo *TestUpdateOne) AddQuestions(q ...*Question) *TestUpdateOne {
	ids := make([]uuid.UUID, len(q))
	for i := range q {
		ids[i] = q[i].ID
	}
	return tuo.AddQuestionIDs(ids...)
}

// AddQuestionCollectionIDs adds the "question_collections" edge to the QuestionCollection entity by IDs.
func (tuo *TestUpdateOne) AddQuestionCollectionIDs(ids ...uuid.UUID) *TestUpdateOne {
	tuo.mutation.AddQuestionCollectionIDs(ids...)
	return tuo
}

// AddQuestionCollections adds the "question_collections" edges to the QuestionCollection entity.
func (tuo *TestUpdateOne) AddQuestionCollections(q ...*QuestionCollection) *TestUpdateOne {
	ids := make([]uuid.UUID, len(q))
	for i := range q {
		ids[i] = q[i].ID
	}
	return tuo.AddQuestionCollectionIDs(ids...)
}

// AddTestQuestionCountIDs adds the "test_question_counts" edge to the TestQuestionCount entity by IDs.
func (tuo *TestUpdateOne) AddTestQuestionCountIDs(ids ...uuid.UUID) *TestUpdateOne {
	tuo.mutation.AddTestQuestionCountIDs(ids...)
	return tuo
}

// AddTestQuestionCounts adds the "test_question_counts" edges to the TestQuestionCount entity.
func (tuo *TestUpdateOne) AddTestQuestionCounts(t ...*TestQuestionCount) *TestUpdateOne {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tuo.AddTestQuestionCountIDs(ids...)
}

// AddTestIgnoreQuestionIDs adds the "test_ignore_questions" edge to the TestIgnoreQuestion entity by IDs.
func (tuo *TestUpdateOne) AddTestIgnoreQuestionIDs(ids ...uuid.UUID) *TestUpdateOne {
	tuo.mutation.AddTestIgnoreQuestionIDs(ids...)
	return tuo
}

// AddTestIgnoreQuestions adds the "test_ignore_questions" edges to the TestIgnoreQuestion entity.
func (tuo *TestUpdateOne) AddTestIgnoreQuestions(t ...*TestIgnoreQuestion) *TestUpdateOne {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tuo.AddTestIgnoreQuestionIDs(ids...)
}

// AddTestQuestionPointIDs adds the "test_question_points" edge to the TestQuestionPoint entity by IDs.
func (tuo *TestUpdateOne) AddTestQuestionPointIDs(ids ...uuid.UUID) *TestUpdateOne {
	tuo.mutation.AddTestQuestionPointIDs(ids...)
	return tuo
}

// AddTestQuestionPoints adds the "test_question_points" edges to the TestQuestionPoint entity.
func (tuo *TestUpdateOne) AddTestQuestionPoints(t ...*TestQuestionPoint) *TestUpdateOne {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tuo.AddTestQuestionPointIDs(ids...)
}

// Mutation returns the TestMutation object of the builder.
func (tuo *TestUpdateOne) Mutation() *TestMutation {
	return tuo.mutation
}

// ClearCourseSection clears the "course_section" edge to the CourseSection entity.
func (tuo *TestUpdateOne) ClearCourseSection() *TestUpdateOne {
	tuo.mutation.ClearCourseSection()
	return tuo
}

// ClearCourse clears the "course" edge to the Course entity.
func (tuo *TestUpdateOne) ClearCourse() *TestUpdateOne {
	tuo.mutation.ClearCourse()
	return tuo
}

// ClearTestSessions clears all "test_sessions" edges to the TestSession entity.
func (tuo *TestUpdateOne) ClearTestSessions() *TestUpdateOne {
	tuo.mutation.ClearTestSessions()
	return tuo
}

// RemoveTestSessionIDs removes the "test_sessions" edge to TestSession entities by IDs.
func (tuo *TestUpdateOne) RemoveTestSessionIDs(ids ...uuid.UUID) *TestUpdateOne {
	tuo.mutation.RemoveTestSessionIDs(ids...)
	return tuo
}

// RemoveTestSessions removes "test_sessions" edges to TestSession entities.
func (tuo *TestUpdateOne) RemoveTestSessions(t ...*TestSession) *TestUpdateOne {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tuo.RemoveTestSessionIDs(ids...)
}

// ClearQuestions clears all "questions" edges to the Question entity.
func (tuo *TestUpdateOne) ClearQuestions() *TestUpdateOne {
	tuo.mutation.ClearQuestions()
	return tuo
}

// RemoveQuestionIDs removes the "questions" edge to Question entities by IDs.
func (tuo *TestUpdateOne) RemoveQuestionIDs(ids ...uuid.UUID) *TestUpdateOne {
	tuo.mutation.RemoveQuestionIDs(ids...)
	return tuo
}

// RemoveQuestions removes "questions" edges to Question entities.
func (tuo *TestUpdateOne) RemoveQuestions(q ...*Question) *TestUpdateOne {
	ids := make([]uuid.UUID, len(q))
	for i := range q {
		ids[i] = q[i].ID
	}
	return tuo.RemoveQuestionIDs(ids...)
}

// ClearQuestionCollections clears all "question_collections" edges to the QuestionCollection entity.
func (tuo *TestUpdateOne) ClearQuestionCollections() *TestUpdateOne {
	tuo.mutation.ClearQuestionCollections()
	return tuo
}

// RemoveQuestionCollectionIDs removes the "question_collections" edge to QuestionCollection entities by IDs.
func (tuo *TestUpdateOne) RemoveQuestionCollectionIDs(ids ...uuid.UUID) *TestUpdateOne {
	tuo.mutation.RemoveQuestionCollectionIDs(ids...)
	return tuo
}

// RemoveQuestionCollections removes "question_collections" edges to QuestionCollection entities.
func (tuo *TestUpdateOne) RemoveQuestionCollections(q ...*QuestionCollection) *TestUpdateOne {
	ids := make([]uuid.UUID, len(q))
	for i := range q {
		ids[i] = q[i].ID
	}
	return tuo.RemoveQuestionCollectionIDs(ids...)
}

// ClearTestQuestionCounts clears all "test_question_counts" edges to the TestQuestionCount entity.
func (tuo *TestUpdateOne) ClearTestQuestionCounts() *TestUpdateOne {
	tuo.mutation.ClearTestQuestionCounts()
	return tuo
}

// RemoveTestQuestionCountIDs removes the "test_question_counts" edge to TestQuestionCount entities by IDs.
func (tuo *TestUpdateOne) RemoveTestQuestionCountIDs(ids ...uuid.UUID) *TestUpdateOne {
	tuo.mutation.RemoveTestQuestionCountIDs(ids...)
	return tuo
}

// RemoveTestQuestionCounts removes "test_question_counts" edges to TestQuestionCount entities.
func (tuo *TestUpdateOne) RemoveTestQuestionCounts(t ...*TestQuestionCount) *TestUpdateOne {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tuo.RemoveTestQuestionCountIDs(ids...)
}

// ClearTestIgnoreQuestions clears all "test_ignore_questions" edges to the TestIgnoreQuestion entity.
func (tuo *TestUpdateOne) ClearTestIgnoreQuestions() *TestUpdateOne {
	tuo.mutation.ClearTestIgnoreQuestions()
	return tuo
}

// RemoveTestIgnoreQuestionIDs removes the "test_ignore_questions" edge to TestIgnoreQuestion entities by IDs.
func (tuo *TestUpdateOne) RemoveTestIgnoreQuestionIDs(ids ...uuid.UUID) *TestUpdateOne {
	tuo.mutation.RemoveTestIgnoreQuestionIDs(ids...)
	return tuo
}

// RemoveTestIgnoreQuestions removes "test_ignore_questions" edges to TestIgnoreQuestion entities.
func (tuo *TestUpdateOne) RemoveTestIgnoreQuestions(t ...*TestIgnoreQuestion) *TestUpdateOne {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tuo.RemoveTestIgnoreQuestionIDs(ids...)
}

// ClearTestQuestionPoints clears all "test_question_points" edges to the TestQuestionPoint entity.
func (tuo *TestUpdateOne) ClearTestQuestionPoints() *TestUpdateOne {
	tuo.mutation.ClearTestQuestionPoints()
	return tuo
}

// RemoveTestQuestionPointIDs removes the "test_question_points" edge to TestQuestionPoint entities by IDs.
func (tuo *TestUpdateOne) RemoveTestQuestionPointIDs(ids ...uuid.UUID) *TestUpdateOne {
	tuo.mutation.RemoveTestQuestionPointIDs(ids...)
	return tuo
}

// RemoveTestQuestionPoints removes "test_question_points" edges to TestQuestionPoint entities.
func (tuo *TestUpdateOne) RemoveTestQuestionPoints(t ...*TestQuestionPoint) *TestUpdateOne {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tuo.RemoveTestQuestionPointIDs(ids...)
}

// Where appends a list predicates to the TestUpdate builder.
func (tuo *TestUpdateOne) Where(ps ...predicate.Test) *TestUpdateOne {
	tuo.mutation.Where(ps...)
	return tuo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (tuo *TestUpdateOne) Select(field string, fields ...string) *TestUpdateOne {
	tuo.fields = append([]string{field}, fields...)
	return tuo
}

// Save executes the query and returns the updated Test entity.
func (tuo *TestUpdateOne) Save(ctx context.Context) (*Test, error) {
	if err := tuo.defaults(); err != nil {
		return nil, err
	}
	return withHooks(ctx, tuo.sqlSave, tuo.mutation, tuo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (tuo *TestUpdateOne) SaveX(ctx context.Context) *Test {
	node, err := tuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (tuo *TestUpdateOne) Exec(ctx context.Context) error {
	_, err := tuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (tuo *TestUpdateOne) ExecX(ctx context.Context) {
	if err := tuo.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (tuo *TestUpdateOne) defaults() error {
	if _, ok := tuo.mutation.UpdatedAt(); !ok {
		if test.UpdateDefaultUpdatedAt == nil {
			return fmt.Errorf("ent: uninitialized test.UpdateDefaultUpdatedAt (forgotten import ent/runtime?)")
		}
		v := test.UpdateDefaultUpdatedAt()
		tuo.mutation.SetUpdatedAt(v)
	}
	return nil
}

// check runs all checks and user-defined validators on the builder.
func (tuo *TestUpdateOne) check() error {
	if v, ok := tuo.mutation.Name(); ok {
		if err := test.NameValidator(v); err != nil {
			return &ValidationError{Name: "name", err: fmt.Errorf(`ent: validator failed for field "Test.name": %w`, err)}
		}
	}
	if v, ok := tuo.mutation.TotalPoints(); ok {
		if err := test.TotalPointsValidator(v); err != nil {
			return &ValidationError{Name: "total_points", err: fmt.Errorf(`ent: validator failed for field "Test.total_points": %w`, err)}
		}
	}
	return nil
}

func (tuo *TestUpdateOne) sqlSave(ctx context.Context) (_node *Test, err error) {
	if err := tuo.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(test.Table, test.Columns, sqlgraph.NewFieldSpec(test.FieldID, field.TypeUUID))
	id, ok := tuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "Test.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := tuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, test.FieldID)
		for _, f := range fields {
			if !test.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != test.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := tuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := tuo.mutation.CreatedAt(); ok {
		_spec.SetField(test.FieldCreatedAt, field.TypeTime, value)
	}
	if value, ok := tuo.mutation.UpdatedAt(); ok {
		_spec.SetField(test.FieldUpdatedAt, field.TypeTime, value)
	}
	if value, ok := tuo.mutation.DeletedAt(); ok {
		_spec.SetField(test.FieldDeletedAt, field.TypeTime, value)
	}
	if tuo.mutation.DeletedAtCleared() {
		_spec.ClearField(test.FieldDeletedAt, field.TypeTime)
	}
	if value, ok := tuo.mutation.Name(); ok {
		_spec.SetField(test.FieldName, field.TypeString, value)
	}
	if value, ok := tuo.mutation.TotalPoints(); ok {
		_spec.SetField(test.FieldTotalPoints, field.TypeInt, value)
	}
	if value, ok := tuo.mutation.AddedTotalPoints(); ok {
		_spec.AddField(test.FieldTotalPoints, field.TypeInt, value)
	}
	if tuo.mutation.CourseSectionCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   test.CourseSectionTable,
			Columns: []string{test.CourseSectionColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(coursesection.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tuo.mutation.CourseSectionIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   test.CourseSectionTable,
			Columns: []string{test.CourseSectionColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(coursesection.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tuo.mutation.CourseCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   test.CourseTable,
			Columns: []string{test.CourseColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(course.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tuo.mutation.CourseIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   test.CourseTable,
			Columns: []string{test.CourseColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(course.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tuo.mutation.TestSessionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   test.TestSessionsTable,
			Columns: []string{test.TestSessionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(testsession.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tuo.mutation.RemovedTestSessionsIDs(); len(nodes) > 0 && !tuo.mutation.TestSessionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   test.TestSessionsTable,
			Columns: []string{test.TestSessionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(testsession.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tuo.mutation.TestSessionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   test.TestSessionsTable,
			Columns: []string{test.TestSessionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(testsession.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tuo.mutation.QuestionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   test.QuestionsTable,
			Columns: test.QuestionsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(question.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tuo.mutation.RemovedQuestionsIDs(); len(nodes) > 0 && !tuo.mutation.QuestionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   test.QuestionsTable,
			Columns: test.QuestionsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(question.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tuo.mutation.QuestionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   test.QuestionsTable,
			Columns: test.QuestionsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(question.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tuo.mutation.QuestionCollectionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   test.QuestionCollectionsTable,
			Columns: test.QuestionCollectionsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(questioncollection.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tuo.mutation.RemovedQuestionCollectionsIDs(); len(nodes) > 0 && !tuo.mutation.QuestionCollectionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   test.QuestionCollectionsTable,
			Columns: test.QuestionCollectionsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(questioncollection.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tuo.mutation.QuestionCollectionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   test.QuestionCollectionsTable,
			Columns: test.QuestionCollectionsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(questioncollection.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tuo.mutation.TestQuestionCountsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   test.TestQuestionCountsTable,
			Columns: []string{test.TestQuestionCountsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(testquestioncount.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tuo.mutation.RemovedTestQuestionCountsIDs(); len(nodes) > 0 && !tuo.mutation.TestQuestionCountsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   test.TestQuestionCountsTable,
			Columns: []string{test.TestQuestionCountsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(testquestioncount.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tuo.mutation.TestQuestionCountsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   test.TestQuestionCountsTable,
			Columns: []string{test.TestQuestionCountsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(testquestioncount.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tuo.mutation.TestIgnoreQuestionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   test.TestIgnoreQuestionsTable,
			Columns: []string{test.TestIgnoreQuestionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(testignorequestion.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tuo.mutation.RemovedTestIgnoreQuestionsIDs(); len(nodes) > 0 && !tuo.mutation.TestIgnoreQuestionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   test.TestIgnoreQuestionsTable,
			Columns: []string{test.TestIgnoreQuestionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(testignorequestion.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tuo.mutation.TestIgnoreQuestionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   test.TestIgnoreQuestionsTable,
			Columns: []string{test.TestIgnoreQuestionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(testignorequestion.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tuo.mutation.TestQuestionPointsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   test.TestQuestionPointsTable,
			Columns: []string{test.TestQuestionPointsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(testquestionpoint.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tuo.mutation.RemovedTestQuestionPointsIDs(); len(nodes) > 0 && !tuo.mutation.TestQuestionPointsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   test.TestQuestionPointsTable,
			Columns: []string{test.TestQuestionPointsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(testquestionpoint.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tuo.mutation.TestQuestionPointsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   test.TestQuestionPointsTable,
			Columns: []string{test.TestQuestionPointsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(testquestionpoint.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &Test{config: tuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, tuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{test.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	tuo.mutation.done = true
	return _node, nil
}
