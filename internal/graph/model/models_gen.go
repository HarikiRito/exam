// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/google/uuid"
)

type AddMultiCollectionToTestInput struct {
	TestID        uuid.UUID   `json:"testId"`
	CollectionIds []uuid.UUID `json:"collectionIds"`
}

type Auth struct {
	AccessToken  string `json:"accessToken"`
	RefreshToken string `json:"refreshToken"`
}

type BatchDeleteQuestionPointsInput struct {
	TestID      uuid.UUID   `json:"testId"`
	QuestionIds []uuid.UUID `json:"questionIds"`
}

type BatchIgnoreQuestionsInput struct {
	TestID             uuid.UUID             `json:"testId"`
	QuestionIgnoreData []*QuestionIgnoreData `json:"questionIgnoreData"`
}

type BatchUpdateQuestionPointsInput struct {
	TestID         uuid.UUID              `json:"testId"`
	QuestionPoints []*QuestionPointsInput `json:"questionPoints"`
}

type CourseSectionFilterInput struct {
	OnlyRoot *bool `json:"onlyRoot,omitempty"`
}

type CreateCourseInput struct {
	Title       string  `json:"title"`
	Description *string `json:"description,omitempty"`
}

type CreateCourseSectionInput struct {
	Title       string     `json:"title"`
	Description string     `json:"description"`
	CourseID    uuid.UUID  `json:"courseId"`
	SectionID   *uuid.UUID `json:"sectionId,omitempty"`
}

type CreateQuestionCollectionInput struct {
	Title       string  `json:"title"`
	Description *string `json:"description,omitempty"`
}

type CreateQuestionInput struct {
	QuestionText         string                 `json:"questionText"`
	QuestionCollectionID uuid.UUID              `json:"questionCollectionId"`
	Options              []*QuestionOptionInput `json:"options"`
	Points               int                    `json:"points"`
}

type CreateQuestionOptionInput struct {
	QuestionID uuid.UUID `json:"questionId"`
	OptionText string    `json:"optionText"`
	IsCorrect  bool      `json:"isCorrect"`
}

type CreateTestInput struct {
	Name            string     `json:"name"`
	CourseSectionID *uuid.UUID `json:"courseSectionId,omitempty"`
	CourseID        *uuid.UUID `json:"courseId,omitempty"`
	TotalTime       int        `json:"totalTime"`
}

type CreateTestSessionInput struct {
	TestID uuid.UUID  `json:"testId"`
	UserID *uuid.UUID `json:"userId,omitempty"`
}

type LoginInput struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

type Mutation struct {
}

type NewTodo struct {
	Text string `json:"text"`
}

type PaginatedCourse struct {
	Pagination *Pagination `json:"pagination"`
	Items      []*Course   `json:"items"`
}

type PaginatedQuestion struct {
	Pagination *Pagination `json:"pagination"`
	Items      []*Question `json:"items"`
}

type PaginatedQuestionCollection struct {
	Pagination *Pagination           `json:"pagination"`
	Items      []*QuestionCollection `json:"items"`
}

type PaginatedQuestionOption struct {
	Pagination *Pagination       `json:"pagination"`
	Items      []*QuestionOption `json:"items"`
}

type PaginatedTest struct {
	Pagination *Pagination `json:"pagination"`
	Items      []*Test     `json:"items"`
}

type PaginatedTestSession struct {
	Pagination *Pagination    `json:"pagination"`
	Items      []*TestSession `json:"items"`
}

type PaginatedUser struct {
	Pagination *Pagination `json:"pagination"`
	Items      []*User     `json:"items"`
}

type Pagination struct {
	CurrentPage     int  `json:"currentPage"`
	TotalPages      int  `json:"totalPages"`
	TotalItems      int  `json:"totalItems"`
	HasNextPage     bool `json:"hasNextPage"`
	HasPreviousPage bool `json:"hasPreviousPage"`
}

type PaginationInput struct {
	Page   *int    `json:"page,omitempty"`
	Limit  *int    `json:"limit,omitempty"`
	Search *string `json:"search,omitempty"`
}

type Query struct {
}

type QuestionIgnoreData struct {
	QuestionID uuid.UUID `json:"questionId"`
	Reason     *string   `json:"reason,omitempty"`
}

type QuestionOptionInput struct {
	OptionText string `json:"optionText"`
	IsCorrect  bool   `json:"isCorrect"`
}

type QuestionOrder struct {
	QuestionID uuid.UUID `json:"questionId"`
	Order      int       `json:"order"`
}

type QuestionPointsInput struct {
	QuestionID uuid.UUID `json:"questionId"`
	Points     int       `json:"points"`
}

type RegisterInput struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

type StartTestSessionInput struct {
	TestTimeTaken int        `json:"testTimeTaken"`
	ExpiredAt     *time.Time `json:"expiredAt,omitempty"`
}

type SubmitTestSessionInput struct {
	Answers []*TestSessionAnswerInput `json:"answers"`
}

type TestIgnoreQuestion struct {
	ID         uuid.UUID `json:"id"`
	TestID     uuid.UUID `json:"testId"`
	QuestionID uuid.UUID `json:"questionId"`
	Reason     *string   `json:"reason,omitempty"`
	Question   *Question `json:"question,omitempty"`
}

type TestQuestionCount struct {
	ID                uuid.UUID `json:"id"`
	TestID            uuid.UUID `json:"testId"`
	NumberOfQuestions int       `json:"numberOfQuestions"`
	Points            int       `json:"points"`
}

type TestSessionAnswerInput struct {
	QuestionID        uuid.UUID   `json:"questionId"`
	QuestionOptionIds []uuid.UUID `json:"questionOptionIds"`
}

type Todo struct {
	ID   uuid.UUID `json:"id"`
	Text string    `json:"text"`
}

type UpdateBatchQuestionsByCollectionInput struct {
	CollectionID uuid.UUID             `json:"collectionId"`
	Questions    []*UpdateQuestionData `json:"questions"`
}

type UpdateCourseInput struct {
	Title       *string `json:"title,omitempty"`
	Description *string `json:"description,omitempty"`
}

type UpdateCourseSectionInput struct {
	Title       *string    `json:"title,omitempty"`
	Description *string    `json:"description,omitempty"`
	SectionID   *uuid.UUID `json:"sectionId,omitempty"`
}

type UpdateQuestionCollectionInput struct {
	Title       *string `json:"title,omitempty"`
	Description *string `json:"description,omitempty"`
}

type UpdateQuestionData struct {
	ID           *uuid.UUID                   `json:"id,omitempty"`
	QuestionText *string                      `json:"questionText,omitempty"`
	Options      []*UpdateQuestionOptionInput `json:"options"`
	Points       int                          `json:"points"`
}

type UpdateQuestionInput struct {
	QuestionText         *string                `json:"questionText,omitempty"`
	QuestionCollectionID *uuid.UUID             `json:"questionCollectionId,omitempty"`
	Options              []*QuestionOptionInput `json:"options,omitempty"`
	Points               int                    `json:"points"`
}

type UpdateQuestionOptionInput struct {
	OptionText *string `json:"optionText,omitempty"`
	IsCorrect  *bool   `json:"isCorrect,omitempty"`
}

type UpdateQuestionPointsByCollectionInput struct {
	TestID       uuid.UUID `json:"testId"`
	CollectionID uuid.UUID `json:"collectionId"`
	Points       int       `json:"points"`
}

type UpdateTestInput struct {
	Name      *string `json:"name,omitempty"`
	TotalTime *int    `json:"totalTime,omitempty"`
}

type UpdateTestQuestionRequirementInput struct {
	NumberOfQuestions int `json:"numberOfQuestions"`
	PointsPerQuestion int `json:"pointsPerQuestion"`
}

type UpdateTestSessionInput struct {
	CompletedAt *time.Time `json:"completedAt,omitempty"`
	TotalScore  *int       `json:"totalScore,omitempty"`
}

type User struct {
	ID        uuid.UUID `json:"id"`
	Email     string    `json:"email"`
	Username  string    `json:"username"`
	FirstName *string   `json:"firstName,omitempty"`
	LastName  *string   `json:"lastName,omitempty"`
	IsActive  bool      `json:"isActive"`
}

type TestSessionStatus string

const (
	TestSessionStatusPending    TestSessionStatus = "PENDING"
	TestSessionStatusCompleted  TestSessionStatus = "COMPLETED"
	TestSessionStatusInProgress TestSessionStatus = "IN_PROGRESS"
	TestSessionStatusCancelled  TestSessionStatus = "CANCELLED"
	TestSessionStatusExpired    TestSessionStatus = "EXPIRED"
)

var AllTestSessionStatus = []TestSessionStatus{
	TestSessionStatusPending,
	TestSessionStatusCompleted,
	TestSessionStatusInProgress,
	TestSessionStatusCancelled,
	TestSessionStatusExpired,
}

func (e TestSessionStatus) IsValid() bool {
	switch e {
	case TestSessionStatusPending, TestSessionStatusCompleted, TestSessionStatusInProgress, TestSessionStatusCancelled, TestSessionStatusExpired:
		return true
	}
	return false
}

func (e TestSessionStatus) String() string {
	return string(e)
}

func (e *TestSessionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TestSessionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TestSessionStatus", str)
	}
	return nil
}

func (e TestSessionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
