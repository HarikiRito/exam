# Cursor Rules for Remix React Project

## Component Usage Guidelines

### Allowed Components
Only components from the `app/shared/components` directory are permitted

### Import Path Rules
- Use absolute imports based on `tsconfig.json` paths
- Prefix imports with `app/` 
- Example: `import { Button } from "app/shared/components/button"`

### Styling
- Utilize TailwindCSS for all styling
- Avoid inline styles or external CSS files
- Use Tailwind's utility classes for responsive and dark mode designs

### Component Creation
- If a required component does not exist in `app/shared/components/`:
  1. Confirm with the team before creating a new component
  2. Follow existing component structure and design patterns
  3. Place new components in the appropriate subdirectory
  4. Ensure TailwindCSS compatibility
  5. Add comprehensive documentation

### Typography Guidelines
- Prefer using the AppTypography components from "app/shared/components/typography/AppTypography.tsx" for all typography needs to maintain consistency.

### Performance and Best Practices
- Prefer functional components
- Use React hooks for state management
- Implement proper prop typing
- Follow accessibility guidelines (WCAG)
- Do not use useMemo or useCallback for non-expensive operations

### Function Declaration Guidelines
- Use function declarations (`function functionName()`) for all functions
- Exceptions ONLY for React hooks:
  - `useEffect`
  - `useMemo`
  - `useCallback`
  - These hooks MUST use arrow function syntax
- Benefits of function declarations:
  - Hoisting allows function usage before declaration
  - Clearer stack traces
  - More readable and consistent code structure
- Naming conventions:
  - Use descriptive, camelCase function names
  - Prefix boolean-returning functions with `is`, `has`, or `should`

### Example Function Declarations
```typescript
// Preferred: Function declaration for most functions
function calculateTotal(items: Item[]): number {
  return items.reduce((total, item) => total + item.price, 0);
}

// Preferred: Regular function for event handlers
function handleSubmit(event: React.FormEvent) {
  event.preventDefault();
  // Submit logic
}
```

### Framework Specifics
- Use Remix conventions for routing and data loading
- Leverage Remix's built-in performance optimizations
- Use `loader` and `action` functions for data fetching and mutations
- **Forbid the use of `loader` in SPA mode**

### Example Component Usage
```tsx
import { AppButton } from "app/shared/components/button"
import { AppInput } from "app/shared/components/input"

export default function ExampleComponent() {
  return (
    <div className="flex space-x-4">
      <AppInput placeholder="Enter text" />
      <AppButton variant="primary">Submit</AppButton>
    </div>
  )
}
```

### Shared Directory Structure
- `shared` folder contains the following subdirectories:
  - `hooks/`: Custom React hooks
    - Use camelCase naming convention
    - Prefix hook names with `use`
    - Example: `useCustomState.ts`, `useDataFetching.ts`
  
  - `types/`: TypeScript type declarations
    - Use PascalCase for type names
    - Suffix interfaces with `Type` or `Interface`
    - Example: `UserType.ts`, `ResponseInterface.ts`
  
  - `constants/`: Constant variables
    - Use UPPERCASE_SNAKE_CASE
    - Group related constants together
    - Example: `API_ENDPOINTS.ts`, `ERROR_MESSAGES.ts`
  
  - `constants/enums/`: Enum declarations
    - Use PascalCase for enum names
    - Use UPPERCASE_SNAKE_CASE for enum values
    - Example: `UserRoles.ts` with values like `ADMIN`, `USER`, `GUEST`

#### Constants and Enums Best Practices
- Constants should be immutable
- Use `as const` for type safety when appropriate
- Enums provide type-safe way to represent a set of named constants
- Prefer const enums for better performance in TypeScript

### Example Constant and Enum Usage
```typescript
// constants/api.ts
export const API_BASE_URL = 'https://api.example.com';
export const DEFAULT_TIMEOUT = 5000;

// constants/enums/UserRoles.ts
export enum UserRole {
  ADMIN = 'ADMIN',
  USER = 'USER',
  GUEST = 'GUEST'
}

// hooks/useUserRole.ts
function useUserRole() {
  const [role, setRole] = useState<UserRole>(UserRole.GUEST);
  // ... hook implementation
}
```

### File Naming Conventions
- React component file names:
  - Files in `app/routes/` directory: camelCase (e.g., `index.tsx`, `login.tsx`)
  - All other React component files: PascalCase (e.g., `UserProfile.tsx`, `NavigationBar.tsx`)
- Non-component TypeScript files: camelCase (e.g., `userService.ts`, `apiClient.ts`)
- Ensure file names match the primary component or function exported from the file

### Example File Naming
```
app/routes/
├── index.tsx           // camelCase for route files
├── login.tsx           // camelCase for route files

app/components/
├── UserProfile.tsx     // PascalCase for components
├── NavigationBar.tsx   // PascalCase for components

app/shared/
├── userService.ts      // camelCase for services
├── apiClient.ts        // camelCase for utility files
```

### Zod Validation Guidelines
- Use Zod for all form and data validation
- Create schemas in `app/shared/validation/` directory
- Follow these schema creation best practices:
  - Use descriptive, comprehensive validation rules
  - Leverage Zod's type inference with `z.infer<typeof schema>`
  - Handle optional and nullable fields explicitly
  - Create reusable schemas for consistent validation

#### Zod Schema Example
```typescript
// app/shared/validation/userSchema.ts
import { z } from 'zod';

export const userSchema = z.object({
  name: z.string().min(2, "Name must be at least 2 characters"),
  email: z.string().email("Invalid email address"),
  age: z.number().min(18, "Must be at least 18 years old").optional()
});

export type UserSchema = z.infer<typeof userSchema>;
```

### React Hook Form Guidelines
- Use React Hook Form for all form management
- Integrate with Zod for validation
- Follow these form handling best practices:
  - Use `useForm` hook with Zod resolver
  - Implement clear error handling
  - Use `handleSubmit` for form submission
  - Minimize unnecessary re-renders

#### React Hook Form Example
```typescript
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { userSchema } from 'app/shared/validation/userSchema';

function UserForm() {
  const { 
    register, 
    handleSubmit, 
    formState: { errors } 
  } = useForm({
    resolver: zodResolver(userSchema)
  });

  function onSubmit(data) {
    // Handle form submission
  }

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {/* Form fields with error handling */}
    </form>
  );
}
```

### Integration Best Practices
- Combine Zod, React Hook Form, and Tanstack Query for robust form handling
- Use type inference to maintain type safety across the stack
- Handle loading and error states consistently
- Implement proper caching and data synchronization

#### Integrated Example
```typescript
function UserManagement() {
  const { data: users, isLoading } = useUsers();
  const createUserMutation = useCreateUser();
  const { 
    register, 
    handleSubmit, 
    formState: { errors } 
  } = useForm({
    resolver: zodResolver(userSchema)
  });

  function onSubmit(data) {
    createUserMutation.mutate(data);
  }

  // Render component with integrated logic
}
```

### Component Custom Class Names
- Do not add custom class names to existing shared components
- Custom class names should only be added when explicitly requested
- Existing shared components in `app/shared/components/` should maintain their default styling
- If styling modifications are necessary, discuss with the team first

### Form Handling Best Practices
- Use a consistent approach for all forms in the application
- Combine Zod for validation, React Hook Form for form management, and shared components for UI
- Follow these guidelines for creating forms:

#### Form Structure
- Always use `AppForm.*` components from shared components
- Utilize `AppInput`, `AppButton`, and other shared input components
- Implement form validation using Zod schemas
- Use React Hook Form with Zod resolver for form management

#### Example Comprehensive Form Implementation
```tsx
// Validation Schema
const loginSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string()
    .min(8, 'Password must be at least 8 characters')
    .regex(/[A-Z]/, 'Password must contain at least one uppercase letter')
    .regex(/[a-z]/, 'Password must contain at least one lowercase letter')
    .regex(/[0-9]/, 'Password must contain at least one number')
    .regex(/[!@#$%^&*()]/, 'Password must contain at least one special character'),
});

// Form Component
function LoginForm() {
  // Use form with Zod resolver
  const form = useForm<LoginFormData>({
    resolver: zodResolver(loginSchema),
    mode: 'onBlur', // Validate on field blur
  });

  // Submit handler
  function onSubmit(data: LoginFormData) {
    // Perform login logic
    console.log('Login submitted:', data);
  }

  return (
    <AppForm.Root {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)}>
        <AppForm.Field
          control={form.control}
          name="email"
          render={({ field }) => (
            <AppForm.Item>
              <AppForm.Label>Email</AppForm.Label>
              <AppForm.Control>
                <AppInput 
                  type="email" 
                  placeholder="m@example.com" 
                  {...field} 
                />
              </AppForm.Control>
              <AppForm.Message />
            </AppForm.Item>
          )}
        />

        <AppForm.Field
          control={form.control}
          name="password"
          render={({ field }) => (
            <AppForm.Item>
              <AppForm.Label>Password</AppForm.Label>
              <AppForm.Control>
                <AppInput 
                  type="password" 
                  {...field} 
                />
              </AppForm.Control>
              <AppForm.Message />
            </AppForm.Item>
          )}
        />

        <AppButton type="submit">Login</AppButton>
      </form>
    </AppForm.Root>
  );
}
```

#### Form Handling Guidelines
- Always use `mode: 'onBlur'` for validation to provide immediate feedback
- Implement clear, descriptive error messages
- Use `AppForm.Message` for displaying validation errors
- Leverage Zod's comprehensive validation capabilities
- Keep form logic clean and focused

#### Performance Considerations
- Minimize unnecessary re-renders using React Hook Form's performance optimizations
- Use `defaultValues` to set initial form state
- Leverage `watch` and `trigger` methods for advanced form interactions

### Commit Message Guidelines
- Commit messages must be concise and descriptive
- Maximum length: 100 characters
- Use imperative mood (e.g., "Add feature" not "Added feature")
- Capitalize the first letter
- Do not end with a period
- Provide a clear, high-level summary of the changes
- Focus on the "what" and "why", not the "how"

#### Commit Message Examples
```
# Good commit messages
Add user authentication flow
Fix memory leak in data fetching hook
Update login form validation rules
Refactor error handling in API service

# Bad commit messages
fixed some stuff
wip
changes
updated code
```

### PNPM Package Management Guidelines

#### Package Manager
- Use `pnpm` as the exclusive package manager for this project
- Never use `npm` or `yarn`
- Always use `pnpm` commands for all package management tasks

#### Installation and Setup
- Install dependencies using `pnpm install`
- Use `pnpm add` for adding new packages
- Use `pnpm add -D` for adding development dependencies
- Use `pnpm remove` for removing packages

#### Script Execution
- Use `pnpm run` or `pnpm` to execute scripts defined in `package.json`
- Prefix workspace-specific scripts with workspace name

#### Troubleshooting
- Use `pnpm why` to understand dependency trees
- Use `pnpm list` to view installed packages
- Clear cache with `pnpm store clean` if experiencing dependency issues

- Always look at the components folder first to see if there is anything you can reuse before creating a new one
- Use icons from the existing package instead of generating the SVG inline (lucide-icons)

## GraphQL and Remix Specific Guidelines

- Save operations GraphQL queries or mutations as `.query.gql` or `.mutation.gql` files. The file extension must end with `.gql`. After creation, run the `graphql:codegen` command specified in the `package.json`.
  Example: Create a file named `user.query.gql` and then run `pnpm run graphql:codegen`.

- When asked to build a query, run the command pnpm graphql:codegen after the .gql is created to generate a codegen version of it.

- Do not run the `cd` command if you are already in the destination folder.
  Example: If your current directory is `remix-react`, avoid using `cd remix-react`.

- Use Apollo's generated `useQuery` hook (from the codegen) for data operations.
  Example: `const { loading, data, error } = useUserQuery();` where `useUserQuery` is auto-generated from your GraphQL query.

- Prefer defining GraphQL fragments for commonly used types in a `.fragment.gql` file.
  Example: Define a fragment in a file like `UserFragment.fragment.gql` to reuse common user fields.

- Run your Remix application in SPA mode, without any server involvement. Do not use the `loader` function or any SSR-related functions as described in the Remix documentation.
  Example: Use hooks like `useQuery` in your components for data fetching instead of server-side `loader` functions.

- Fix all lint problems before proceeding with any other tasks.
  Example: Run `pnpm run lint:fix` to automatically address any lint issues.

## Knowledge

- Unique static paths in APP_ROUTES should be defined as string keys. For example:
  - dashboard: '/dashboard'
  - login: '/login'

- Dynamic paths must be implemented as functions that accept parameters to generate the full path. For instance:
  - adminCourseDetail: (courseId: string) => `/admin/courses/${courseId}`
  - adminCourseEdit: (courseId: string) => `/admin/courses/${courseId}/edit`

- Always use these defined keys and functions when navigating programmatically to ensure consistency and maintainability in the project.

## Error Handling Guidelines
- For Apollo queries and mutations, only check for the plain error object; avoid using both try-catch and additional error handling.
