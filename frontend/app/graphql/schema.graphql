schema {
  query: Query
  mutation: Mutation
}

"""
The @defer directive may be specified on a fragment spread to imply de-prioritization, that causes the fragment to be omitted in the initial response, and delivered as a subsequent response afterward. A query with @defer directive will cause the request to potentially return multiple responses, where non-deferred data is delivered in the initial response and data deferred delivered in a subsequent response. @include and @skip take precedence over @defer.
"""
directive @defer(if: Boolean = true, label: String) on FRAGMENT_SPREAD | INLINE_FRAGMENT

directive @goEnum(value: String) on ENUM_VALUE

directive @goModel(model: String, models: [String!]) on ENUM | INPUT_OBJECT | INTERFACE | OBJECT | SCALAR | UNION

directive @goTag(key: String!, value: String) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

input AddMultiCollectionToTestInput {
  collectionIds: [ID!]!
  testId: ID!
}

input AdminCreateUserInput {
  email: String!
  password: String!
  roleId: ID!
}

input AdminEditUserInput {
  email: String
  isActive: Boolean
  password: String
  roleId: ID
}

type Auth {
  accessToken: String!
  refreshToken: String!
}

input BatchDeleteQuestionPointsInput {
  questionIds: [ID!]!
  testId: ID!
}

input BatchIgnoreQuestionsInput {
  questionIgnoreData: [QuestionIgnoreData!]!
  testId: ID!
}

input BatchUpdateQuestionPointsInput {
  questionPoints: [QuestionPointsInput!]!
  testId: ID!
}

type Course {
  createdAt: DateTime!
  creator: User!
  description: String
  id: ID!
  title: String!
  updatedAt: DateTime!
}

type CourseSection {
  courseId: ID!
  description: String!
  id: ID!
  order: Int!
  sectionId: ID
  title: String!
}

input CourseSectionFilterInput {
  onlyRoot: Boolean
}

input CreateCourseInput {
  description: String
  title: String!
}

input CreateCourseSectionInput {
  courseId: ID!
  description: String!
  sectionId: ID
  title: String!
}

input CreateQuestionCollectionInput {
  description: String
  title: String!
}

input CreateQuestionInput {
  options: [QuestionOptionInput!]!
  points: Int!
  questionCollectionId: ID!
  questionText: String!
}

input CreateQuestionOptionInput {
  isCorrect: Boolean!
  optionText: String!
  questionId: ID!
}

input CreateTestInput {
  courseId: ID
  courseSectionId: ID
  name: String!
  totalTime: Int!
}

input CreateTestSessionInput {
  expiredTime: DateTime
  testId: ID!
  userIds: [ID!]
}

scalar DateTime

input LoginInput {
  email: String!
  password: String!
}

type Mutation {
  addMultiCollectionToTest(input: AddMultiCollectionToTestInput!): Boolean!
  adminCreateUser(input: AdminCreateUserInput!): User!
  adminEditUser(id: ID!, input: AdminEditUserInput!): User!
  batchIgnoreQuestions(input: BatchIgnoreQuestionsInput!): Boolean!
  createCourse(input: CreateCourseInput!): Course!
  createCourseSection(input: CreateCourseSectionInput!): CourseSection!
  createQuestion(input: CreateQuestionInput!): Question!
  createQuestionCollection(input: CreateQuestionCollectionInput!): QuestionCollection!
  createQuestionOption(input: CreateQuestionOptionInput!): QuestionOption!
  createTest(input: CreateTestInput!): Test!
  createTestSession(input: CreateTestSessionInput!): [TestSession!]!
  createTodo(input: NewTodo!): Todo!
  deleteQuestion(id: ID!): Boolean!
  deleteQuestionCollection(id: ID!): Boolean!
  deleteQuestionOption(id: ID!): Boolean!
  deleteTest(id: ID!): Boolean!
  deleteTestSession(id: ID!): Boolean!
  login(input: LoginInput!): Auth!
  logout: Boolean!
  register(input: RegisterInput!): Boolean!
  removeCourse(id: ID!): Boolean!
  removeCourseSection(id: ID!): Boolean!
  renewToken(refreshToken: String!): Auth!
  startTestSession(id: ID!): TestSession!
  submitTestSession(input: SubmitTestSessionInput!, sessionId: ID!): TestSession!
  updateBatchQuestionsByCollection(input: UpdateBatchQuestionsByCollectionInput!): Boolean!
  updateCourse(id: ID!, input: UpdateCourseInput!): Course!
  updateCourseSection(id: ID!, input: UpdateCourseSectionInput!): CourseSection!
  updateQuestion(id: ID!, input: UpdateQuestionInput!): Question!
  updateQuestionCollection(id: ID!, input: UpdateQuestionCollectionInput!): QuestionCollection!
  updateQuestionOption(id: ID!, input: UpdateQuestionOptionInput!): QuestionOption!
  updateTest(id: ID!, input: UpdateTestInput!): Test!
  updateTestQuestionRequirement(input: [UpdateTestQuestionRequirementInput!]!, testId: ID!): Boolean!
}

input NewTodo {
  text: String!
}

type PaginatedCourse {
  items: [Course!]!
  pagination: Pagination!
}

type PaginatedQuestion {
  items: [Question!]!
  pagination: Pagination!
}

type PaginatedQuestionCollection {
  items: [QuestionCollection!]!
  pagination: Pagination!
}

type PaginatedQuestionOption {
  items: [QuestionOption!]!
  pagination: Pagination!
}

type PaginatedTest {
  items: [Test!]!
  pagination: Pagination!
}

type PaginatedTestSession {
  items: [TestSession!]!
  pagination: Pagination!
}

type PaginatedUser {
  items: [User!]!
  pagination: Pagination!
}

type Pagination {
  currentPage: Int!
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  totalItems: Int!
  totalPages: Int!
}

input PaginationInput {
  limit: Int
  page: Int
  search: String
}

enum PermissionEnum {
  COLLECTION_CREATE
  COLLECTION_DELETE
  COLLECTION_READ
  COLLECTION_UPDATE
  COURSE_CREATE
  COURSE_DELETE
  COURSE_READ
  COURSE_SECTION_CREATE
  COURSE_SECTION_DELETE
  COURSE_SECTION_READ
  COURSE_SECTION_UPDATE
  COURSE_UPDATE
  MEDIA_CREATE
  MEDIA_DELETE
  MEDIA_READ
  MEDIA_UPDATE
  QUESTION_CREATE
  QUESTION_DELETE
  QUESTION_OPTION_CREATE
  QUESTION_OPTION_DELETE
  QUESTION_OPTION_READ
  QUESTION_OPTION_UPDATE
  QUESTION_READ
  QUESTION_UPDATE
  SESSION_CREATE
  SESSION_DELETE
  SESSION_READ
  SESSION_UPDATE
  TEST_CREATE
  TEST_DELETE
  TEST_READ
  TEST_UPDATE
  USER_CREATE
  USER_READ
  USER_UPDATE
  VIDEO_CREATE
  VIDEO_DELETE
  VIDEO_READ
  VIDEO_UPDATE
}

type Query {
  course(id: ID!): Course!
  courseSection(id: ID!): CourseSection!
  courseSectionsByCourseId(courseId: ID!, filter: CourseSectionFilterInput): [CourseSection!]!
  exportQuestions(questionIds: [ID!]!): String!
  getAllPermissions: [PermissionEnum!]!
  getAllRoles: [Role!]!
  getUserById(id: ID!): User!
  isAuthenticated: Boolean!
  me: User!
  paginatedCourses(paginationInput: PaginationInput): PaginatedCourse!
  paginatedQuestionCollections(paginationInput: PaginationInput): PaginatedQuestionCollection!
  paginatedQuestions(paginationInput: PaginationInput): PaginatedQuestion!
  paginatedTestSessions(paginationInput: PaginationInput): PaginatedTestSession!
  paginatedTests(paginationInput: PaginationInput): PaginatedTest!
  paginatedUsers(paginationInput: PaginationInput): PaginatedUser!
  question(id: ID!): Question!
  questionCollection(id: ID!): QuestionCollection!
  questionCountByPoints(collectionIds: [ID!]!): [QuestionPointsCount!]!
  questionOption(id: ID!): QuestionOption!
  questions(ids: [ID!]!): [Question!]!
  test(id: ID!): Test!
  testSession(id: ID!): TestSession!
  todos: [Todo!]!
}

type Question {
  collection: QuestionCollection
  correctOptionCount: Int!
  id: ID!
  options: [QuestionOption!]!
  points: Int!
  questionText: String!
}

type QuestionCollection {
  createdAt: DateTime!
  creator: User!
  description: String
  id: ID!
  questions: [Question!]!
  title: String!
  updatedAt: DateTime!
}

input QuestionIgnoreData {
  questionId: ID!
  reason: String
}

type QuestionOption {
  id: ID!
  isCorrect: Boolean!
  optionText: String!
  question: Question!
}

input QuestionOptionInput {
  isCorrect: Boolean!
  optionText: String!
}

type QuestionOrder {
  order: Int!
  questionId: ID!
}

type QuestionPointsCount {
  count: Int!
  points: Int!
}

input QuestionPointsInput {
  points: Int!
  questionId: ID!
}

input RegisterInput {
  email: String!
  password: String!
}

type Role {
  id: ID!
  name: String!
}

input StartTestSessionInput {
  expiredAt: DateTime
  testTimeTaken: Int!
}

input SubmitTestSessionInput {
  answers: [TestSessionAnswerInput!]!
}

type Test {
  id: ID!
  name: String!
  questionCollections: [QuestionCollection!]!
  testIgnoreQuestions: [TestIgnoreQuestion!]!
  testQuestionCounts: [TestQuestionCount!]!
  totalTime: Int
}

type TestIgnoreQuestion {
  id: ID!
  question: Question
  questionId: ID!
  reason: String
  testId: ID!
}

type TestQuestionCount {
  id: ID!
  numberOfQuestions: Int!
  points: Int!
  testId: ID!
}

type TestSession {
  completedAt: DateTime
  createdAt: DateTime!
  expiredAt: DateTime
  id: ID!
  maxPoints: Int!
  orderedQuestions: [QuestionOrder!]!
  pointsEarned: Int!
  questions: [Question!]!
  startedAt: DateTime
  status: TestSessionStatus!
  test: Test!
  testId: ID!
  updatedAt: DateTime!
  userId: ID
}

input TestSessionAnswerInput {
  questionId: ID!
  questionOptionIds: [ID!]!
}

enum TestSessionStatus {
  CANCELLED
  COMPLETED
  EXPIRED
  IN_PROGRESS
  PENDING
}

type Todo {
  id: ID!
  text: String!
}

scalar UUID

input UpdateBatchQuestionsByCollectionInput {
  collectionId: ID!
  questions: [UpdateQuestionData!]!
}

input UpdateCourseInput {
  description: String
  title: String
}

input UpdateCourseSectionInput {
  description: String
  sectionId: ID
  title: String
}

input UpdateQuestionCollectionInput {
  description: String
  title: String
}

input UpdateQuestionData {
  id: ID
  options: [UpdateQuestionOptionInput!]!
  points: Int!
  questionText: String
}

input UpdateQuestionInput {
  options: [QuestionOptionInput!]
  points: Int!
  questionCollectionId: ID
  questionText: String
}

input UpdateQuestionOptionInput {
  isCorrect: Boolean
  optionText: String
}

input UpdateQuestionPointsByCollectionInput {
  collectionId: ID!
  points: Int!
  testId: ID!
}

input UpdateTestInput {
  name: String
  totalTime: Int
}

input UpdateTestQuestionRequirementInput {
  numberOfQuestions: Int!
  pointsPerQuestion: Int!
}

input UpdateTestSessionInput {
  completedAt: DateTime
  totalScore: Int
}

type User {
  email: String!
  firstName: String
  id: ID!
  isActive: Boolean!
  lastName: String
  permissions: [PermissionEnum!]!
  roles: [Role!]!
  username: String!
}