package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.57

import (
	"context"
	"template/internal/features/permission"
	"template/internal/features/question"
	"template/internal/features/question_collection"
	"template/internal/graph/dataloader"
	"template/internal/graph/model"
	"template/internal/shared/utilities/slice"

	"github.com/google/uuid"
)

// CreateQuestionCollection is the resolver for the createQuestionCollection field.
func (r *mutationResolver) CreateQuestionCollection(ctx context.Context, input model.CreateQuestionCollectionInput) (*model.QuestionCollection, error) {
	userId, err := CheckUserPermissions(ctx, []permission.Permission{
		permission.CollectionCreate,
	})
	if err != nil {
		return nil, err
	}

	questionCollection, err := question_collection.CreateQuestionCollection(ctx, userId, input)
	if err != nil {
		return nil, err
	}
	return model.ConvertQuestionCollectionToModel(questionCollection), nil
}

// UpdateQuestionCollection is the resolver for the updateQuestionCollection field.
func (r *mutationResolver) UpdateQuestionCollection(ctx context.Context, id uuid.UUID, input model.UpdateQuestionCollectionInput) (*model.QuestionCollection, error) {
	userId, err := CheckUserPermissions(ctx, []permission.Permission{
		permission.CollectionUpdate,
	})
	if err != nil {
		return nil, err
	}

	collection, err := question_collection.UpdateQuestionCollection(ctx, userId, id, input)
	if err != nil {
		return nil, err
	}
	return model.ConvertQuestionCollectionToModel(collection), nil
}

// DeleteQuestionCollection is the resolver for the deleteQuestionCollection field.
func (r *mutationResolver) DeleteQuestionCollection(ctx context.Context, id uuid.UUID) (bool, error) {
	userId, err := CheckUserPermissions(ctx, []permission.Permission{
		permission.CollectionDelete,
	})
	if err != nil {
		return false, err
	}

	return question_collection.DeleteQuestionCollection(ctx, userId, id)
}

// UpdateBatchQuestionsByCollection is the resolver for the updateBatchQuestionsByCollection field.
func (r *mutationResolver) UpdateBatchQuestionsByCollection(ctx context.Context, input model.UpdateBatchQuestionsByCollectionInput) (bool, error) {
	userId, err := CheckUserPermissions(ctx, []permission.Permission{
		permission.CollectionUpdate,
	})
	if err != nil {
		return false, err
	}

	err = question_collection.UpdateBatchQuestionsByCollection(ctx, userId, input)
	if err != nil {
		return false, err
	}

	return true, nil
}

// QuestionCollection is the resolver for the questionCollection field.
func (r *queryResolver) QuestionCollection(ctx context.Context, id uuid.UUID) (*model.QuestionCollection, error) {
	userId, err := CheckUserPermissions(ctx, []permission.Permission{
		permission.CollectionRead,
	})
	if err != nil {
		return nil, err
	}

	collection, err := question_collection.GetQuestionCollectionByID(ctx, userId, id)
	if err != nil {
		return nil, err
	}
	return model.ConvertQuestionCollectionToModel(collection), nil
}

// PaginatedQuestionCollections is the resolver for the paginatedQuestionCollections field.
func (r *queryResolver) PaginatedQuestionCollections(ctx context.Context, paginationInput *model.PaginationInput) (*model.PaginatedQuestionCollection, error) {
	userId, err := CheckUserPermissions(ctx, []permission.Permission{
		permission.CollectionRead,
	})
	if err != nil {
		return nil, err
	}

	result, err := question_collection.PaginatedQuestionCollections(ctx, userId, paginationInput)
	if err != nil {
		return nil, err
	}

	items := slice.Map(result.Items, model.ConvertQuestionCollectionToModel)
	pagination := &model.Pagination{
		CurrentPage:     result.CurrentPage,
		TotalPages:      result.TotalPages,
		TotalItems:      result.TotalItems,
		HasNextPage:     result.HasNextPage,
		HasPreviousPage: result.HasPrevPage,
	}

	return &model.PaginatedQuestionCollection{
		Pagination: pagination,
		Items:      items,
	}, nil
}

// ExportQuestions is the resolver for the exportQuestions field.
func (r *queryResolver) ExportQuestions(ctx context.Context, questionIds []uuid.UUID) (string, error) {
	userId, err := CheckUserPermissions(ctx, []permission.Permission{
		permission.QuestionRead,
	})
	if err != nil {
		return "", err
	}

	// Export questions using the feature function
	return question.ExportQuestions(ctx, userId, questionIds)
}

// QuestionCountByPoints is the resolver for the questionCountByPoints field.
func (r *queryResolver) QuestionCountByPoints(ctx context.Context, collectionIds []uuid.UUID) ([]*model.QuestionPointsCount, error) {
	_, err := CheckUserPermissions(ctx, []permission.Permission{
		permission.QuestionRead,
	})
	if err != nil {
		return nil, err
	}

	return question_collection.GetQuestionCountByPoints(ctx, collectionIds)
}

// Creator is the resolver for the creator field.
func (r *questionCollectionResolver) Creator(ctx context.Context, obj *model.QuestionCollection) (*model.User, error) {
	return dataloader.GetUser(ctx, obj.CreatorID)
}

// Questions is the resolver for the questions field.
func (r *questionCollectionResolver) Questions(ctx context.Context, obj *model.QuestionCollection) ([]*model.Question, error) {
	return dataloader.GetQuestionsByCollectionID(ctx, obj.ID)
}

// QuestionCollection returns QuestionCollectionResolver implementation.
func (r *Resolver) QuestionCollection() QuestionCollectionResolver {
	return &questionCollectionResolver{r}
}

type questionCollectionResolver struct{ *Resolver }
