# Cursor Rules for Remix React Project

## Component Usage Guidelines

### Allowed Components
Only components from the `app/shared/components` directory are permitted

### Import Path Rules
- Use absolute imports based on `tsconfig.json` paths
- Prefix imports with `app/` 
- Example: `import { Button } from "app/shared/components/button"`

### Styling
- Utilize TailwindCSS for all styling
- Avoid inline styles or external CSS files
- Use Tailwind's utility classes for responsive and dark mode designs

### Component Creation
- If a required component does not exist in `app/shared/components/`:
  1. Confirm with the team before creating a new component
  2. Follow existing component structure and design patterns
  3. Place new components in the appropriate subdirectory
  4. Ensure TailwindCSS compatibility
  5. Add comprehensive documentation

### Performance and Best Practices
- Prefer functional components
- Use React hooks for state management
- Implement proper prop typing
- Follow accessibility guidelines (WCAG)

### Function Declaration Guidelines
- Use function declarations (`function functionName()`) for all functions
- Exceptions ONLY for React hooks:
  - `useEffect`
  - `useMemo`
  - `useCallback`
  - These hooks MUST use arrow function syntax
- Benefits of function declarations:
  - Hoisting allows function usage before declaration
  - Clearer stack traces
  - More readable and consistent code structure
- Naming conventions:
  - Use descriptive, camelCase function names
  - Prefix boolean-returning functions with `is`, `has`, or `should`

### Example Function Declarations
```typescript
// Preferred: Function declaration for most functions
function calculateTotal(items: Item[]): number {
  return items.reduce((total, item) => total + item.price, 0);
}

// Preferred: Regular function for event handlers
function handleSubmit(event: React.FormEvent) {
  event.preventDefault();
  // Submit logic
}
```

### Framework Specifics
- Use Remix conventions for routing and data loading
- Leverage Remix's built-in performance optimizations
- Use `loader` and `action` functions for data fetching and mutations

### Example Component Usage
```tsx
import { AppButton } from "app/shared/components/button"
import { AppInput } from "app/shared/components/input"

export default function ExampleComponent() {
  return (
    <div className="flex space-x-4">
      <AppInput placeholder="Enter text" />
      <AppButton variant="primary">Submit</AppButton>
    </div>
  )
}
```

### Shared Directory Structure
- `shared` folder contains the following subdirectories:
  - `hooks/`: Custom React hooks
    - Use camelCase naming convention
    - Prefix hook names with `use`
    - Example: `useCustomState.ts`, `useDataFetching.ts`
  
  - `types/`: TypeScript type declarations
    - Use PascalCase for type names
    - Suffix interfaces with `Type` or `Interface`
    - Example: `UserType.ts`, `ResponseInterface.ts`
  
  - `constants/`: Constant variables
    - Use UPPERCASE_SNAKE_CASE
    - Group related constants together
    - Example: `API_ENDPOINTS.ts`, `ERROR_MESSAGES.ts`
  
  - `constants/enums/`: Enum declarations
    - Use PascalCase for enum names
    - Use UPPERCASE_SNAKE_CASE for enum values
    - Example: `UserRoles.ts` with values like `ADMIN`, `USER`, `GUEST`

#### Constants and Enums Best Practices
- Constants should be immutable
- Use `as const` for type safety when appropriate
- Enums provide type-safe way to represent a set of named constants
- Prefer const enums for better performance in TypeScript

### Example Constant and Enum Usage
```typescript
// constants/api.ts
export const API_BASE_URL = 'https://api.example.com';
export const DEFAULT_TIMEOUT = 5000;

// constants/enums/UserRoles.ts
export enum UserRole {
  ADMIN = 'ADMIN',
  USER = 'USER',
  GUEST = 'GUEST'
}

// hooks/useUserRole.ts
function useUserRole() {
  const [role, setRole] = useState<UserRole>(UserRole.GUEST);
  // ... hook implementation
}
```

### File Naming Conventions
- React component file names:
  - Files in `app/routes/` directory: camelCase (e.g., `index.tsx`, `login.tsx`)
  - All other React component files: PascalCase (e.g., `UserProfile.tsx`, `NavigationBar.tsx`)
- Non-component TypeScript files: camelCase (e.g., `userService.ts`, `apiClient.ts`)
- Ensure file names match the primary component or function exported from the file

### Example File Naming
```
app/routes/
├── index.tsx           // camelCase for route files
├── login.tsx           // camelCase for route files

app/components/
├── UserProfile.tsx     // PascalCase for components
├── NavigationBar.tsx   // PascalCase for components

app/shared/
├── userService.ts      // camelCase for services
├── apiClient.ts        // camelCase for utility files
```

### Zod Validation Guidelines
- Use Zod for all form and data validation
- Create schemas in `app/shared/validation/` directory
- Follow these schema creation best practices:
  - Use descriptive, comprehensive validation rules
  - Leverage Zod's type inference with `z.infer<typeof schema>`
  - Handle optional and nullable fields explicitly
  - Create reusable schemas for consistent validation

#### Zod Schema Example
```typescript
// app/shared/validation/userSchema.ts
import { z } from 'zod';

export const userSchema = z.object({
  name: z.string().min(2, "Name must be at least 2 characters"),
  email: z.string().email("Invalid email address"),
  age: z.number().min(18, "Must be at least 18 years old").optional()
});

export type UserSchema = z.infer<typeof userSchema>;
```

### React Hook Form Guidelines
- Use React Hook Form for all form management
- Integrate with Zod for validation
- Follow these form handling best practices:
  - Use `useForm` hook with Zod resolver
  - Implement clear error handling
  - Use `handleSubmit` for form submission
  - Minimize unnecessary re-renders

#### React Hook Form Example
```typescript
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { userSchema } from 'app/shared/validation/userSchema';

function UserForm() {
  const { 
    register, 
    handleSubmit, 
    formState: { errors } 
  } = useForm({
    resolver: zodResolver(userSchema)
  });

  function onSubmit(data) {
    // Handle form submission
  }

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {/* Form fields with error handling */}
    </form>
  );
}
```

### Tanstack Query (React Query) Guidelines
- Use Tanstack Query for all data fetching and server state management
- Create query hooks in `app/shared/hooks/queries/`
- Follow these data fetching best practices:
  - Use `useQuery` for read operations
  - Use `useMutation` for write operations
  - Implement error and loading states
  - Use query keys for caching and invalidation
  - Leverage `staleTime` and `cacheTime` for performance

#### Tanstack Query Example
```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { fetchUsers, createUser } from 'app/services/userService';

// Read Query
function useUsers() {
  return useQuery({
    queryKey: ['users'],
    queryFn: fetchUsers,
    staleTime: 5 * 60 * 1000 // 5 minutes
  });
}

// Mutation Query
function useCreateUser() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: createUser,
    onSuccess: () => {
      // Invalidate and refetch users query
      queryClient.invalidateQueries({ queryKey: ['users'] });
    }
  });
}
```

### Integration Best Practices
- Combine Zod, React Hook Form, and Tanstack Query for robust form handling
- Use type inference to maintain type safety across the stack
- Handle loading and error states consistently
- Implement proper caching and data synchronization

#### Integrated Example
```typescript
function UserManagement() {
  const { data: users, isLoading } = useUsers();
  const createUserMutation = useCreateUser();
  const { 
    register, 
    handleSubmit, 
    formState: { errors } 
  } = useForm({
    resolver: zodResolver(userSchema)
  });

  function onSubmit(data) {
    createUserMutation.mutate(data);
  }

  // Render component with integrated logic
}
```

### Component Custom Class Names
- Do not add custom class names to existing shared components
- Custom class names should only be added when explicitly requested
- Existing shared components in `app/shared/components/` should maintain their default styling
- If styling modifications are necessary, discuss with the team first
