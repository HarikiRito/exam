# Cursor Rules for Remix React Project

## Component Usage Guidelines

### Allowed Components
Only components from the `app/shared/components` directory are permitted

### Import Path Rules
- Use absolute imports based on `tsconfig.json` paths
- Prefix imports with `app/` 
- Example: `import { Button } from "app/shared/components/button"`

### Styling
- Utilize TailwindCSS for all styling
- Avoid inline styles or external CSS files
- Use Tailwind's utility classes for responsive and dark mode designs

### Component Creation
- If a required component does not exist in `app/shared/components/`:
  1. Confirm with the team before creating a new component
  2. Follow existing component structure and design patterns
  3. Place new components in the appropriate subdirectory
  4. Ensure TailwindCSS compatibility
  5. Add comprehensive documentation

### Typography Guidelines
- Prefer using the AppTypography components from "app/shared/components/typography/AppTypography.tsx" for all typography needs to maintain consistency.

### Performance and Best Practices
- Prefer functional components
- Use React hooks for state management
- Implement proper prop typing
- Follow accessibility guidelines (WCAG)

### Function Declaration Guidelines
- Use function declarations (`function functionName()`) for all functions
- Exceptions ONLY for React hooks:
  - `useEffect`
  - `useMemo`
  - `useCallback`
  - These hooks MUST use arrow function syntax
- Benefits of function declarations:
  - Hoisting allows function usage before declaration
  - Clearer stack traces
  - More readable and consistent code structure
- Naming conventions:
  - Use descriptive, camelCase function names
  - Prefix boolean-returning functions with `is`, `has`, or `should`

### Example Function Declarations
```typescript
// Preferred: Function declaration for most functions
function calculateTotal(items: Item[]): number {
  return items.reduce((total, item) => total + item.price, 0);
}

// Preferred: Regular function for event handlers
function handleSubmit(event: React.FormEvent) {
  event.preventDefault();
  // Submit logic
}
```

### Framework Specifics
- Use Remix conventions for routing and data loading
- Leverage Remix's built-in performance optimizations
- Use `loader` and `action` functions for data fetching and mutations

### Example Component Usage
```tsx
import { AppButton } from "app/shared/components/button"
import { AppInput } from "app/shared/components/input"

export default function ExampleComponent() {
  return (
    <div className="flex space-x-4">
      <AppInput placeholder="Enter text" />
      <AppButton variant="primary">Submit</AppButton>
    </div>
  )
}
```

### Shared Directory Structure
- `shared` folder contains the following subdirectories:
  - `hooks/`: Custom React hooks
    - Use camelCase naming convention
    - Prefix hook names with `use`
    - Example: `useCustomState.ts`, `useDataFetching.ts`
  
  - `types/`: TypeScript type declarations
    - Use PascalCase for type names
    - Suffix interfaces with `Type` or `Interface`
    - Example: `UserType.ts`, `ResponseInterface.ts`
  
  - `constants/`: Constant variables
    - Use UPPERCASE_SNAKE_CASE
    - Group related constants together
    - Example: `API_ENDPOINTS.ts`, `ERROR_MESSAGES.ts`
  
  - `constants/enums/`: Enum declarations
    - Use PascalCase for enum names
    - Use UPPERCASE_SNAKE_CASE for enum values
    - Example: `UserRoles.ts` with values like `ADMIN`, `USER`, `GUEST`

#### Constants and Enums Best Practices
- Constants should be immutable
- Use `as const` for type safety when appropriate
- Enums provide type-safe way to represent a set of named constants
- Prefer const enums for better performance in TypeScript

### Example Constant and Enum Usage
```typescript
// constants/api.ts
export const API_BASE_URL = 'https://api.example.com';
export const DEFAULT_TIMEOUT = 5000;

// constants/enums/UserRoles.ts
export enum UserRole {
  ADMIN = 'ADMIN',
  USER = 'USER',
  GUEST = 'GUEST'
}

// hooks/useUserRole.ts
function useUserRole() {
  const [role, setRole] = useState<UserRole>(UserRole.GUEST);
  // ... hook implementation
}
```

### File Naming Conventions
- React component file names:
  - Files in `app/routes/` directory: camelCase (e.g., `index.tsx`, `login.tsx`)
  - All other React component files: PascalCase (e.g., `UserProfile.tsx`, `NavigationBar.tsx`)
- Non-component TypeScript files: camelCase (e.g., `userService.ts`, `apiClient.ts`)
- Ensure file names match the primary component or function exported from the file

### Example File Naming
```
app/routes/
├── index.tsx           // camelCase for route files
├── login.tsx           // camelCase for route files

app/components/
├── UserProfile.tsx     // PascalCase for components
├── NavigationBar.tsx   // PascalCase for components

app/shared/
├── userService.ts      // camelCase for services
├── apiClient.ts        // camelCase for utility files
```

### Zod Validation Guidelines
- Use Zod for all form and data validation
- Create schemas in `app/shared/validation/` directory
- Follow these schema creation best practices:
  - Use descriptive, comprehensive validation rules
  - Leverage Zod's type inference with `z.infer<typeof schema>`
  - Handle optional and nullable fields explicitly
  - Create reusable schemas for consistent validation

#### Zod Schema Example
```typescript
// app/shared/validation/userSchema.ts
import { z } from 'zod';

export const userSchema = z.object({
  name: z.string().min(2, "Name must be at least 2 characters"),
  email: z.string().email("Invalid email address"),
  age: z.number().min(18, "Must be at least 18 years old").optional()
});

export type UserSchema = z.infer<typeof userSchema>;
```

### React Hook Form Guidelines
- Use React Hook Form for all form management
- Integrate with Zod for validation
- Follow these form handling best practices:
  - Use `useForm` hook with Zod resolver
  - Implement clear error handling
  - Use `handleSubmit` for form submission
  - Minimize unnecessary re-renders

#### React Hook Form Example
```typescript
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { userSchema } from 'app/shared/validation/userSchema';

function UserForm() {
  const { 
    register, 
    handleSubmit, 
    formState: { errors } 
  } = useForm({
    resolver: zodResolver(userSchema)
  });

  function onSubmit(data) {
    // Handle form submission
  }

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {/* Form fields with error handling */}
    </form>
  );
}
```

### Tanstack Query (React Query) Guidelines
- Use Tanstack Query for all data fetching and server state management
- Create query hooks in `app/shared/hooks/queries/`
- Follow these data fetching best practices:
  - Use `useQuery` for read operations
  - Use `useMutation` for write operations
  - Implement error and loading states
  - Use query keys for caching and invalidation
  - Leverage `staleTime` and `cacheTime` for performance

#### Tanstack Query Example
```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { fetchUsers, createUser } from 'app/services/userService';

// Read Query
function useUsers() {
  return useQuery({
    queryKey: ['users'],
    queryFn: fetchUsers,
    staleTime: 5 * 60 * 1000 // 5 minutes
  });
}

// Mutation Query
function useCreateUser() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: createUser,
    onSuccess: () => {
      // Invalidate and refetch users query
      queryClient.invalidateQueries({ queryKey: ['users'] });
    }
  });
}
```

### Integration Best Practices
- Combine Zod, React Hook Form, and Tanstack Query for robust form handling
- Use type inference to maintain type safety across the stack
- Handle loading and error states consistently
- Implement proper caching and data synchronization

#### Integrated Example
```typescript
function UserManagement() {
  const { data: users, isLoading } = useUsers();
  const createUserMutation = useCreateUser();
  const { 
    register, 
    handleSubmit, 
    formState: { errors } 
  } = useForm({
    resolver: zodResolver(userSchema)
  });

  function onSubmit(data) {
    createUserMutation.mutate(data);
  }

  // Render component with integrated logic
}
```

### Component Custom Class Names
- Do not add custom class names to existing shared components
- Custom class names should only be added when explicitly requested
- Existing shared components in `app/shared/components/` should maintain their default styling
- If styling modifications are necessary, discuss with the team first

### Form Handling Best Practices
- Use a consistent approach for all forms in the application
- Combine Zod for validation, React Hook Form for form management, and shared components for UI
- Follow these guidelines for creating forms:

#### Form Structure
- Always use `AppForm.*` components from shared components
- Utilize `AppInput`, `AppButton`, and other shared input components
- Implement form validation using Zod schemas
- Use React Hook Form with Zod resolver for form management

#### Example Comprehensive Form Implementation
```typescript
// Validation Schema
const loginSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string()
    .min(8, 'Password must be at least 8 characters')
    .regex(/[A-Z]/, 'Password must contain at least one uppercase letter')
    .regex(/[a-z]/, 'Password must contain at least one lowercase letter')
    .regex(/[0-9]/, 'Password must contain at least one number')
    .regex(/[!@#$%^&*()]/, 'Password must contain at least one special character'),
});

// Form Component
function LoginForm() {
  // Use form with Zod resolver
  const form = useForm<LoginFormData>({
    resolver: zodResolver(loginSchema),
    mode: 'onBlur', // Validate on field blur
  });

  // Submit handler
  function onSubmit(data: LoginFormData) {
    // Perform login logic
    console.log('Login submitted:', data);
  }

  return (
    <AppForm.Root {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)}>
        <AppForm.Field
          control={form.control}
          name="email"
          render={({ field }) => (
            <AppForm.Item>
              <AppForm.Label>Email</AppForm.Label>
              <AppForm.Control>
                <AppInput 
                  type="email" 
                  placeholder="m@example.com" 
                  {...field} 
                />
              </AppForm.Control>
              <AppForm.Message />
            </AppForm.Item>
          )}
        />

        <AppForm.Field
          control={form.control}
          name="password"
          render={({ field }) => (
            <AppForm.Item>
              <AppForm.Label>Password</AppForm.Label>
              <AppForm.Control>
                <AppInput 
                  type="password" 
                  {...field} 
                />
              </AppForm.Control>
              <AppForm.Message />
            </AppForm.Item>
          )}
        />

        <AppButton type="submit">Login</AppButton>
      </form>
    </AppForm.Root>
  );
}
```

#### Form Handling Guidelines
- Always use `mode: 'onBlur'` for validation to provide immediate feedback
- Implement clear, descriptive error messages
- Use `AppForm.Message` for displaying validation errors
- Leverage Zod's comprehensive validation capabilities
- Keep form logic clean and focused

#### Performance Considerations
- Minimize unnecessary re-renders using React Hook Form's performance optimizations
- Use `defaultValues` to set initial form state
- Leverage `watch` and `trigger` methods for advanced form interactions

#### Accessibility
- Ensure all form fields have associated labels
- Use `AppForm.Label` and `AppForm.Item` for proper accessibility
- Provide clear error messages and visual feedback
- Implement keyboard navigation support

### Commit Message Guidelines
- Commit messages must be concise and descriptive
- Maximum length: 100 characters
- Use imperative mood (e.g., "Add feature" not "Added feature")
- Capitalize the first letter
- Do not end with a period
- Provide a clear, high-level summary of the changes
- Focus on the "what" and "why", not the "how"

#### Commit Message Examples
```
# Good commit messages
Add user authentication flow
Fix memory leak in data fetching hook
Update login form validation rules
Refactor error handling in API service

# Bad commit messages
fixed some stuff
wip
changes
updated code
```

### PNPM Package Management Guidelines

#### Package Manager
- Use `pnpm` as the exclusive package manager for this project
- Never use `npm` or `yarn`
- Always use `pnpm` commands for all package management tasks

#### Installation and Setup
- Install dependencies using `pnpm install`
- Use `pnpm add` for adding new packages
- Use `pnpm add -D` for adding development dependencies
- Use `pnpm remove` for removing packages

#### Workspace Management
- Leverage pnpm workspaces for monorepo management
- Use `pnpm -F` for running commands in specific workspaces
- Configure `pnpm-workspace.yaml` for defining workspace structure

#### Dependency Management Best Practices
- Use `pnpm-lock.yaml` for precise dependency locking
- Commit `pnpm-lock.yaml` to version control
- Regularly update dependencies using `pnpm update`
- Use `pnpm audit` to check for security vulnerabilities

#### Script Execution
- Use `pnpm run` or `pnpm` to execute scripts defined in `package.json`
- Prefix workspace-specific scripts with workspace name

#### Performance Optimization
- Utilize pnpm's built-in performance optimizations
- Use `pnpm store prune` to clean unused packages
- Enable content-addressable storage for efficient package management

#### Example Workspace Configuration
```yaml
# pnpm-workspace.yaml
packages:
  - 'app/*'
  - 'packages/*'
```

#### Example Package Scripts
```json
{
  "scripts": {
    "build": "pnpm run build -F web",
    "test": "pnpm run test -r",
    "lint": "pnpm run lint -r"
  }
}
```

#### Continuous Integration
- Configure CI/CD pipelines to use `pnpm`
- Use `pnpm ci` for clean, reproducible installations in CI environments
- Cache `pnpm` store in CI to improve build times

#### Version Management
- Use `pnpm version` for managing package versions
- Follow semantic versioning principles
- Use `pnpm publish` for publishing packages to registries

#### Troubleshooting
- Use `pnpm why` to understand dependency trees
- Use `pnpm list` to view installed packages
- Clear cache with `pnpm store clean` if experiencing dependency issues

- Always look at the components folder first to see if there is anything you can reuse before creating a new one
- Use icons from the existing package instead of generating the SVG inline (lucide-icons)
